<!DOCTYPE html>
<html>
    
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>[필기] 컴퓨터공학과 &lt;데이터베이스&gt; 과목 - 후반부 | devfreedom.github.io</title>
    <meta name="title" content="[필기] 컴퓨터공학과 &lt;데이터베이스&gt; 과목 - 후반부 | devfreedom.github.io">
    <meta name="description" content="devfreedom&#39;s personal blog">
    <meta name="keywords" content="❮필기❯,컴퓨터공학,데이터베이스,DBMS,RDBMS,SQL,eleventy,template,simple,clean">
    <meta name="author" content="devfreedom">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://devfreedom.github.io/20240207_1931_study-note_compsci_database_02/">
    <link rel="shortcut icon" type="image/png" href="/assets/img/favicon.svg">
    <link rel="apple-touch-icon" href="/assets/img/apple-touch-icon.png">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="/assets/css/main.css">
    
</head>	

<body class="flex flex-col h-screen bg-white text-gray-800 break-words">
    <header id="header" class="header-shadow bg-black px-6 py-5 z-50 fixed w-full top-0 transition-all transform ease-in-out duration-500">
    <div class="max-w-5xl mx-auto flex items-center flex-wrap justify-between">
        <div class="sm:mr-8">
            <a class="flex items-center" href="/">                              
                <span class="text-lg text-white font-semibold self-center">devfreedom.github.io</span>
            </a>
        </div>
        <nav id="menu" class="order-last md:order-none items-center flex-grow w-full md:w-auto md:flex hidden mt-2 md:mt-0">
            
            <a href="/tags" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">Categories</a>
            
            <a href="https://github.com/devfreedom" target="_blank" rel="noopener" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">GitHub</a>
            
            <a href="/about" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">About</a>
            
        </nav>
        <form id="search" action="/search" class="order-last sm:order-none flex-auto w-32 items-center justify-end hidden sm:block mt-6 sm:mt-0">
            <label class="visually-hidden" for="header-searchbox">Search here ...</label>
            <input type="text" id="header-searchbox" name="q" placeholder="Search..." class="w-full sm:max-w-xs bg-gray-200 border border-transparent float-right focus:bg-white focus:border-gray-300 focus:outline-none h-8 p-4 placeholder-gray-700 rounded text-gray-700 text-sm">
        </form>
        <div id="menu-toggle" class="flex items-center md:hidden text-gray-700 hover:text-teal-600 cursor-pointer sm:ml-6">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
    <line x1="3" y1="12" x2="21" y2="12"></line>
    <line x1="3" y1="6" x2="21" y2="6"></line>
    <line x1="3" y1="18" x2="21" y2="18"></line>
</svg>
        </div>
    </div>
</header>
    <main class="mx-7 lg:mx-6 mt-32 flex-grow">
        
        
<article class="max-w-5xl mx-auto">
    <header class="mb-14">
        <h1 class="text-3xl text-center font-bold leading-normal text-gray-900 mt-0 mb-3">[필기] 컴퓨터공학과 &lt;데이터베이스&gt; 과목 - 후반부</h1>
        <div class="text-center">Published on 7 February 2024 07:31 PM</div>
        
        <div class="mt-3 text-center">
            
            <a href="/tags/❮필기❯" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#❮필기❯</a>
            
            <a href="/tags/컴퓨터공학" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#컴퓨터공학</a>
            
            <a href="/tags/데이터베이스" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#데이터베이스</a>
            
            <a href="/tags/DBMS" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#DBMS</a>
            
            <a href="/tags/RDBMS" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#RDBMS</a>
            
            <a href="/tags/SQL" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#SQL</a>
            
        </div>
        
        
        <div class="mt-10 -mx-7 md:mx-0">
            <img class="w-full max-w-2xl mx-auto" src="/assets/img/database.jpg" width="960" height="500" alt="This post thumbnail">
        </div>
        
    </header>
    <div id="content" class="prose text-gray-800 max-w-none">
        <h1>5. Entity-Relationship Model</h1>
<h2>5-1. 엔티티, 속성, 그리고 관계</h2>
<h3>엔티티</h3>
<ul>
<li>엔티티란 '지속적인 관심의 대상'이자 '동질성을 지닌 개체 또는 행위의 집합'을 의미함
<ul>
<li>동질성 및 집합의 정의에 따라 엔티티/속성/관계의 구성과 정의도 달라짐</li>
<li>이러한 집합에 대한 명확한 정의는 데이터 모델링에서 가장 핵심적인 사안임
<ul>
<li>&quot;어떤 대상이 엔티티에 속하는지 속하지 않는지를 명확하게 구분할 수 있는가?&quot;</li>
</ul>
</li>
</ul>
</li>
<li>엔티티 정의의 조건
<ul>
<li>우리가 관리하고자 하는 것인가?</li>
<li>가로와 세로를 가진 면적/집합의 개념인가?
<ul>
<li>주로 명사로 표현되며, 집합으로써의 개념을 가짐</li>
</ul>
</li>
<li>대상들간에 동질성이 있는가?</li>
<li>다른 엔티티들과 확연히 구분되는 독립성을 가지고 있는가?</li>
<li>순수하게 엔티티로써 존재하거나, 또는 엔티티가 수행한 행위의 집합인가?</li>
</ul>
</li>
<li>엔티티의 성질
<ul>
<li>반드시 구축하고자 하는 시스템이나 업무에서 필요하고 또 관리하고자 하는 정보여야 함</li>
<li>유일한 식별자에 의해 식별 가능해야 함</li>
<li>영속적으로 존재하는 엔티티의 집합이어야 함</li>
<li>업무 프로세스가 해당 엔티티를 반드시 이용해야 함</li>
<li>엔티티는 반드시 속성을 포함해야 함</li>
<li>엔티티는 반드시 다른 엔티티와 최소 한 개 이상의 관계를 맺어야 함</li>
</ul>
</li>
<li>엔티티의 구성
<ul>
<li>엔티티 타입 = 2개 이상의 엔티티가 존재하는 엔티티의 분류 집합</li>
<li>엔티티 = 각 엔티티는 고유한 성격/특성을 표현하는 속성을 두 개 이상 지님
<ul>
<li>인스턴스 = 엔티티 집합에서의 각 개체들을 의미함
<ul>
<li>예: 직원 인스턴스 = 직원번호, 성명, 주민번호, 부서명, 입사일 ...</li>
</ul>
</li>
</ul>
</li>
<li>속성 = 업무에 필요한 엔티티를 관리하고자 하는, 더는 분리되지 않는 최소 데이터 단위
<ul>
<li>식별자 = 각 인스턴스를 지칭하거나 식별해주는 속성으로써, 하나 또는 그 이상의 속성으로 구성되어 있음
<ul>
<li>예: 직원 인스턴스
<ul>
<li>성명, 부서명, 입사일 등은 여러 직원들이 동일한 값을 가질 수 있으므로 식별성이 매우 낮음</li>
<li>각 인스턴스를 고유하게 식별 가능한 '직원번호'와 '주민번호'를 식별자로써 사용할 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>속성값 = 엔티티가 표현하는 성격/특성의 실제 값으로써 하나의 속성은 오직 하나의 속성값만을 지님</li>
</ul>
</li>
</ul>
<h3>속성</h3>
<ul>
<li>속성의 종류
<ul>
<li>기본 속성
<ul>
<li>업무 분석을 통해 바로 정의한 속성
<ul>
<li>단, 업무로부터 분석한 속성이라고 하더라도 이미 업무상 코드로써 정의된 것들은 제외됨</li>
</ul>
</li>
<li>엔티티 타입에서 가장 일반적이고 많은 비중을 차지함</li>
<li>일련번호와 같은 코드성 데이터라던가, 다른 속성으로부터 영향을 받아 생성된 속성을 제외한 모든 속성</li>
</ul>
</li>
<li>설계 속성
<ul>
<li>원래 업무에는 존재하지 않지만 설계를 하면서 도출되는 속성
<ul>
<li>업무를 규칙화하려고 속성을 새로 만들거나 변형해 정의하는 속성</li>
</ul>
</li>
<li>코드 속성은 원래 존재하던 다른 속성을 업무의 필요에 따라 변형해 만든 '설계 속성'으로 간주됨
<ul>
<li>예를 들면 일련번호와 같은 속성은 유일성을 만족하는 식별자를 부여하기 위해서 새롭게 정의된 '설계 속성'임</li>
</ul>
</li>
</ul>
</li>
<li>파생 속성
<ul>
<li>다른 속성으로부터 계산되거나 변형되어 생성되는 속성</li>
<li>다른 속성의 영향을 많이 받으므로 데이터 정합성을 유지하기 위해 유의해야 할 점들이 많음
<ul>
<li>파생 속성은 가급적 적게 정의하는 것이 좋음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>관계</h3>
<ul>
<li>관계란 엔티티간의 연관성을 의미함
<ul>
<li>엔티티와 속성의 정의에 따라 영향을 받고 다양하게 변할 수 있음</li>
<li>엔티티간의 수많은 논리적 관계 중에서 의미있고 관리할 관계만 선정해낸다는것은 쉽지 않음</li>
</ul>
</li>
<li>대응수 (mapping cardinality)
<ul>
<li>ERD에서 엔티티와 연결될 때 대응(mapping)되는 수</li>
<li>전체 참여 = 엔티티 집합에 속한 모든 엔티티 인스턴스들이 해당 관계에 참여함
<ul>
<li>예: 모든 사원은 어떠한 부서에든 속해있어야 함</li>
</ul>
</li>
<li>부분 참여 = 엔티티 집합에 속한 모든 엔티티 인스턴스들이 해당 관계에 참여하는 것은 아님
<ul>
<li>예: 모든 사원이 물류 업무에 속해있어야 하는 것은 아님</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>5-2. Entity-Relationship Diagram (ERD)</h2>
<h3>ERD란?</h3>
<ul>
<li>각 업무별로 도출된 엔티티간의 관계를 이해하기 쉽도록, 도식화된 다이어그램으로써 표시하는 방법
<ul>
<li>단순히 그림 역할을 하는 것이 아닌, 업무에서의 데이터 흐름과 프로세스의 연관성을 파악하는 중요한 산출물</li>
<li>정보공학적 프로젝트 모델링에서는 해당 업무에 가장 적절한 ERD를 그려내는 것이 중요함</li>
<li>UML 표준 표기법을 사용하는 오브젝트 모델링에서는 해당 업무에 가장 적절한 클래스 다이어그램을 그려내는 것이 중요함
<ul>
<li>오브젝트 모델링이라고 하더라도 관계형 데이터베이스를 대부분 사용하므로 ERD가 중요함
<ul>
<li>이론적으로는 엔티티/관계/속성 등이 데이터 사전이나 산출물에 의해서 분석된 상태에서 ERD를 그림</li>
<li>실무적으로는 분석된 엔티티/관계/속성이 바로 ERD에 표현되며, 이해관계자간 의사소통 과정에서 항상 이용됨</li>
</ul>
</li>
</ul>
</li>
<li>데이터 모델링 초기 단계에서부터 모델을 지나치게 상세히 표현하려고 하면 추후 ERD를 이해하거나 다루기 힘들 수 있음</li>
</ul>
</li>
<li>장점
<ul>
<li>데이터 모델을 누구나 공통된 시각으로 파악할 수 있음</li>
<li>원활한 의사소통이 가능함</li>
</ul>
</li>
</ul>
<h3>초기 ERD 표기법</h3>
<ul>
<li>초기 ERD의 특징
<ul>
<li>M:M 관계가 표현됨</li>
<li>N-ary 관계가 표현됨
<ul>
<li>두 개 이상의 엔티티 타입이 하나의 관계에 관련될 수 있음</li>
</ul>
</li>
<li>다중 관계 표현
<ul>
<li>두 엔티티 타입 사이에 둘 이상의 관계가 존재할 수 있음</li>
</ul>
</li>
<li>관계 타입도 속성을 가질 수 있음</li>
</ul>
</li>
<li>Chen 표기법
<ul>
<li>1976년 Peter Chen에 의해 고안됨</li>
<li>초기 표기법 중 하나로써 대학 교재 등에서 교육용으로 사용되며 실무에서는 사용되지 않음</li>
</ul>
</li>
<li>IDEF1X 표기법
<ul>
<li>1970년대 미국 공군에 의해 도입됨</li>
<li>마름모와 원을 사용하는 표기법</li>
<li>실무에서는 드물게 사용됨</li>
</ul>
</li>
<li>기타 표기법
<ul>
<li>ISO 표기법
<ul>
<li>기수성을 조금 더 정교하게 표현</li>
<li>거의 활용되지 않음</li>
</ul>
</li>
<li>UML 표기법
<ul>
<li>데이터 모델링에 사용되며 스테레오타입을 이용해 엔티티를 표현함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Information Engineering (IE) Notation</h3>
<ul>
<li>IE 표기법은 정보시스템 구축에 있어 데이터 분석과 데이터베이스 설계에 매우 유용한 기법
<ul>
<li>1:M 관계에서 many쪽에 까마귀발 기호를 사용하므로 'Crow's Foot Model'이라고도 불림</li>
</ul>
</li>
<li>표기 방법
<ul>
<li>예시<pre><code> Entity A                                                             Entity B
  - child                                                              - parent
  - referencing                                                        - referenced
  - subject                                                            - object

  EMPLOYEE                                                             DEPARTMENT
┌────────────────┐                                                   ┌────────────────┐
│ EMP_NO         │                                                   │ DEPT_NO        │
│ -------------- │                                                   │ -------------- │
│ NAME           │                                                   │ DEPT_TITLE     │
│ ADDRESS        │ ∋┼Θ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ │ BRANCH         │
│ DEPARTMENT     │                                                   │                │
│ PHONE_NO       │                                                   └────────────────┘
│ DEPT_NO (FK)   │ → Each of many employees         Each department ←
│                │ → must have                   could possibly has ←
└────────────────┘ → only one                    zero, one, or more ←
                   → department.                         employees. ←
</code></pre>
</li>
<li>엔티티 타입
<ul>
<li>직사각형을 그리고 직사각형 바깥 좌측 상단에 엔티티 타입 이름을 적음</li>
<li>서브타입이 있는 경우,
<ul>
<li>배타적 서브타입
<ul>
<li>슈퍼타입은 최대 1개의 서브타입과 관련될 수 있음
<ul>
<li>예: 직원은 '정규직' 또는 '계약직'중 하나에만 속해야 함</li>
</ul>
</li>
<li>관계를 나타내는 실선 혹은 직선 가운데에다가 '속이 비어있는 위쪽 반원 (closed upper-half circle) 내부에 X를 그린 기호'를 사용해서 서브타입들을 분기</li>
</ul>
</li>
<li>포괄적 서브타입
<ul>
<li>슈퍼타입은 1개 이상의 서브타입과 관련될 수 있음
<ul>
<li>예: 서류 제출은 '인터넷 제출'을 했더라도 추가 서류를 '방문 제출'로 다시 할 수 있음</li>
</ul>
</li>
<li>관계를 나타내는 실선 혹은 직선 가운데에다가 '속이 비어있는 위쪽 반원 (closed upper-half circle) 기호'를 사용해서 서브타입들을 분기</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>속성
<ul>
<li>직사각형 내부 좌측 상단에는 식별자를 적음</li>
<li>식별자 아래에 수평선을 그어 나머지 속성들과 구분함</li>
</ul>
</li>
<li>관계
<ul>
<li>선의 종류로써 식별 관계를 나타냄
<ul>
<li>실선 = 식별 관계 = 관계를 통해 이주한 부모 엔티티의 식별자가 자식 엔티티의 주 식별자의 일부가 됨
<ul>
<li>예: DEPT_NO가 EMPLOYEE 엔티티의 주 식별자로써 사용됨</li>
</ul>
</li>
<li>점선 = 비식별 관계 = 부모 엔티티의 주 식별자가 자식의 non-key 영역으로 이주하고, 자식을 식별하는 데 관계하지 않음
<ul>
<li>예: DEPT_NO가 EMPLOYEE 엔티티의 외래키로써만 존재하고 주 식별자로 사용되지는 않음</li>
</ul>
</li>
</ul>
</li>
<li>선 끝에 기호를 통해 관계 형태를 나타냄<pre><code>1:1 = 하나의 A는 하나의 B로 구성되어 있다
[ENTITY A] ┼─────────────┼ [ENTITY B]     

1:M = 하나의 A는 하나 이상의 B로 구성되어 있다
[ENTITY A] ┼────────────┼∈ [ENTITY B]

1:0 or 1:1 = 하나의 A는 0개 혹은 1개의 B로 구성되어 있다 
[ENTITY A] ┼────────────Θ┼ [ENTITY B]

1:0 or 1:1 or 1:M = 하나의 A는 0개, 1개, 혹은 여러개의 B로 구성되어 있다
[ENTITY A] ┼───────────Θ┼∈ [ENTITY B]
</code></pre>
</li>
<li>다중 관계
<ul>
<li>병렬식
<ul>
<li>두 엔티티 사이에 존재하는 관계들을 별도의 관계로 간주함
<ul>
<li>두 엔티티 사각형 사이에 여러 개의 선을 긋게 됨</li>
</ul>
</li>
</ul>
</li>
<li>직렬식
<ul>
<li>두 엔티티 사이에 존재하는 몇 개의 관계를 모아 상위 개념으로써 하나로 통합 관리함
<ul>
<li>이렇게 되면 M:M 관계가 발생하게 됨<pre><code>예: (고객) ∋───────────∈ (보험계약)
</code></pre>
</li>
<li>이를 해소하기 위해 병렬로 정의되었던 여러 관계들을 모두 묶어 새로운 명칭의 관계로써 통합<pre><code>예: (보험계약 관련자) ─────&lt;배타적 서브타입 기호&gt;───── (계약자)(피보험자)(수익자)...
</code></pre>
<ul>
<li>이 경우 각각의 관계들이 서로 섞이지 않도록 하기 위해 서브타입 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Barker's Notation</h3>
<ul>
<li>1980년대에 영국 컨설팅 기업 CACI에서 근무하던 Richard Barker에 의해 개발된 표기법
<ul>
<li>Oracle에서 Richard Barker의 Case*Method를 채택해서 사용</li>
<li>IE 표기법과 유사하나 일부 다름</li>
</ul>
</li>
<li>표기 방법
<ul>
<li>예시:<pre><code> Entity A                                                         Entity B
  - child                                                          - parent
  - referencing                                                    - referenced
  - subject                                                        - object
┌────────────────┐                                               ┌────────────────┐
│ EMPLOYEE       │                                               │ DEPARTMENT     │
│                │                                               │                │
│ # EMP_NO       │ ASSIGN                                        │ # DEPT_NO      │
│ * NAME         │ ∋────────────────────── ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │ * DEPT_TITLE   │
│ * DEPARTMENT   │                                        BELONG │ o BRANCH       │
│ o PHONE_NO     │                                               └────────────────┘
│ o ADDRESS      │ → Each of employees         Each department ←
│ * DEPT_NO (FK) │ → must have              could possibly has ←
└────────────────┘ → only one                      one or more ←
                   → department.                    employees. ←
</code></pre>
</li>
<li>엔티티 타입
<ul>
<li>둥근 모서리를 가진 사각형을 그리고, 사각형 내부 좌측 상단에 엔티티 타입 이름을 적음</li>
<li>서브타입이 있는 경우에는 엔티티 사각형 내부에다가 또다른 사각형들을 그려서 표시
<ul>
<li>서브타입은 서로 중복을 허락하지 않는 상호 배타적 관계</li>
</ul>
</li>
</ul>
</li>
<li>속성
<ul>
<li>엔티티명 아래에다가 식별자를 비롯한 속성들의 이름을 목록으로 적어 내려감</li>
<li>식별자에 해당되는 속성 이름 앞에다가는 식별자의 종류를 나타내는 기호를 붙여줌
<ul>
<li><code>#</code> = 식별자에 해당되는 속성임을 표시</li>
<li>논리적 모델링의 경우 반드시 (FK)를 표시해주어야 함</li>
</ul>
</li>
<li>식별자가 아닌 속성 이름 앞에다가는 속성값의 조건을 나타내는 기호를 붙여줌
<ul>
<li><code>*</code> = mandatory = 해당 속성은 반드시 어떠한 값을 가져야 함</li>
<li><code>o</code> = optional = 해당 속성에 값이 존재할 수도 있고 없을 수도 있음 (null값 허용)</li>
</ul>
</li>
</ul>
</li>
<li>관계
<ol>
<li>해당 엔티티의 가까운 위치에 관계 구문을 기반으로 함
<ul>
<li>관계 구문 구성
<ol>
<li>(각 / 임의의 / 하나의) (엔티티1) 은</li>
<li>(하나의 / 하나 이상의) (엔티티2)에
<ul>
<li>1:1인지 1:M인지, 즉 관계 형태를 의미함</li>
</ul>
</li>
<li>(관계명)이</li>
<li>(반드시 되어야 한다 / 될 수도 있다)
<ul>
<li>필수 참여인지 선택 참여인지, 즉 관계 사양을 의미함</li>
</ul>
</li>
</ol>
<ul>
<li>한쪽 엔티티를 기준으로 상대 엔티티와의 관계를 규명하고, 반대로 다시 한번 규명함
<ul>
<li>예: 각 사원은 하나의 부서에 소속이 반드시 되어야 한다 / 각 부서는 하나 이상의 사원이 소속이 될 수도 있다</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>두 엔티티 타입을 나타내는 사각형 사이에다가 관계 형태와 관계 사양을 의미하는 선을 그어줌
<ul>
<li>선의 종류로써 관계 사양을 나타냄
<ul>
<li>실선 = 필수 참여</li>
<li>점선 = 선택 참여</li>
</ul>
</li>
<li>선 끝에 기호를 통해 관계 형태를 나타냄<pre><code>[ENTITY A] ──────────────── [ENTITY B]      1:1 관계를 의미

[ENTITY A] ───────────────∈ [ENTITY B]      1:M 관계를 의미

[ENTITY A] ∋──────────────∈ [ENTITY B]      M:M 관계를 의미



- 참고사항 - 

────┼∈ [ENTITY]
이렇게 세로로 직선이 그어져 있는 것을 UID bar라고 하며, 
식별자의 식별 관계와 종속성 등을 나타냄

Case*Method에서는 UID bar를 사용하지 않고 생략함
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li>다중 관계
<ul>
<li>병렬식
<ul>
<li>두 엔티티 사이에 존재하는 관계들을 별도의 관계로 간주함
<ul>
<li>두 엔티티 사각형 사이에 여러 개의 선을 긋게 됨</li>
</ul>
</li>
</ul>
</li>
<li>직렬식
<ul>
<li>두 엔티티 사이에 존재하는 몇 개의 관계를 모아 상위 개념으로써 하나로 통합 관리함
<ul>
<li>이렇게 되면 M:M 관계가 발생하게 됨<pre><code>예: (제품) ∋───────────∈ (공급자)
</code></pre>
</li>
<li>이를 해소하기 위해 병렬로 정의되었던 여러 관계들을 모두 묶어 새로운 명칭의 관계로써 통합<pre><code>예: (제품) ─ ─ ─ ─────∈ (제품공급목록) ∋───── ─ ─ ─ (공급자)
</code></pre>
<ul>
<li>이 경우 각각의 관계들이 서로 섞이지 않도록 하기 위해 서브타입 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>순환 관계
<ul>
<li>하나의 엔티티가 자기 자신과 관계를 맺는 경우</li>
<li>예: 여러 조직들이 트리 구조로 구성되어 있는 경우, 조직 속에 조직이 속하면서도 또한 조직이 조직을 구성되게 됨</li>
</ul>
</li>
<li>배타적(exclusive)/아크(arc) 관계
<ul>
<li>어떤 엔티티가 두 개 이상의 다른 엔티티들의 합집합과 관계를 맺는 경우</li>
<li>예: (출고) --- (공정)(창고)(외주 가공처)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1>6. 정규화 (normalization)</h1>
<h2>6-1. 이상 상태 (anomaly)</h2>
<h3>바람직한 데이터베이스란</h3>
<ul>
<li>하나의 릴레이션에 속한 각 튜플은 실세계에 존재하는 하나의 엔티티만을 표현해야 함</li>
<li>릴레이션의 각 튜플은 하나의 엔티티 또는 관계 인스턴스를 표현해야만 함</li>
<li>서로 다른 엔티티들의 속성은 하나의 테이블에 섞여서 나타나면 안됨</li>
<li>다른 엔티티를 참조하기 위해서는 외래키를 사용해야만 함</li>
<li>'엔티티'와 '관계'는 최대한 서로 분리시켜야 함</li>
</ul>
<h3>이상 상태</h3>
<ul>
<li>실제 DB 운영 시 직면하는 문제
<ul>
<li>대량의 운영 데이터를 어떻게 조직하고 효율적으로 관리할 것인가?</li>
<li>관계형 모델을 어떻게 이용해 실세계를 잘 표현할 것인가?</li>
<li>DB 내에 어떤 릴레이션들이 필요하며, 각 릴레이션은 어떤 속성들로 구성할 것인가?</li>
</ul>
</li>
<li>속성들 사이의 관계성을 제대로 고려하지 않으면 실제 데이터 처리 과정에서 이상 상태가 발생
<ul>
<li>예: 수강(학번, 과목명, 성적, 학년) 릴레이션<pre><code>STUDENT_NO      SUBJECT          GRADE      YEAR
------------------------------------------------
013             ECON_0027        85         1
013             ECON_8248        90         1
014             PHYS_1210        77         2
014             PHYS_1941        86         2
015             BCHM_3503        92         4
</code></pre>
</li>
<li>중복된 데이터의 저장이 발생됨
<ul>
<li>= 릴레이션의 어떠한 튜플이 여러개의 엔티티를 표현하고 있음
<ul>
<li>저장 공간이 낭비됨</li>
<li>처리 작업에서 이상 상태 발생</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>이상상태의 종류
<ul>
<li>삽입 이상
<ul>
<li>특정 정보를 추가하기 위해서는 원하지 않는 다른 정보도 함께 추가할 수밖에 없도록 잘못 설계된 경우에 발생
<ul>
<li>예: 새로운 016번 학생의 학년을 입력하기 위해서는 어쩔 수 없이 수강하지도 않는 과목명과 있지도 않은 성적을 입력해야 함</li>
</ul>
</li>
</ul>
</li>
<li>삭제 이상
<ul>
<li>특정 정보를 삭제하기 위해서는 다른 정보도 함께 연쇄적으로 삭제(triggered deletion)되게끔 잘못 설계되어 정보 손실이 발생하는 경우
<ul>
<li>예: 015번 학생이 BCHM_3503 과목의 최종 성적 및 수료를 중도 포기해 해당 튜플을 삭제할 경우, 해당 학생의 학년 정보도 같이 사라져버림</li>
</ul>
</li>
</ul>
</li>
<li>변경/갱신 이상
<ul>
<li>특정 정보를 변경하거나 갱신하기 위해서는 다른 정보도 모두 바꾸어줘야만 되게끔 잘못 설계된 경우에 발생
<ul>
<li>예: 013번 학생의 학년이 1학년으로 잘못 입력되어 있어 이를 3학년으로 바꾸어야 하는 경우, 두 개의 튜플을 모두 바꾸어주어야 함</li>
</ul>
</li>
<li>중복 데이터의 일부 갱신에 따른 불일치(inconsistency) 문제가 발생할 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>이상상태의 원인
<ul>
<li>릴레이션의 어떠한 튜플이 여러 개의 엔티티에 대한 정보를 담고 있음</li>
<li>릴레이션 내에 여러 속성들간의 연관성이 중복되어 나타남
<ul>
<li>예: 수강(학번, 과목명, 성적, 학년) 릴레이션
<ul>
<li>014번 학생의 성적 엔티티와 학년 엔티티가 혼재되어 나타남</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>이상상태의 해결
<ul>
<li>속성들 간의 여러 연관 관계를 분해해 별개의 릴레이션으로 표현해주어야 함
<ul>
<li>하나의 연관 관계는 하나의 릴레이션에서만 나타나도록 설계해주는 과정을 정규화(normalization)이라고 함
<ul>
<li>일련의 제약조건을 만족하는 릴레이션을 '정규형(normal form)'이라고 함</li>
<li>정규화란 '스키마 변환을 통해 정규형을 만들어주는 것'을 의미</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>6-1. 정규화와 정규형</h2>
<h3>정규화</h3>
<ul>
<li>정규화의 목적
<ul>
<li>데이터의 삽입/삭제/변경시에 발생하는 이상 상태를 릴레이션을 분해함으로써 해결하기 위함
<ul>
<li>데이터를 검색할 때는 이상 상태가 발견되지 않음</li>
</ul>
</li>
<li>다만 릴레이션들이 분해되므로, 검색을 통해 원하는 정보를 얻기 위해서는 오버헤드가 큰 JOIN 연산이 필요하게 됨
<ul>
<li>따라서 데이터 처리 과정에서 이상 상태가 발견되지 않는다면 굳이 정규화를 할 필요가 없음!</li>
</ul>
</li>
</ul>
</li>
<li>정규화의 종류
<ul>
<li>함수 종속에 기반한 정규화 과정
<ul>
<li>제1정규형 = 1NF</li>
<li>제2정규형 = 2NF</li>
<li>제3정규형 = 3NF</li>
<li>BCNF</li>
</ul>
</li>
<li>다치 종속과 조인 종속에 기반한 고급 정규화 과정
<ul>
<li>제4정규형 = 4NF</li>
<li>제5정규형 = 5NF</li>
</ul>
</li>
</ul>
</li>
<li>정규화의 원칙
<ul>
<li>정보 표현의 무손실
<ul>
<li>스키마를 변환할 때 정보의 손실이 있어서는 안됨</li>
<li>변환 전 스키마가 포함하고 있던 모든 정보는 변환된 스키마도 포함하고 있어야 함</li>
</ul>
</li>
<li>데이터 중복의 최소화</li>
<li>분리의 원칙
<ul>
<li>하나의 독립된 관계성은 별도의 분리된 릴레이션으로 표현함</li>
<li>각 릴레이션을 독립적으로 처리할 수 있는 기초가 됨</li>
</ul>
</li>
<li>무손실 분해/조인
<ul>
<li>분해된 테이블들을 모두 합쳐 자연 조인했을 때 추가적인 튜플이 생성되지 않아야 함</li>
<li>원본 릴레이션에서 얻을 수 있는 정보는 분해된 릴레이션들로부터도 얻을 수 있어야 함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>제1정규형</h3>
<ul>
<li>모든 속성의 도메인이 원자값으로 이루어져 있는 릴레이션을 의미
<ul>
<li>모든 관계형 릴레이션은 제1정규형을 만족함
<ul>
<li>튜플의 유일성</li>
<li>튜플의 무순서성</li>
<li>속성의 원자성</li>
<li>속성의 무순서성</li>
</ul>
</li>
</ul>
</li>
<li>제1정규형은 이상 상태를 발생시킬 수 있음
<ul>
<li>이상상태 원인
<ul>
<li>기본키로 식별되는 엔티티와는 무관한 정보들이 존재하기 때문
<ul>
<li>기본키에 '부분 함수 종속'된 속성들이 존재함</li>
</ul>
</li>
<li>한 튜플 내에 여러 엔티티들이 혼재되어 나타나기 때문</li>
<li>튜플 내에 여러개의 속성들간에 연관성이 있기 때문</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>제2정규형</h3>
<ul>
<li>제2정규형이란, '1NF를 만족하면서, 키에 속하지 않은 속성들이 모두 기본키에 '완전 함수 종속'된 경우'를 의미
<ul>
<li>함수 종속(functional dependency)
<ul>
<li>X→Y = 결정자(determinant)인 속성 X의 값에 대해서 종속자(dependent)인 속성 Y의 값이 하나만 연관될 때, 속성 X는 속성 Y에 '함수 종속'된다고 표현함
<ul>
<li>속성들간의 연관성을 의미함</li>
</ul>
</li>
<li>함수 종속의 분류
<ul>
<li>완전 함수 종속 = X의 부분집합 X'에 대해서 X'→Y를 만족하는 X'가 존재하지 않을 때</li>
<li>부분 함수 종속 = X의 부분집합 X'에 대해서 X'→Y를 만족하는 X'가 존재할 때</li>
</ul>
</li>
<li>함수 종속의 특징
<ul>
<li>릴레이션에서 속성 X가 키인 경우, 모든 속성 Y에 대해서 X→Y 성립
<ul>
<li>예: 기본키인 '학번' 속성의 값이 정해지면, 해당 학번에 대한 학생은 오직 하나만 존재함</li>
</ul>
</li>
<li>X→Y가 성립할 때, 릴레이션에서 속성 X가 반드시 키여야 하는 것은 아님
<ul>
<li>예: 만약 1학생 1전담강사 정책이 있다고 하면, '전담 강사' 속성이 키가 아니더라도 해당 전담 강사에 대한 학생은 오직 하나만 존재함</li>
</ul>
</li>
<li>속성 X의 어떠한 값에 대응되는 Y의 값을 가지는 튜플이 두 개 이상일 수 있음
<ul>
<li>단, 여러 튜플들은 같은 값을 가지며 결과적으로 속성값은 하나만 존재함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>1NF에 무손실 분해/조인을 적용해 2NF로 정규화
<ul>
<li>제1정규형인 릴레이션 R(A, B, C)에서 함수 종속 B→C가 존재할 경우, R1(A, B)와 R2(B, C)로 프로젝션 분해하면 무손실 분해가 됨
<ul>
<li>예: 학적 릴레이션 = 학번(PK), 과목명(CK), 지도교수, 학과명, 성적
<ul>
<li>수강 릴레이션 = 학번(PK) / 과목명(CK) → 성적</li>
<li>학과 릴레이션 = 학번 → 지도교수 → 학과명</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>제2정규형은 여전히 이상 상태를 발생시킬 수 있음
<ul>
<li>이상상태 종류
<ul>
<li>삽입 이상
<ul>
<li>예: 학과 릴레이션에서 새로운 '학번'을 배정하지 않고는 학과를 만들 수 없음</li>
</ul>
</li>
<li>삭제 이상
<ul>
<li>예: 학과 릴레이션에서 학생이 단 한명뿐인 학과의 경우, 해당 학생이 중퇴를 해서 학번이 사라지면 그 학생이 속한 학과도 함께 없어짐</li>
</ul>
</li>
<li>갱신 이상
<ul>
<li>예: 학과 릴레이션에서 특정 학생의 학과가 변경될 경우, 해당 학과에 속한 다른 학생 역시 학과명이 변경되어야 함</li>
</ul>
</li>
</ul>
</li>
<li>이상상태 원인
<ul>
<li>기본키 이외의 다른 속성에 의해서 그 값이 결정되는 속성이 있기 때문
<ul>
<li>예: 학과 릴레이션의 경우 학과명이 '학번'이 아닌 '지도교수'에 의해 결정되고 있음</li>
<li>릴레이션에서 각 튜플은 하나의 엔티티 또는 관계 인스턴스를 표현해야만 함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>제3정규형</h3>
<ul>
<li>제3정규형이란, '2NF를 만족하면서, 키가 아닌 속성들은 기본키에 이행적 함수 종속이 되지 않은 경우'를 의미
<ul>
<li>이행적 종속 = if A→B &amp; A→C, then A→C</li>
<li>R(A, B, C)를 분해한 제2정규형이라고 하더라도 A→B와 B→C 사이에 A→C인 함수 종속이 여전히 존재함
<ul>
<li>예: 학과 릴레이션에서 '학번(PK)→성적'과 '지도교수→학과명'으로 나눴어도 '학번→학과명'이 존재</li>
</ul>
</li>
</ul>
</li>
<li>2NF에 무손실 분해를 적용해 이행적 함수 종속을 제거하고 3NF로 정규화
<ul>
<li>예: 학과 릴레이션 = 학번 → 지도교수 → 학과명
<ul>
<li>학과 릴레이션 = 학과명 → 지도교수</li>
<li>학생 소속 릴레이션 = 학번 → 학과명</li>
</ul>
</li>
</ul>
</li>
<li>(속성이 2개인) 이진 릴레이션은 기본적으로 제3정규형에 속함
<ul>
<li>이행적 함수 종속이 발생하기 위해서는 A, B, C라는 최소한 3개의 속성이 필요하기 때문</li>
<li>속성이 2개만 존재하면 이행적 함수 종속이 존재할 수 없음</li>
</ul>
</li>
<li>제3정규형은 여전히 이상 상태를 발생시킬 수 있음
<ul>
<li>이진 릴레이션이 아니더라도 제3정규형이 될 수 있기 때문
<ul>
<li>복수의 후보키를 가지고 있음</li>
<li>후보키들이 여러개의 속성들로 구성되어 있음</li>
<li>후보키들의 속성이 서로 중첩되어 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>BCNF (Boyce-Codd normal form)</h3>
<ul>
<li>BCNF이란, '3NF를 만족하면서 릴레이션에 속한 결정자가 후보키인 경우'를 의미
<ul>
<li>모든 속성은 후보키에 의해 결정됨</li>
<li>하나의 튜플은 하나의 엔티티를 표현함</li>
</ul>
</li>
<li>관계형 데이터베이스 설계 목표는 바로 각 릴레이션이 BCNF를 만족하게 하는 것
<ul>
<li>BCNF = 강력한 3NF</li>
<li>참고로 이진 릴레이션은 BCNF에도 속함</li>
</ul>
</li>
</ul>
<h3>제4정규형</h3>
<ul>
<li>다치 종속 (multivalued dependency)
<ul>
<li>속성 X의 값이 하나 결정될 때, 속성 Y의 여러 값들이 결정되는 경우 &quot;X는 Y를 다중 결정한다&quot;라고 함</li>
<li>예: '과목'이 결정될 때, 해당 과목에 사용될 여러 '교재'들이 결정되는 경우</li>
</ul>
</li>
<li>릴레이션 R의 모든 비단순 다치 종속 X→Y를 만족하는 속성 X,Y가 존재할 때, X가 R의 슈퍼키인 경우, 릴레이션 R은 제4정규형에 해당됨</li>
<li>4NF 특징
<ul>
<li>BCNF와 제3정규형과는 달리 제4정규형은 '다치 종속성'을 다룸</li>
<li>제4정규형을 만족하는 모든 릴레이션은 BCNF 역시 만족함</li>
</ul>
</li>
</ul>
<h3>제5정규형</h3>
<ul>
<li>조인 종속 (join dependency)
<ul>
<li>릴레이션 R이 그 프로젝션 릴레이션인 R1, R2, R3, ..., Rn의 조인과 동일한 경우 &quot;R은 조인 종속성을 만족한다&quot;라고 함</li>
</ul>
</li>
<li>릴레이션 R에 존재하는 모든 조인 종속에 대해, 모든 조인 종속 릴레이션이 R의 후보키라면, 릴레이션 R은 제5정규형에 해당됨
<ul>
<li>조인 종속성을 발견하는 것은 매우 어려우므로 실무에서 5NF를 사용하는 경우는 거의 없음</li>
</ul>
</li>
</ul>
<hr>
<h1>7. Transaction &amp; View</h1>
<h2>7-1. 트랜잭션</h2>
<h3>트랜잭션이란?</h3>
<ul>
<li>논리적인 일의 단위
<ul>
<li>하나의 SQL문 = 하나의 트랜잭션</li>
<li>여러개의 SQL문들이 묶여 하나의 트랜잭션이 될 수 있음</li>
</ul>
</li>
<li>트랜잭션이 필요한 이유
<ul>
<li>동시성(concurrency) 제어
<ul>
<li>다수의 사용자나 여러 애플리케이션들이 데이터베이스에 동시에 접근하고 연산이 수행되더라도, 서로 간섭하지 못하도록 제어해서 데이터베이스의 일관성을 유지함</li>
<li>동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향이, 이들을 순차적으로 수행했을때와 동일하도록 보장해주는 역할</li>
<li>트랜잭션 단위로 동시성을 제어할 수 있음</li>
</ul>
</li>
<li>회복
<ul>
<li>데이터베이스를 갱신하는 도중 시스템 고장이 발생하더라도 데이터베이스의 일관성을 유지함</li>
<li>트랜잭션 단위로 회복을 수행할 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>트랜잭션 제어문(Transaction Control Language; TCL)을 사용함
<ul>
<li>COMMIT
<ul>
<li>트랜잭션의 마지막 명령어가 수행됨</li>
<li>트랜잭션에 의한 변경을 확정함
<ul>
<li>철회 불가능</li>
</ul>
</li>
<li>명령문을 실행하기 전에, 하나의 트랜잭션을 변경한 결과를 다른 트랜잭션에서 접근할 수 없도록 방지해 일관성 유지</li>
</ul>
</li>
<li>ROLLBACK
<ul>
<li>트랜잭션의 변경을 취소하고 트랜잭션을 종료함
<ul>
<li><code>ROLLBACK TRAN savepoint_name</code></li>
</ul>
</li>
</ul>
</li>
<li>SAVEPOINT
<ul>
<li>현재 트랜잭션으로부터 ROLLBACK시킬 위치를 지정
<ul>
<li><code>SAVE TRAN savepoint_name</code></li>
</ul>
</li>
<li>대규모 트랜잭션에서 오류가 발생하면 전체 트랜잭션을 취소시키는것이 큰 부담이 될 수 있음
<ul>
<li>실패한 일정 부분만 취소시키기</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>트랜잭션 모드
<ul>
<li>자동 커밋 트랜잭션
<ul>
<li>하나의 명령문이 하나의 트랜잭션이 됨</li>
<li>MS-SQL 기본 모드</li>
</ul>
</li>
<li>명시적 트랜잭션
<ul>
<li>명시적으로 사용자가 트랜잭션을 정의함</li>
<li>예: <code>BEGIN TRAN ~ COMMIT(or ROLLBACK) TRAN</code></li>
</ul>
</li>
<li>묵시적 트랜잭션
<ul>
<li>자동 커밋 트랜잭션과 반대되는 개념</li>
<li>사용자가 COMMIT/ROLLBACK TRAN을 입력하기 전까지, 복수개의 명령문을 기본적으로 하나의 트랜잭션으로 간주
<ul>
<li>BEGIN TRAN 명령이 필요 없음</li>
</ul>
</li>
<li>설정 방법
<ul>
<li><code>SET IMPLICIT TRANSACTIONS {ON or OFF}</code></li>
<li>트랜잭션의 종료마다 사용자가 반드시 COMMIT/ROLLBACK 명령문을 실행시켜야 함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>ACID 원칙</h3>
<ul>
<li>트랜잭션이 만족해야 하는 4가지 특성
<ul>
<li>Atomicity = 원자성
<ul>
<li>한 트랜잭션 내의 모든 연산들은 '완전히 수행됨' 또는 '전혀 수행되지 않음' 중 하나의 상태만을 가짐
<ul>
<li>All or Nothing</li>
</ul>
</li>
<li>연산 처리 도중 시스템이 다운되더라도, DBMS의 회복 모듈은 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소하는 방법을 통해 트랜잭션의 원자성을 보장함</li>
<li>완료된 트랜잭션이 갱신했던 사항은 트랜잭션의 영향을 다시 수행하는 방법을 통해 트랜잭션의 원자성을 보장함</li>
</ul>
</li>
<li>Consistency = 일관성
<ul>
<li>어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면, 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐</li>
<li>트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 이러한 일관성을 갖지 않을 수도 있음</li>
<li>DBMS에서 관리하는 '무결성 제약조건'과 관련이 있음</li>
</ul>
</li>
<li>Isolation = 격리성
<ul>
<li>한 트랜잭션이 데이터를 갱신하는 동안, 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함</li>
<li>다수의 트랜잭션들이 동시에 수행되더라도, 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
<ul>
<li>= 동시성 제어</li>
</ul>
</li>
<li>DBMS의 동시성 제어 모듈은 다양한 고립 수준에 기반해 트랜잭션의 고립성을 보장함</li>
</ul>
</li>
<li>Durability = 영속성
<ul>
<li>일단 한 트랜잭션이 완료되면, 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음</li>
<li>완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 지속됨</li>
<li>DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>트랜잭션의 상태</h3>
<pre><code>                                    The state where                            The state where
                                    the last command                           the transaction
                                    has been executed                          has been applied
                                  (PARTIAL COMPLETION)

 EXECUTE → [ EXECUTE COMMAND ] →         COMMIT         → [ OUTPUT TO DISK ] → [ COMPLETION ]
         ↘          ↓           
           [      ERROR      ] → [       FAILURE      ] →      ROLLBACK      → [ WITHDRAWAL ]
          (logical or hardware)     
                                    The state where                            The state where
                                    the transaction                            the transaction
                                    has been failed                            has been undo-ed

                                                                             (transaction pending)
                                                                             (transaction restart)
</code></pre>
<ul>
<li>부분 완료
<ul>
<li>COMMIT 명령문을 받은 상태</li>
</ul>
</li>
<li>완료
<ul>
<li>모든 트랜잭션 결과를 DB에 반영한 상태</li>
</ul>
</li>
<li>실패
<ul>
<li>트랜잭션의 실패</li>
<li>실패 상태에 놓인 트랜잭션에 취할 수 있는 조치
<ul>
<li>트랜잭션의 재시작
<ul>
<li>하드웨어나 시스템 오류로 인해 철회된 트랜잭션은 다시 새로운 트랜잭션으로 취급되어 재시작됨</li>
</ul>
</li>
<li>트랜잭션의 폐기
<ul>
<li>트랜잭션의 내부적 오류로 인해, 또는 취급하려는 데이터가 없기 때문에 철회된 트랜잭션은 폐기됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>철회
<ul>
<li>ROLLBACK 명령문에 의해서, 트랜잭션의 모든 결과가 취소되고 트랜잭션 이전의 원래 상태로 돌려놓아진 상태</li>
</ul>
</li>
</ul>
<h2>7-2. 뷰</h2>
<h3>뷰의 개념</h3>
<ul>
<li>하나 이상의 기본 테이블이나 다른 뷰를 이용해서 생성되는 '가상의 테이블'
<ul>
<li>기본 테이블은 디스크에 공간이 할당되어 데이터를 저장함</li>
<li>뷰의 경우에는 데이터 딕셔너리 테이블에 뷰에 대한 정의(SQL문)만 저장되므로 디스크 저장 공간 할당이 이루어지지 않음</li>
<li>뷰를 활용하면 전체 데이터 중에서 일부만 접근할 수 있도록 할 수 있음
<ul>
<li>뷰에 대한 수정 결과는 뷰를 정의한 기본 테이블에 적용됨</li>
<li>뷰를 정의한 기본 테이블에서 정의된 무결성 제약조건은 그대로 유지됨</li>
</ul>
</li>
</ul>
</li>
<li>뷰의 필요성
<ul>
<li>사용자마다 특정 객체만 조회할 수 있도록 할 필요가 있음
<ul>
<li>모든 직원에 대한 정보를 모든 사원이 볼 수 있도록 해서는 안됨</li>
</ul>
</li>
<li>복잡한 쿼리문을 단순화할 수 있음</li>
<li>데이터의 중복성을 최소화할 수 있음
<ul>
<li>예: 회계 부서에 속한 사원들만 따로 관리하고 싶을 때, 이들을 사원 테이블에서 찾아서 별개의 테이블로 만들어 관리하면 데이터 중복성 문제가 발생함</li>
</ul>
</li>
</ul>
</li>
<li>뷰의 장점
<ul>
<li>논리적 독립성 제공</li>
<li>데이터의 접근과 보안을 제어</li>
<li>사용자의 데이터 관리를 단순화할 수 있음</li>
<li>여러 사용자의 다양한 데이터 요구를 지원하고 반영함</li>
</ul>
</li>
<li>뷰의 단점
<ul>
<li>뷰의 정의를 변경할 수 없음</li>
<li>삽입/삭제/갱신 연산에 제한이 있음</li>
</ul>
</li>
<li>뷰의 종류
<ul>
<li>원천 테이블의 개수에 따른 분류
<ul>
<li>단순뷰 = 하나의 기본 테이블 위에 정의된 뷰</li>
<li>복합뷰 = 두 개 이상의 기본 테이블로부터 파생된 뷰</li>
</ul>
</li>
<li>인라인(inline) 뷰
<ul>
<li>하나의 쿼리문 내에서만 사용되고, 쿼리 수행 종료 후에는 사라지는 1회성 뷰
<ul>
<li>뷰의 명시적인 선언(CREATE VIEW)이 없음</li>
<li>FROM 절에서 참조하는 테이블의 크기가 클 경우, 필요한 행과 속성만으로 구성된 집합으로 뷰를 별도로 정의해 쿼리문을 효율적으로 구성할 수 있음</li>
<li>FROM 절에서 서브쿼리를 사용해서 생성하는 임시 뷰
<ul>
<li>예: 부서별 평균 급여를 '사원 테이블'과 '부서 테이블' 조인을 통해 부서 번호와 부서명 기반으로 파악하는 경우<pre><code>SELECT dept_no, AVG(salary) AS avg_sal
FROM employee
GROUP BY dept_no

SELECT dept_name, AVG(salary)
FROM department dept, employee emp
WHERE dept.dept_no = emp.dept_no
GROUP BY dept_name
</code></pre>
<ul>
<li>인라인 뷰를 사용해 부서별 부서명과 평균 급여 출력<pre><code>SELECT dept_name, avg_sal
FROM (SELECT dept_no, AVG(salary) AS avg_sal 
      FROM employee
      GROUP BY dept_no) AS sal_view, department dept      /* sal_view라는 인라인 뷰를 선언 */
WHERE sal_view.dept_no = dept.dept_no
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>WITH 절을 사용해서 인라인 뷰를 정의할 수도 있음
<ul>
<li><code>WITH temp_table(attributes...) AS (SELECT something FROM something WHERE ...)</code></li>
<li>예시<pre><code>WITH sal_view(dept_no, avg_sal)
AS (SELECT dept_no, AVG(salary)
    FROM employee
    GROUP BY dept_no)
SELECT dept_name, avg_sal
FROM sal_view, department
WHERE department.dept_no = sal_view.dept_no
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>뷰 조작 쿼리문</h3>
<ul>
<li>뷰의 생성
<ul>
<li><code>CREATE VIEW view_name AS sql_clauses</code></li>
<li>예시: <code>CREATE VIEW emp30 AS SELECT * FROM employee WHERE dept_no=30</code></li>
</ul>
</li>
<li>뷰의 삭제
<ul>
<li><code>DROP VIEW view_name</code></li>
</ul>
</li>
<li>정의된 뷰를 저장 프로시져를 실행시켜서 확인
<ul>
<li><code>EXEC SP_HELPTEXT view_name</code></li>
</ul>
</li>
</ul>
<h3>뷰의 연산</h3>
<ul>
<li>갱신 연산
<ul>
<li>무결성 제약조건, 표현식, 집단연산, GROUP BY절의 유무에 따라 DML문의 사용이 제한적임
<ul>
<li>뷰의 결과가 통계 요약을 가지고 있는 경우
<ul>
<li>통계값이므로 기본 테이블 중 어느 튜플에 반영할지를 파악하기 어려움</li>
</ul>
</li>
<li>뷰가 두 개 이상의 테이블로부터 (조인 연산) 파생된 경우
<ul>
<li>여러 개의 테이블로부터 생셩된 것이므로, 어느 테이블에 속한 튜플을 갱신해야할지 파악하기 어려움</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1>8. Indexing</h1>
<h2>8-1. 색인의 개념</h2>
<h3>데이터 조직 방법</h3>
<ul>
<li>순차 방식
<ul>
<li>튜플을 일정한 순서대로 저장하는 방법
<ul>
<li>엔트리 순차 파일
<ul>
<li>레코드가 생성되는 순서대로 저장</li>
<li>장점: 쉬운 레코드 저장</li>
<li>단점: 필요한 레코드를 찾기 위해 전체를 다 검색해야 함</li>
</ul>
</li>
<li>키 순차 파일
<ul>
<li>레코드의 키값 순서대로 저장</li>
<li>장점: 키값을 이용한 효율적 검색</li>
<li>단점: 새로운 레코드 삽입시 매우 느림</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>색인 방식
<ul>
<li>부가적인 자료 구조를 이용해 데이터의 빠른 접근을 지원하는 방법</li>
</ul>
</li>
<li>해싱 방식
<ul>
<li>hashing function을 이용해 데이터를 그룹화하는 방법</li>
</ul>
</li>
</ul>
<h3>색인(index) 이란?</h3>
<ul>
<li>검색 성능을 향상시키기 위한 부가적 자료 구조
<ul>
<li>SQL 명령문의 검색 속도를 향상시키기 위해 컬럼에 생성하는 객체</li>
<li>테이블에 저장된 데이터에다가 포인터를 사용해 랜덤 액세스</li>
</ul>
</li>
<li>인덱스가 효율적인 경우
<ul>
<li>WHERE 절이나 JOIN 조건절에서 자주 사용되는 컬럼</li>
<li>전체 데이터 중에서 10~15% 이내의 데이터를 검색하는 경우</li>
<li>두 개 이상의 컬럼이 WHERE 절이나 조인 조건에서 자주 사용되는 경우</li>
<li>테이블에 저장된 데이터의 변경이 드문 경우</li>
</ul>
</li>
<li>인덱스 조작 쿼리문
<ul>
<li>인덱스 생성: <code>CREATE INDEX index_name ON table_name(attributes...)</code></li>
<li>인덱스 삭제: <code>CREATE INDEX index_name ON table_name</code></li>
</ul>
</li>
</ul>
<h3>쿼리에 인덱스를 강제로 사용하는 방법</h3>
<ul>
<li>사용할 인덱스의 이름을 WITH 절을 사용해 `WITH(INDEX=index_name)'로 지정해주면 됨
<ul>
<li>예: <code>SELECT * FROM employee WITH(INDEX=idx_emp_name) WHERE name='John Doe'</code></li>
</ul>
</li>
</ul>
<h3>색인의 종류</h3>
<ul>
<li>속성의 유일성 기준
<ul>
<li>고유 인덱스
<ul>
<li>유일값을 가지는 속성에 대해 생성함
<ul>
<li>기본키는 중복을 허용하지 않으므로, 기본키에 대해서는 테이블이 자동으로 고유 인덱스(primary index)를 생성함</li>
</ul>
</li>
<li>각 키값은 테이블에서의 하나의 튜플과 연관됨
<ul>
<li>테이블을 검색할 때는 기본키만 사용하는 것은 아니므로, 새로운 튜플을 삽입할 때마다 해당 키값이 고유한지를 검사해야 함
<ul>
<li>테이블에 튜플들이 많다면 매우 느림</li>
<li>그래서 많이 사용되는 컬럼에다가 별도의 고유 인덱스를 보조 인덱스(secondary index)로써 생성 및 사용하면 성능이 뛰어남</li>
</ul>
</li>
</ul>
</li>
<li>고유 인덱스 생성문: <code>CREATE UNIQUE INDEX unique_index_name ON table_name(attributes...)</code></li>
</ul>
</li>
<li>비고유 인덱스
<ul>
<li>중복된 값을 가지는 속성에 생성하는 인덱스</li>
<li>각 키값은 여러 개의 튜플들과 연관됨</li>
<li>비고유 인덱스 생성문 = 인덱스 생성문 = <code>CREATE INDEX index_name ON table_name(attributes...)</code></li>
</ul>
</li>
</ul>
</li>
<li>속성의 개수 기준
<ul>
<li>단일 인덱스
<ul>
<li>하나의 속성만으로 구성된 인덱스</li>
<li>예: <code>CREATE INDEX idx_salary ON employee(salary)</code></li>
</ul>
</li>
<li>결합 인덱스
<ul>
<li>두 개 이상의 속성들에 대해서 생성된 인덱스</li>
<li>예: <code>CREATE INDEX idx_emp_no_salary ON employee(emp_no, salary)</code></li>
</ul>
</li>
</ul>
</li>
<li>정렬 순서 기준
<ul>
<li>오름차순(ascending) 인덱스
<ul>
<li>일반적인 색인들은 속성값에 대해서 오름차순으로 정렬되어 저장됨</li>
</ul>
</li>
<li>내림차순(descending) 인덱스
<ul>
<li>속성별로 정렬 순서를 내림차순으로 지정해서 결합 인덱스를 생성하는 방법</li>
</ul>
</li>
<li>색인 생성 시에 각 속성별로 오름차순/내림차순 정렬 여부를 지정해주면 됨
<ul>
<li>예: <code>CREATE INDEX idx_emp_no_salary_desc ON employee(emp_no ASC, salary DESC)</code></li>
</ul>
</li>
</ul>
</li>
<li>물리적 순서와의 일치 여부 기준
<ul>
<li>집중(clustered) 인덱스
<ul>
<li>'테이블의 튜플이 저장된 물리적 순서'가 '해당 인덱스의 키값 순서'와 동일하게 유지되도록 구성된 인덱스
<ul>
<li>예: 기본키에 대해서 생성된 인덱스
<ul>
<li>테이블의 튜플들이 기본키에 오름차순으로 정렬되어 저장되어 있다면, 기본키의 인덱스 또한 기본키에 대응해 오름차순으로 정렬되어 있음</li>
</ul>
</li>
</ul>
</li>
<li>하나의 테이블에는 하나의 집중 인덱스만 생성할 수 있음</li>
</ul>
</li>
<li>비집중(unclustered) 인덱스
<ul>
<li>집중 인덱스가 아닌 인덱스들</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>색인의 내부 구조</h3>
<ul>
<li>이진 탐색 트리란?
<ul>
<li>자식이 최대 2개</li>
<li>각 노드의 키값이 하나</li>
<li>각 노드의 키값이 왼쪽 자손 노드들의 키값보다는 항상 크고, 오른쪽 자식 노드의 키값보다는 항상 작은 이진 트리</li>
</ul>
</li>
<li>B-tree란?
<ul>
<li>이진 탐색 트리의 일반화로써, 각 노드가 두 개 이상의 자식을 가질 수 있음
<ul>
<li>자식을 최대 m개 가질 수 있는 N-ary 트리</li>
</ul>
</li>
<li>문제점
<ul>
<li>단말 노드와 비단말 노드의 구조가 다름
<ul>
<li>저장 공간이 낭비됨</li>
<li>단말 노드와 비단말 노드 사이의 변환에 비용이 많이 필요함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>인덱스와 B-tree
<ul>
<li>단말 노드와 비단말 노드의 물리적 구조를 같게 만들어 줘서 B-tree의 성능 문제 해결
<ul>
<li>순차 세트
<ul>
<li>단말 노드들로 구성함</li>
<li>테이블에 있는 모든 키값들을 포함시킴</li>
<li>키값 순서대로 연결되어 있음</li>
</ul>
</li>
<li>인덱스 세트
<ul>
<li>비단말 노드들로 구성함</li>
<li>단말 노드에 있는 키값들에 대한 접근 경로를 제공</li>
<li>인덱스 세트에 있는 키값은 테이블에 존재하지 않을 수도 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>8-2. 해싱</h2>
<h3>트리 기반 색인과의 차이</h3>
<ul>
<li>트리 기반의 인덱싱
<ul>
<li>'인덱스에 존재하는 여러 노드들을 탐색'해서 원하는 레코드를 찾는 방식임</li>
</ul>
</li>
<li>해싱
<ul>
<li>'계산을 통해 얻은 주소'에다가 데이터를 저장하는 방식임
<ul>
<li>자료를 검색할 때 키값을 비교하는 것이 아니라, 키값을 이용해서 '직접 데이터에 접근'하기</li>
<li>해시 함수가 사용됨</li>
</ul>
</li>
<li>해싱 기법은 영역 탐색을 지원하지 못함</li>
</ul>
</li>
</ul>
<h3>충돌(collision)</h3>
<ul>
<li>어떠한 해시 함수가 2개 이상의 입력값(키)에 대해 동일한 해시값을 출력하는 상황
<ul>
<li>2개 이상의 키가 동일한 해시값을 갖게 됨</li>
</ul>
</li>
<li>충돌의 방지
<ul>
<li>open hashing
<ul>
<li>같은 해시값을 갖는 키들을 바구니(주로 linked-list)에 모아 놓음</li>
<li>나중에 해당 바구니를 검색할 때는 순차 검색을 사용함</li>
</ul>
</li>
<li>extendable hashing
<ul>
<li>키값에서 일정 길이 부분의 비트를 해시값으로 사용</li>
<li>레코드들이 늘어나면 버킷을 분해함</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1>9. 장애와 회복</h1>
<h2>9-1. 장애</h2>
<h3>장애의 유형</h3>
<ul>
<li>전원 오류
<ul>
<li>하드웨어 장애</li>
</ul>
</li>
<li>트랜잭션 장애
<ul>
<li>트랜잭션의 논리적 오류로 인해 발생</li>
<li>입력 데이터 불량, 시스템 자원 과다 요구 등 트랜잭션의 내부 조건으로 인해 트랜잭션이 정상적으로 실행될 수 없는 상태</li>
</ul>
</li>
<li>시스템 장애
<ul>
<li>하드웨어 오동작으로 인한 메모리의 정보 손실</li>
<li>교착 상태 등으로 인해 더 이상 시스템이 실행되지 않는 상태</li>
</ul>
</li>
<li>미디어 장애
<ul>
<li>저장 장치의 고장이나 파손으로 인해 데이터가 손상/파괴된 상태</li>
</ul>
</li>
<li>human error
<ul>
<li>사람에 의해 발생하는 장애</li>
</ul>
</li>
</ul>
<h3>운영체제와 입출력</h3>
<ul>
<li>보조기억장치와 주기억장치 사이의 데이터 이동
<ul>
<li>보조기억장치에서 주기억장치로 데이터를 가지고 올 때 블록 또는 페이지 단위로 가지고 옴
<ul>
<li>버퍼블록 입력
<ul>
<li>데이터가 포함되어 있는 블록을 보조기억장치에서 주기억장치 버퍼로 가지고 옴 (요청에 따른 on-demand 작업)</li>
</ul>
</li>
<li>버퍼블록 출력
<ul>
<li>데이터가 포함되어 있는 버퍼 블록을 보조기억장치로 다시 이동시켜서 기록함 (buffer manager에 의한 처리)
<ul>
<li>제자리 갱신
<ul>
<li>버퍼블록을 출력할 때, 버퍼블록이 위치했던 디스크 위치에 그대로 덮어쓰는 방식</li>
</ul>
</li>
<li>간접 갱신
<ul>
<li>버퍼블록을 출력할 때, 버퍼블록이 위치했던 디스크 위치와는 다른 위치에 쓰는 방식</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>읽기 연산
<ul>
<li>읽을 데이터 X가 버퍼 블록에 없는 경우, X가 포함된 블록 Bx에 대해 버퍼블록 입력을 실행
<ul>
<li>버퍼 블록으로 옮겨진 데이터를 읽음</li>
</ul>
</li>
</ul>
</li>
<li>쓰기 연산
<ul>
<li>만약 쓰기를 수행할 데이터 X가 버퍼 블록에 없는 경우, X가 포함된 블록 Bx에 대해서 버퍼블록 입력을 실행
<ul>
<li>버퍼 블록에 데이터를 기록</li>
</ul>
</li>
</ul>
</li>
<li>버퍼 강제 출력
<ul>
<li>주기억장치의 버퍼 블록에서 메모리 공간을 필요로 할 때, 버퍼 관리자가 불가피하게 수행하는 버퍼블록 출력</li>
</ul>
</li>
</ul>
</li>
<li>데이터가 상실되는 상황
<ol>
<li>어떤 트랜잭션이 데이터를 읽기 위해 데이터 X에 접근함
<ul>
<li>내부적으로 필요에 따라 버퍼블록 입력을 실행</li>
</ul>
</li>
<li>트랜잭션이 X에 대한 연산을 마친 뒤, 변경된 X의 값을 쓰기 연산을 통해 데이터베이스 자체에 반영하려고 시도함
<ul>
<li>하지만 쓰기 연산을 위한 버퍼블록 출력은 보통 즉각적으로 실행되지는 않고 지연 및 대기됨</li>
</ul>
</li>
<li>바로 이 순간에 시스템에 장애가 발생해버린다면?
<ul>
<li>쓰기 연산 자체는 수행되었지만, 그 연산으로 인한 변경 사항이 버퍼블록 출력을 통해 보조기억장치에 물리적으로는 반영이 되지 않는 사태가 발생
<ul>
<li>데이터 X의 변경 사항이 상실되어버림</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>변경된 버퍼블록을 보조기억장치에 실제로 기록을 하는 방식
<ul>
<li>종류
<ul>
<li>Steal
<ul>
<li>트랜잭션이 완료되기 전에, 그 트랜잭션에 의해 갱신된 cache를 디스크에 기록하는 방식</li>
</ul>
</li>
<li>No-Steal
<ul>
<li>트랜잭션이 완료되기 전에는 그 트랜잭션에 의해 갱신된 cache를 디스크에 기록할 수 없는 방식</li>
</ul>
</li>
<li>Force
<ul>
<li>트랜잭션이 완료될 때, 그 트랜잭션에 의해 갱신된 cache를 즉시 디스크에 기록하는 방식</li>
</ul>
</li>
<li>No-Force
<ul>
<li>트랜잭션이 완료될 때, 그 트랜잭션에 의해 갱신된 cache를 즉시 디스크에 기록할 수 없는 방식</li>
</ul>
</li>
</ul>
</li>
<li>대부분의 DBMS들은 Steal + No-force 방식을 사용함
<ul>
<li>트랜잭션이 완료되기 전에 일단 cache를 디스크에 기록하고, 트랜잭션이 완료되더라도 새로운 cache를 디스크에 즉시 기록하지는 않음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>9-2. 회복</h2>
<h3>회복의 개념</h3>
<ul>
<li>장애가 발생되었을 때 데이터베이스를 장애 이전의 일관된 상태로 복원시키는 과정
<ul>
<li>DBMS는 장애 탐지와 데이터베이스 복원을 지원함
<ul>
<li>손상된 부분만을 포함하는 최소 단위의 회복</li>
<li>최단 시간 내에 회복</li>
<li>트랜잭션 기반의 회복</li>
<li>회복 자료의 보장</li>
<li>시스템 레벨에서의 자동 조치</li>
</ul>
</li>
</ul>
</li>
<li>회복의 기본 원리는 '데이터의 중복 보관'
<ul>
<li>데이터를 여러 곳에 복제해 놓으면, 시스템 장애 발생시 이를 사용해 복원할 수 있음</li>
<li>데이터 중복을 통한 회복
<ul>
<li>dump/backup
<ul>
<li>데이터의 전체나 일부분을 다른 저장 장치에 (주기적으로) 복제해두기</li>
</ul>
</li>
<li>log/journal
<ul>
<li>데이터베이스가 변경될 때마다, 해당 데이터베이스의 기존 값과 새로 변경된 값을 별도로 분리해 기록해 두기</li>
<li>Write-ahead Log
<ul>
<li>데이터를 디스크에 쓰기 전에, 대응되는 로그 정보를 먼저 써야한다는 로그 기반 회복 규약</li>
<li>모든 REDO 및 UNDO 유형의 로그 기록들이 '버퍼 강제 출력'을 통해 보조기억장치에 물리적으로 기록이 먼저 되어야만 트랜잭션이 완료될 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>장애 종류에 따른 회복
<ul>
<li>재해적이고 물리적인 실패
<ul>
<li>미디어 장애 및 전원 장애의 경우가 이에 해당됨</li>
<li>장애 사건 직전의 최신 복제본을 시스템에 적재시킨 뒤, 해당 목제본 이후에 일어난 변경만을 로그를 이용해 재실행시켜 복원하는 방식
<ul>
<li>회복에 백업본과 로그가 필요함</li>
</ul>
</li>
</ul>
</li>
<li>비재해적이고 논리적 실패
<ul>
<li>트랜잭션 장애 및 시스템 장애의 경우가 이에 해당됨
<ul>
<li>데이터베이스의 내용 자체는 손상되지 않고, 데이터의 변경 과정 및 변경 내용에 대한 신뢰성이 상실된 상태</li>
</ul>
</li>
<li>장애 사건 당시의 모든 변경을 취소시켜 원래의 데이터베이스 상태로 복원하는 방식
<ul>
<li>회복에 로그가 필요함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>로그 기반의 회복 기법</h3>
<ul>
<li>지연 갱신
<ul>
<li>부분 완료될 때까지의 모든 출력 연산을 지연시킴
<ul>
<li>UNDO 연산자는 불필요함</li>
<li>과정
<ol>
<li>모든 데이터베이스의 변경을 '로그'에 기록</li>
<li>안전한 저장소에 PARTIAL COMMIT을 포함하는 로그 레코드를 기록한 후에 데이터베이스를 갱신함</li>
<li>완료 상태가 됨</li>
</ol>
</li>
</ul>
</li>
<li>로그 레코드는 REDO 연산에 대비함
<ul>
<li>REDO 연산의 멱등성(idempotency)
<ul>
<li>같은 REDO 연산을 여러번 수행해도 결과는 동일함</li>
<li>REDO 작업 중 장애가 발생해 REDO 연산을 다시 실행하게 되어도 결과는 동일함</li>
</ul>
</li>
</ul>
</li>
<li>start 레코드와 commit 레코드가 모두 있는 트랜잭션만 재실행</li>
</ul>
</li>
<li>즉시 갱신
<ul>
<li>데이터의 변경 결과를 데이터베이스에 그대로 반영
<ul>
<li>REDO와 UNDO 연산자가 필요함</li>
</ul>
</li>
<li>미완료 갱신(uncommitted update)
<ul>
<li>완료 상태가 되지 않은 (부분 완료) 트랜잭션에 의해 데이터베이스에 반영된 갱신을 의미</li>
<li>트랜잭션 장애가 일어나면 트랜잭션이 실행되기 전 상태의 데이터 값으로 복원
<ul>
<li>UNDO 연산도 멱등성을 가지고 있음</li>
</ul>
</li>
</ul>
</li>
<li>start 레코드와 commit 레코드 둘 다 있는 트랜잭션에는 REDO를 수행</li>
<li>start 레코드만 있고 commit 레코드가 없는 트랜잭션에는 UNDO를 수행</li>
</ul>
</li>
</ul>
<h3>검사시점 회복 기법</h3>
<ul>
<li>로그기반 회복 기법의 단점
<ul>
<li>트랜잭션별 REDO와 UNDO의 필요성을 판단하기 위해 로그 전체를 조사해야 함
<ul>
<li>시간과 자원이 소모되고 불필요한 REDO도 발생함</li>
</ul>
</li>
</ul>
</li>
<li>검사시점 회복 기법
<ul>
<li>로그 기록을 유지하되 일정 시간 간격으로 검사시점을 설정함</li>
<li>과정
<ol>
<li>주기억장치에 있는 모든 로그 레코드를 안정 저장소로 출력</li>
<li>변경된 데이터 버퍼블록을 전부 보조기억장치로 출력</li>
<li>검사시점을 의미하는 checkpoint 로그 레코드를 안정 저장소로 출력</li>
</ol>
</li>
</ul>
</li>
<li>트랜잭션 목록 결정 과정
<ol>
<li>검사시점 당시를 기준으로 활동중인 트랜잭션은 undo list에 추가</li>
<li>로그를 차례대로 검사하면서 start 로그 레코드를 만나면 해당 트랜잭션을 undo list에 추가</li>
<li>로그를 차례대로 검사하면서 commit 로그 레코드를 만나면 해당 트랜젝션을 undo list에서 redo list로 옮김</li>
</ol>
</li>
<li>UNDO와 REDO 수행 방향
<ul>
<li>후진(backward) 회복
<ul>
<li>undo list에 있는 모든 트랜잭션들에 대해 로그에 기록된 역순으로 UNDO 연산 수행</li>
</ul>
</li>
<li>전진(forward) 회복
<ul>
<li>redo list에 있는 트랜잭션에 대해 로그에 기록된 순서로 REDO 연산 수행</li>
</ul>
</li>
</ul>
</li>
<li>회복 작업이 완료될 때까지 시스템은 새로운 트랜잭션을 받아들일 수 없음</li>
</ul>
<h3>Shadow Paging</h3>
<ul>
<li>로그를 사용하지 않는 회복 기법
<ul>
<li>수정된 내용이 다른 위치에 저장되는 '간접 갱신' 방식임</li>
<li>두 개의 페이지 테이블을 유지함
<ul>
<li>현재 페이지 테이블</li>
<li>그림자 페이지 테이블</li>
</ul>
</li>
<li>트랜잭션을 실행 중에는 '현재 페이지 테이블'만 사용</li>
<li>데이터베이스에 대한 모든 읽기/쓰기 연산은 '그림자 페이지 테이블'을 사용</li>
</ul>
</li>
<li>트랜잭션 수행 과정
<ol>
<li>트랜잭션 시작 시, 현재 페이지 테이블을 그림자 페이지 테이블로 복사</li>
<li>쓰기 연산 시, 수정된 데이터베이스 페이지의 새로운 사본을 생성하고, 현재 페이지 테이블 엔트리가 새 사본을 가리키도록 수정</li>
<li>트랜잭션 완료 시, 그림자 페이지 테이블을 폐기하고, 그 그림자 페이지 테이블이 참조하는 이전 페이지들을 반환</li>
</ol>
</li>
<li>시스템 장애 상황별 회복
<ul>
<li>3단계 과정 전에 발생하는 시스템 장애
<ul>
<li>현재 페이지 테이블을 폐기하면 됨</li>
</ul>
</li>
<li>3단계 과정 직후에 발생하는 시스템 장애
<ul>
<li>트랜잭션의 실행 결과에 아무런 영향이 없음</li>
<li>REDO 연산이 불필요함</li>
</ul>
</li>
</ul>
</li>
<li>장점
<ul>
<li>로그 레코드를 출력하지 않으므로 출력 오버헤드가 없음</li>
<li>UNDO 연산이 아주 간단하며 REDO 연산이 필요 없음
<ul>
<li>단순 장애로부터의 회복 작업이 신속함</li>
</ul>
</li>
</ul>
</li>
<li>단점
<ul>
<li>갱신된 데이터베이스 페이지들의 디스크 상 위치가 변하므로 클러스터링이 어려움
<ul>
<li>클러스터링(clustering) = 유사성 등의 개념에 기반해 데이터를 그룹화하고 분류하는 기법의 총칭</li>
</ul>
</li>
<li>디렉토리가 큰 경우에는 오버헤드가 상당함</li>
<li>트랜젝션 완료시 garbage collection을 해야하는 문제가 있음</li>
<li>동시 사용자 지원 등을 위한 병행 트랜잭션이 곤란함</li>
</ul>
</li>
</ul>
<h3>다중 데이터베이스에서의 회복</h3>
<ul>
<li>다수의 데이터베이스에 접근해야하는 트랜잭션의 경우 각 DBMS들이 서로 다른 회복 기법과 트랜잭션 관리자를 사용할 수 있음
<ul>
<li>이 경우 원자성을 유지하기 위해 2-phase commit을 사용함
<ul>
<li>'모든 참여 데이터베이스가 트랜잭션을 완료하도록' 하거나 '모든 참여 데이터베이스가 트랜잭션을 완료하지 않도록' 함
<ul>
<li>= All or Nothing</li>
</ul>
</li>
<li>참여중인 특정 데이터베이스에 장애가 발생하더라도 트랜잭션이 완료되거나 철회된 상태로의 회복은 항상 가능함</li>
</ul>
</li>
</ul>
</li>
<li>2-phase commit 과정
<ol>
<li>전역 회복 관리자가 READY? 메세지를 로컬 회복 관리자들에게 전송함</li>
<li>각 참여 데이터베이스의 로컬 회복 관리자는 자신이 담당한 트랜잭션 부분을 완료할 수 있으면 COMMIT PREPARED 메세지를 전역 회복 관리자에게 통보함</li>
<li>모든 로컬 회복 관리자가 COMMIT PREPARED 메세지로써 응답하게 되면, 전역 회복 관리자는 모든 로컬 회복 관리자들에게 COMMIT 명령을 보냄
<ul>
<li>만약 하나 이상의 로컬 회복 관리자가 NO 신호로 응답하게 되면, 전역 회복 관리자는 모든 로컬 회복 관리자들에게 ROLLBACK 명령을 보냄</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h1>10. 동시성 제어</h1>
<h2>10-1. 동시성의 개념과 제어 방법</h2>
<h3>데이터베이스의 동시 공유</h3>
<ul>
<li>장점
<ul>
<li>공유성 증가</li>
<li>응답시간 단축</li>
<li>시스템 활용도 증대</li>
</ul>
</li>
<li>단점
<ul>
<li>동시에 읽기/쓰기가 수행되면 비일관성을 유발함
<ul>
<li>읽기 연산의 동시 접근은 문제가 없음</li>
<li>쓰기 연산의 동시 접근 시 서로 다른 트랜잭션에 대해서 동일한 데이터가 접근되어 충돌 발생
<ul>
<li>동시성 제어 필요 = 충돌하는 연산들간의 실행 순서를 정해주는 것</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>동시성 제어가 없을 때 발생하는 현상
<ul>
<li>갱신 분실 (lost update)
<ul>
<li>다른 트랜잭션이 수정한 내용이 데이터베이스에는 미반영됨</li>
</ul>
</li>
<li>비일관성 (inconsistency)
<ul>
<li>트랜잭션 수행 결과에 일관성이 결여됨</li>
</ul>
</li>
<li>연쇄 복귀 (cascading rollback)
<ul>
<li>이미 커밋된 트랜잭션을 복귀시킬 필요가 발생함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>스케줄</h3>
<ul>
<li>트랜잭션들의 연산 실행 순서를 의미함
<ul>
<li>단일 CPU의 시분할(time slicing)
<ul>
<li>interleaving으로 실행함</li>
<li>사용자 입장에서는 각 프로그램들이 병렬로 구동되는 것처럼 보임</li>
</ul>
</li>
</ul>
</li>
<li>트랜잭션 스케줄 종류
<ul>
<li>직렬 스케줄
<ul>
<li>트랜잭션의 순차적 실행</li>
<li>interleaving 되지 않음</li>
<li>n!개의 순서 조합이 가능함</li>
<li>가장 정확한 '올바른 스케줄링'</li>
</ul>
</li>
<li>비직렬 스케줄
<ul>
<li>interleaving 된 스케줄</li>
<li>트랜잭션들의 병렬 실행</li>
</ul>
</li>
<li>직렬 가능(serializable) 스케줄
<ul>
<li>n개의 트랜잭션에 대한 스케줄 S가, 똑같은 n개의 트랜잭션에 대한 어떠한 직렬 스케줄 S와 동등한 경우, 스케줄 S를 '직렬 가능 스케줄'이라고 함</li>
</ul>
</li>
<li>동등 스케줄
<ul>
<li>스케줄 S1과 스케줄 S2가 동일한 트랜잭션들을 포함한 경우를 의미함</li>
<li>모든 데이터 항목들에 대해 마지막 데이터베이스에 기록한 결과가 두 스케줄에서 동일한 경우</li>
<li>주의사항
<ul>
<li>연산자의 유형이나 피연산자의 값에 따라 우연히 최종 결과가 같을수도 있음</li>
<li>항상 동일한 결과를 생성하는 것을 보장하지는 않음</li>
</ul>
</li>
<li>충돌 동등
<ul>
<li>두 스케줄에서 어떠한 충돌 연산들의 순서가 동일한 경우</li>
</ul>
</li>
<li>충돌 직렬 가능 스케줄
<ul>
<li>어떤 직렬 스케줄과 충돌 동등인 스케줄</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>충돌 직렬 가능성 검사
<ul>
<li>선행 그래프를 그렸을 때, 선행 그래프에 사이클이 없는 경우에는 충돌 직렬 가능성이 있음</li>
<li>한계
<ul>
<li>트랜잭션을 임의로 수행시켜 직렬 가능성을 검사하는 방식이고, 직렬 가능이 되지 않으면 스케줄이 취소됨</li>
<li>시스템에 트랜잭션들이 계속 들어올 경우, 어떤 스케줄이 언제 시작해서 언제 끝나는지를 결정하기 어려움
<ul>
<li>문제가 복잡한 경우에 직렬 가능성 검사는 불가능함</li>
</ul>
</li>
</ul>
</li>
<li>대안
<ul>
<li>직렬 가능성 검사를 하지 않고도 이론적 검증으로 직렬 가능성을 보장하는 방법
<ul>
<li>Locking</li>
<li>Timestamp</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>로킹 (Locking)</h3>
<ul>
<li>상호 배제 및 독점 제어의 과정을 의미함
<ul>
<li>잠금이 된 데이터 집합을 생성함</li>
<li>데이터 객체에 배타적으로 할당함</li>
<li>무간섭을 보장함</li>
</ul>
</li>
<li>로킹 규약
<ol>
<li>트랜잭션이 읽기/쓰기 연산을 할 때, 반드시 먼저 lock 연산을 실행함</li>
<li>트랜잭션이 실행한 lock에 대해서, 트랜잭션의 모든 실행을 종료하기 전에 반드시 unlock 연산을 실행함</li>
<li>트랜잭션은 다른 트랜잭션에 의해 이미 lock이 걸려있는 데이터 객체에는 다시 lock 연산을 실행할 수 없음</li>
<li>lock된 데이터 객체에 트랜잭션이 접근할 경우, 해당 lock을 트랜잭션 자신이 걸어놓지 않았을 경우에는 여기에 unlock 연산을 실행할 수 없음
<ul>
<li>lock을 걸어둔 트랜잭션만이 그것을 unlock 할 수 있음</li>
</ul>
</li>
</ol>
</li>
<li>로킹 모드
<ul>
<li>공용 lock
<ul>
<li>읽기 연산에만 허용됨</li>
<li>여러 트랜잭션들의 동시 사용 가능</li>
</ul>
</li>
<li>전용/독점(exclusive) lock
<ul>
<li>읽기/쓰기 연산에 허용됨</li>
<li>오직 하나의 트랜잭션만 사용 가능</li>
</ul>
</li>
<li>트랜잭션이 데이터 객체에 대해 읽기 연산 실행 시, 먼저 공용 lock이나 독점 lock 연산을 실행함</li>
<li>트랜잭션이 데이터 객체에 대해 쓰기 연산 실행 시, 먼저 독점 lock 연산을 실행함</li>
<li>데이터 객체는 다른 트랜잭션에 의해 양립될 수 없으며, lock이 걸려 있다면 그것이 모두 풀릴때까지 대기됨</li>
</ul>
</li>
<li>로킹 규약의 성질
<ul>
<li>데이터 객체의 비공유/비중첩</li>
<li>All or Nothing</li>
<li>단일 소유자</li>
<li>로킹을 수행한 트랜잭션만이 로킹 해제 가능</li>
</ul>
</li>
<li>로킹의 단위
<ul>
<li>속성, 레코드, 릴레이션, 데이터베이스</li>
<li>단위가 큰 경우 = 동시성 감소</li>
<li>단위가 작은 경우 = 로킹 오버헤드의 증가</li>
</ul>
</li>
</ul>
<h3>2-phase Locking Protocol</h3>
<ul>
<li>로킹을 사용하더라도 충돌 직렬 가능 스케줄을 항상 만들 수 있는 것은 아님
<ul>
<li>스케줄 내의 모든 트랜잭션들이 2단계 로킹 규약을 준수할 경우 직렬이 가능해짐</li>
</ul>
</li>
<li>단계
<ul>
<li>growing phase
<ul>
<li>트랜잭션은 lock만 수행 가능함</li>
</ul>
</li>
<li>shrinking phase
<ul>
<li>트랜잭션은 unlock만 수행 가능함</li>
<li>unlock을 한번이라도 수행했다면 이후 lock을 걸 수 없음</li>
</ul>
</li>
</ul>
</li>
<li>주의점
<ul>
<li>2단계 로킹 규약은 충돌 직렬 가능성을 보장하지만, 직렬 가능성의 '충분 조건'이지 '필요 조건'은 아님
<ul>
<li>2단계 로킹 규약을 사용하지 않아도 충돌 직렬 가능 스케줄 생성이 가능함</li>
</ul>
</li>
</ul>
</li>
<li>Strict 2PLP
<ul>
<li>제약이 추가된 엄격한 2단계 로킹 규약
<ol>
<li>모든 독점 lock은 그 트랜잭션이 완료될 때까지 unlock하지 않고 그대로 유지</li>
<li>완료되지 않은 어떤 트랜잭션에 의해 기록된 모든 데이터 객체는, 그 트랜잭션이 완료될 때까지 독점 모드로 로킹
<ul>
<li>다른 트랜잭션은 해당 데이터 객체에 접근할 수 없음</li>
<li>연쇄 복귀 문제가 발생하지 않음</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Rigorous 2PLP
<ul>
<li>S2PLP보다 더욱 엄격한 통제적 2단계 로킹 규약
<ul>
<li>모든 lock는 트랜잭션이 완료될 때까지 unlock되지 않고 잠긴 상태를 유지</li>
</ul>
</li>
<li>트랜잭션들이 완료되는 순서로 직렬화가 가능함</li>
</ul>
</li>
<li>대부분의 DBMS들은 S2PLP나 R2PLP를 사용함</li>
</ul>
<hr>
<h1>11. 교착상태</h1>
<h2>11-1. 교착상태의 개념과 제어 방법</h2>
<h3>교착상태란?</h3>
<ul>
<li>모든 트랜잭션들이 실행을 전혀 진전시키지 못하고 무한정 대기하는 상태</li>
<li>발생 조건
<ul>
<li>상호 배제 (mutual exclusion)
<ul>
<li>독점적 로킹으로 인해 발생</li>
</ul>
</li>
<li>대기 (wait for)
<ul>
<li>로킹을 얻기 위한 대기</li>
</ul>
</li>
<li>선취 금지 (no preemption)
<ul>
<li>트랜잭션이 완료되지 않고 계속 살아있음</li>
</ul>
</li>
<li>순환 대기 (circular wait)
<ul>
<li>상대방의 순서가 끝나기만을 서로 기다리기만 함</li>
</ul>
</li>
</ul>
</li>
<li>해소 방법
<ul>
<li>4가지 발생 조건 중 하나라도 해소해주면 해결됨</li>
<li>탐지
<ul>
<li>교착상태가 일단 발생한 다음, 교착 상태의 조건을 제거해주는 접근법</li>
<li>현재 로킹된 데이터 객체와 로킹 요청이 대기중인 데이터 객체를 기준으로, 교착상태를 탐지하는 시스템 검사를 주기적으로 가동하고 교착상태 회복을 수행</li>
</ul>
</li>
<li>예방
<ul>
<li>트랜잭션이 실행되기 전에 교착상태의 발생 조건을 불가능하게 만드는 접근법</li>
<li>트랜잭션 스케줄링 기법을 사용해, 트랜잭션 실행 전에 필요한 데이터 객체들을 모두 로킹함
<ul>
<li>단점
<ul>
<li>충돌되는 데이터 객체를 필요로 하는 트랜잭션은 병행 실행이 불가능해짐
<ul>
<li>그렇다고 해서 모든 트랜잭션들이 특정 순서에 따라 데이터 객체를 로킹하도록 수동으로 지시하고, 그 순서를 프로그래머가 숙지하는 것은 현실적인 대안이 아님</li>
</ul>
</li>
<li>데이터 요구에 대한 사전 지식이 필요함</li>
<li>데이터가 한번에 일괄적으로 로킹되기 때문에 데이터 활용도가 감소됨</li>
<li>기아(starvation) 문제가 발생함
<ul>
<li>자주 사용되는 데이터의 경우, 특정 트랜잭션이 해당 데이터를 사용하는 동안 나머지 트랜잭션들이 무한정 대기를 해야 함</li>
</ul>
</li>
</ul>
</li>
<li>현실적으로 활용하기 어려움</li>
</ul>
</li>
</ul>
</li>
<li>회피
<ul>
<li>자원을 할당하는 시점 기반으로 교착상태가 일어나지 않도록 실시간 알고리즘을 사용해 검사하는 접근법
<ul>
<li>timestamp를 활용함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Timestamp</h3>
<ul>
<li>교착 상태 회피를 위해 사용되는 식별자
<ul>
<li>트랜잭션의 시작 순서에 기초하는 식별자로써, 트랜잭션이 기다려야 할지 복귀해야 할지를 결정하는데 사용됨
<ul>
<li>시스템의 clock값 또는 논리적 카운터를 timestamp로써 사용함</li>
</ul>
</li>
<li>교착 상태의 주요 원인인 로킹을 사용하는 대신, 순서(타임스탬프) 기반으로 동시성 제어를 하는 접근법
<ul>
<li>새로 접근하는 트랜잭션이 가장 최근에 접근한 트랜잭션보다 더 오래된 경우, 새로운 타임스탬프를 부여해서 재시작함</li>
<li>트랜잭션을 interleaving으로 실행한다면 타임스탬프 순서대로 직렬이 가능함</li>
</ul>
</li>
</ul>
</li>
<li>방식
<ul>
<li>트랜잭션 T2가 로킹한 데이터 객체를 트랜잭션 T1이 요청할 때,</li>
<li>wait-die 방식
<ul>
<li>트랜잭션 T1의 타임스탬프가 트랜잭션 T2의 타임스탬프보다 작은 경우,
<ul>
<li>T1이 고참인 경우 T1은 대기</li>
<li>T1이 신참인 경우 T1은 복귀(die) 후 다시 시작</li>
</ul>
</li>
<li>고참 트랜잭션이 신참 트랜잭션을 기다림</li>
<li>고참 트랜잭션이 가지고 있는 데이터 객체를 신참이 요구하면, 신참 트랜잭션은 복귀 후 재실행</li>
<li>재실행 시 똑같은 순서로 데이터를 요구하므로 불필요한 복귀가 자주 발생함</li>
</ul>
</li>
<li>wound-wait 방식
<ul>
<li>트랜잭션 T1의 타임스탬프가 트랜잭션 T2의 타임스탬프보다 클 경우,
<ul>
<li>T2가 고참인 경우 T2는 대기</li>
<li>T2가 신참인 경우 T2는 T1에 의해 상처를 입고(wound) 복귀해 다시 시작</li>
</ul>
</li>
<li>고참 트랜잭션이 신참 트랜잭션을 기다리지 않음</li>
<li>신참 트랜잭션이 가지고 있는 데이터 객체를 고참이 요구하면, 신참 트랜잭션은 복귀 후 재실행</li>
<li>신참 트랜지션은 대기만 하고 있으면 됨</li>
</ul>
</li>
<li>timestamp 순서 방식
<ul>
<li>T1이 T2보다 오래 되었다면 T1의 타임스탬프가 T2의 타임스탬프보다 작은 값이므로, 시스템이 T1, T2의 직렬 실행과 결과가 일치하도록 보장해주는 방식</li>
<li>장점
<ul>
<li>대기가 없으므로 교착 상태가 없음</li>
</ul>
</li>
<li>단점
<ul>
<li>연쇄 복귀가 발생
<ul>
<li>T1의 복귀가 T2의 복귀를 유발함</li>
<li>T1이 복귀하고 T1이 쓰기 작업을 수행한 데이터를 T2가 벌써 사용했다면, T2 역시 복귀해야 함</li>
</ul>
</li>
<li>순환적 재시작
<ul>
<li>연속적인 복귀와 재시작으로 인한 기아 상태가 발생할 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    <div class="mt-20 md:mt-32 lg:mt-32 xl:mt-32"></div>
</article>
        
    </main>
    <footer class="mt-20 px-10 py-8 bg-gray-200">
    <div class="max-w-5xl mx-auto text-gray-700 text-center">
        © 2022 <a href="/" class="font-medium" target="_blank" rel="noopener">devfreedom.github.io</a> by 
        <a href="https://devfreedom.github.io" target="_blank" rel="noopener">devfreedom</a> 
    </div>
</footer>
    <script src="/assets/js/bundle.js"></script>
</body>

</html>