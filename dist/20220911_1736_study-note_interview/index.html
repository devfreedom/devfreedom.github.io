<!DOCTYPE html>
<html>
    
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>[필기] 개발 직군 기술면접 예상 질문 | devfreedom.github.io</title>
    <meta name="title" content="[필기] 개발 직군 기술면접 예상 질문 | devfreedom.github.io">
    <meta name="description" content="devfreedom&#39;s personal blog">
    <meta name="keywords" content="❮필기❯,커리어,프로그래밍,컴퓨터공학,eleventy,template,simple,clean">
    <meta name="author" content="devfreedom">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://devfreedom.github.io/20220911_1736_study-note_interview/">
    <link rel="shortcut icon" type="image/png" href="/assets/img/favicon.svg">
    <link rel="apple-touch-icon" href="/assets/img/apple-touch-icon.png">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="/assets/css/main.css">
    
</head>	

<body class="flex flex-col h-screen bg-white text-gray-800 break-words">
    <header id="header" class="header-shadow bg-black px-6 py-5 z-50 fixed w-full top-0 transition-all transform ease-in-out duration-500">
    <div class="max-w-5xl mx-auto flex items-center flex-wrap justify-between">
        <div class="sm:mr-8">
            <a class="flex items-center" href="/">                              
                <span class="text-lg text-white font-semibold self-center">devfreedom.github.io</span>
            </a>
        </div>
        <nav id="menu" class="order-last md:order-none items-center flex-grow w-full md:w-auto md:flex hidden mt-2 md:mt-0">
            
            <a href="/tags" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">Categories</a>
            
            <a href="https://github.com/devfreedom" target="_blank" rel="noopener" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">GitHub</a>
            
            <a href="/about" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">About</a>
            
        </nav>
        <form id="search" action="/search" class="order-last sm:order-none flex-auto w-32 items-center justify-end hidden sm:block mt-6 sm:mt-0">
            <label class="visually-hidden" for="header-searchbox">Search here ...</label>
            <input type="text" id="header-searchbox" name="q" placeholder="Search..." class="w-full sm:max-w-xs bg-gray-200 border border-transparent float-right focus:bg-white focus:border-gray-300 focus:outline-none h-8 p-4 placeholder-gray-700 rounded text-gray-700 text-sm">
        </form>
        <div id="menu-toggle" class="flex items-center md:hidden text-gray-700 hover:text-teal-600 cursor-pointer sm:ml-6">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
    <line x1="3" y1="12" x2="21" y2="12"></line>
    <line x1="3" y1="6" x2="21" y2="6"></line>
    <line x1="3" y1="18" x2="21" y2="18"></line>
</svg>
        </div>
    </div>
</header>
    <main class="mx-7 lg:mx-6 mt-32 flex-grow">
        
        
<article class="max-w-5xl mx-auto">
    <header class="mb-14">
        <h1 class="text-3xl text-center font-bold leading-normal text-gray-900 mt-0 mb-3">[필기] 개발 직군 기술면접 예상 질문</h1>
        <div class="text-center">Published on 11 September 2022 05:36 PM</div>
        
        <div class="mt-3 text-center">
            
            <a href="/tags/❮필기❯" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#❮필기❯</a>
            
            <a href="/tags/커리어" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#커리어</a>
            
            <a href="/tags/프로그래밍" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#프로그래밍</a>
            
            <a href="/tags/컴퓨터공학" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#컴퓨터공학</a>
            
        </div>
        
        
        <div class="mt-10 -mx-7 md:mx-0">
            <img class="w-full max-w-2xl mx-auto" src="/assets/img/programming.jpg" width="960" height="500" alt="This post thumbnail">
        </div>
        
    </header>
    <div id="content" class="prose text-gray-800 max-w-none">
        <p>이 블로그는 분명히 &quot;비전공 비개발자의 개발 일기&quot;라는 주제로 시작했는데 어쩌다보니 여기까지 왔습니다. 내가 미쳤지.</p>
<hr>
<h1>컴퓨터공학</h1>
<h2>프로그래밍 일반론</h2>
<ul>
<li>포인터란 무엇인가요?</li>
<li>컴파일 언어와 인터프리터 언어의 차이점은 무엇인가요?</li>
<li>컴퓨터는 문자열을 어떻게 다루나요? (아스키코드, 유니코드 등)</li>
<li>call by value와 call by reference의 차이점은 무엇인가요?</li>
<li>예외 처리에 대해 설명하세요.</li>
<li>재귀(recursive) 함수란 무엇인가요?</li>
<li>클래스와 인스턴스의 차이점은 무엇인가요?</li>
<li>다형성이란 무엇인가요?</li>
<li>프로세스와 쓰레드의 차이점은 무엇인가요?</li>
<li>ORM 이란 무엇인가요?</li>
<li>임계영역이란 무엇인가요?</li>
<li>프로그래밍에서 동기와 비동기, 블로킹과 논블로킹의 차이점은 무엇인가요?</li>
</ul>
<h2>운영체제</h2>
<ul>
<li>커널이란 무엇인가요?</li>
<li>프로세스 스케쥴링이란 무엇인가요?</li>
<li>컨텍스트 스위칭이란 무엇인가요?</li>
<li>가상 메모리란 무엇인가요?</li>
<li>교착 상태란 무엇인가요?</li>
</ul>
<h2>네트워크</h2>
<ul>
<li>OSI 7계층에 대해 설명하세요.</li>
<li>HTTPS 프로토콜에 대해 설명하세요.</li>
<li>대표적인 웹 보안 취약점에 대해 설명하세요.</li>
<li>방화벽이란 무엇인가요?</li>
<li>인터넷과 인트라넷의 차이는 무엇인가요?</li>
<li>IPv4와 IPv6의 차이점은 무엇인가요?</li>
<li>TCP와 UDP의 차이점은 무엇인가요?</li>
<li>SSH란 무엇인가요?</li>
</ul>
<h2>자료구조</h2>
<ul>
<li>자료 구조란 무엇이며 어떤 예시들이 있는가?</li>
<li>메모리 구조에서 스택과 힙의 차이점은 무엇인가요?</li>
</ul>
<h2>소프트웨어 공학 및 설계</h2>
<ul>
<li>SW 설계 시 의존성 주입, 제어의 역전이란 무엇인가요?</li>
<li>디자인 패턴이란 무엇이며 어떤 예시들이 있는가?</li>
<li>좋은 로그 설계 기법은 무엇인가요?</li>
<li>소프트웨어 개발 프로세스에 대해 설명하세요.</li>
<li>테스트 주도 개발 방법론에 대해 설명하세요.</li>
</ul>
<h2>알고리즘</h2>
<ul>
<li>알고리즘의 시간복잡도란 무엇이며 어떤 예시들이 있나요?</li>
<li></li>
</ul>
<h2>데이터베이스</h2>
<h2>데이터베이스 일반론</h2>
<ul>
<li>데이터베이스 정규화와 역정규화에 대해 설명하세요.</li>
<li>데이터베이스의 인덱스 종류에 대해 설명하세요.</li>
<li>데이터베이스의 좋은 인덱스 설계에 대해 설명하세요.</li>
<li>데이터베이스 실행계획에 대해 설명하세요.</li>
<li>데이터베이스 트랜잭션이란 무엇인지 설명하세요.</li>
<li>데이터베이스의 외래키와 무결성 제약 조건에 대해 설명하세요.</li>
<li>스키마란 무엇인가요?
<ul>
<li>데이터의 독립성을 보장하기 위해서 데이터베이스의 구조와 제약 조건을 명시한 것입니다. 개체, 속성, 관계, 제약조건을 정의합니다. 응용 관점에서의 외부 스키마, 조직 관점에서의 개념 스키마, 저장장치 관점에서의 내부 스키마로 나뉩니다. 스키마를 저장/유지/관리하는 별도의 시스템을 데이터 사전이라고 합니다.</li>
</ul>
</li>
<li>데이터베이스의 기본 개념과 데이터 모델에 대해서 설명해보세요.
<ul>
<li>데이터베이스에서 정보의 단위로써 표현하고자 하는 유무형의 객체를 개체(entity)라고 합니다. '학생'은 개체의 예제입니다. 개체는 하나 이상의 속성(attribute)를 가지는데 속성은 데이터의 가장 작은 '논리적인' 단위입니다. '학번, 이름, 학과'는 속성의 예제입니다. '학생'이라는 개체를 '학번, 이름, 학과'와 같이 속성의 이름들로만 나타낸 것을 '개체 타입(entity type)'이라고 합니다. 개체들간에 존재하는 연관성은 관계(relationship)이라고 합니다. '학생은 학과에 소속된다'라던가 '학생은 고유한 학번을 가지며 이를 학사관리에 활용한다'는 관계의 예제입니다. 제약조건(constraint)이란 데이터의 무결성을 지키기 위해 입력받은 데이터에 제한을 두는 것입니다. '학번은 반드시 10자리 미만의 정수로만 이루어져 있다'가 제약조건의 예제입니다. 데이터 모델은 Structure, Operation, Constraint로 구성됩니다. 구조는 데이터의 정적인 성질, 연산은 데이터의 동적인 조작, 제약조건은 데이터의 논리적 한계를 규정한 것입니다.</li>
</ul>
</li>
<li>관계형 데이터베이스의 특징에 대해서 설명하세요.
<ul>
<li>독일 수학자 칸토어의 집합론에 기반해서, 구별되는 각기 다른 원소들이, 특정하고 객관적인 기준에 의해 순위나 순서 없이 모이고, 어떤 원소가 어떤 집합에 포함되는지가 명확한 데이터베이스입니다. 관계형 데이터베이스는 2차원 테이블 구조를 가지고 이를 '릴레이션'이라고 합니다. 릴레이션은 튜플들의 집합입니다. 테이블의 행은 개체, 즉 튜플(tuple)이 되고, 테이블의 열은 속성이 됩니다. 속성이 가질 수 있는 값의 범위를 도메인이라고 합니다. 속성이 변수라면 도메인은 타입이라고 할 수 있습니다. 관계대수와 관계해석의 연산을 합니다.</li>
</ul>
</li>
</ul>
<hr>
<h1>웹 개발</h1>
<h2>Javascript</h2>
<ul>
<li>
<p>비동기 함수에 대해서 설명하세요.</p>
<ul>
<li>비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환합니다. 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며, Promise 객체는 비동기 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 객체입니다. 비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용합니다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요합니다. 여러개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어됩니다.</li>
</ul>
</li>
<li>
<p>call stack, callback queue, event loop, Web API를 예시를 들어서 설명해보세요.</p>
<ul>
<li>
<pre><code>const foo = () =&gt; console.log(&quot;1st&quot;);
const bar = () =&gt; setTimeout(() =&gt; console.log(&quot;2nd&quot;), 500)
const baz = () =&gt; console.log(&quot;3rd&quot;);

bar();
foo();
baz();
</code></pre>
<ol>
<li>
<p>우선은 코드가 실행되기 전, 변수의 선언이 최우선적으로 이루어지는 호이스팅을 생각해볼 필요가 있습니다. 함수의 경우 함수 선언식으로 표현된 경우 호이스팅이 발생하지만 여기서는 함수 표현식이 사용되었으므로 호이스팅이 일어나지 않습니다. 그래서 우선 첫번째 코드에서 전역 컨텍스트가 생성되고, foo(), bar(), baz() 함수들이 차례대로 선언되고 초기화되게 됩니다.</p>
</li>
<li>
<p>먼저 bar() 함수가 호출되고, bar() 함수 안에 있는 코드에서 setTimeout()이 호출됩니다. 이렇게 차례대로 호출되는 함수는 '호출 스택'에 차례대로 쌓이게 되는데, 호출 스택은 후입선출 방식입니다. 따라서 setTimeout()이 먼저 실행됩니다. setTimeout()은 비동기 함수이므로 브라우저의 Web API인 timer를 호출하고, 지정된 500ms의 시간이 지나게 되면 setTimeout() 내부의 console.log(&quot;2nd&quot;)는 백그라운드 작업이 대기하는 '콜백 큐'로 보내지게 됩니다. 다만 해당 작업은 무한정 기다려서는 안되므로, 콜백 큐에 작업이 들어오게 되면 우선 호출 스택이 비어있는지를 확인하고, 비어있다면 콜백 큐에서 호출 스택으로 작업을 밀어넣어 해당 작업이 실행될 수 있도록 하는 '이벤트 루프'가 지속적으로 작동하게 됩니다.</p>
</li>
<li>
<p>setTimeout()에 의해 500ms를 기다려서 console.log(&quot;2nd&quot;)가 콜백 큐에서 대기하고 있는 동안 bar() 다음으로 호출되는 foo() 함수가 호출 스택에 추가되고, 후입선출이므로 바로 실행되어 &quot;1st&quot;라는 문자열이 출력되고 해당 함수 컨텍스트가 소멸되어 호출 스택에서 사라집니다. 만약 이 과정이 setTimeout()의 500ms + 이벤트 루프 사이클보다 짧은 시간 내에 완료된다면, 연달아서 baz() 함수가 실행되고 &quot;3rd&quot;라는 문자열을 출력하게 됩니다. 여기까지 완료되서 호출 스택이 완전히 비어있게 된다면 그제서야 이벤트 루프는 console.log(&quot;2nd&quot;)를 호출 스택으로 밀어넣고, 그것이 실행되어 &quot;2nd&quot;라는 문자열을 출력하고는 전역 컨텍스트가 소멸하게 됩니다. 이런 이유로 인해서 setTimeout() 내부에 정의된 코드는 정확하게 500ms이 아닌 그 이후에 실행될 수 있습니다.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>async/await에 대해서 설명하세요.</p>
<ul>
<li>promise를 보다 간결하게 다룰 수 있도록 하는 ES2017의 syntactic sugar 입니다. promise 객체를 반환하는 async 함수의 내부에서는 await 키워드가 사용된 비동기 통신이 완료가 되면 다음 코드가 실행됩니다.</li>
</ul>
</li>
<li>
<p>clojure에 대해서 설명하세요.</p>
</li>
<li>
<p>hoisting에 대해서 설명하세요.</p>
</li>
<li>
<p>자바스크립트가 가지는 이벤트 기반 특징은 무엇인가요?</p>
</li>
<li>
<p>callback, promise, async/await의 차이점은 무엇인가요?</p>
<ul>
<li>callback 함수는 비동기 작업이 완료되었을 때 호출됩니다. promise 객체는 비동기 작업의 성공/실패 여부를 나타내는 객체입니다. async/await은 promise 객체를 조금 더 간결하게 다룰 수 있도록 하는 syntactic sugar입니다.</li>
</ul>
</li>
<li>
<p>=와 ==와 ===의 차이에 대해서 설명하세요.</p>
</li>
<li>
<p>이벤트 버블링에 대해서 설명하세요.</p>
</li>
<li>
<p>JSON 이란 무엇인가요?</p>
</li>
<li>
<p>callback hell과 그 대안에 대해서 설명해보세요.</p>
<ul>
<li>
<p>자바스크립트에서 비동기 프로그래밍, 특히 네트워크 요청에 따른 응답이라던가 이벤트의 처리를 위해서는 비동기 함수의 매개변수로 넘겨지는 함수인 콜백함수의 적극적 사용이 필요하게 됩니다. 문제는 비동기 작업과 그 결과의 처리를 지속적으로 중첩시켜야하는 경우 콜백함수 또한 중첩해서 작성하게 되고, 들여쓰기마저 누적이 되는데, 코드의 가독성과 간결함을 심하게 저해시키는 이러한 현상을 '콜백 지옥'이라고 합니다.</p>
<p>중첩된 콜백함수에 대한 대안으로는 promise가 있습니다. 프라미스란 비동기 연산이 종료된 후 그 결과를 담는 객체입니다. 프라미스는 pending, fulfull, reject 이렇게 세가지 상태 중 하나를 가지며, 비동기 작업이 성공인 경우 resolve, 실패인 경우 reject를 호출하게 되고 그 결과를 .then()과 .catch()문으로 받을 수 있습니다. 이렇게 여러개의 .then()문으로 비동기 연산의 결과값을 동기 연산처럼 연달아서 받아내는 프라미스 체이닝을 사용하면 콜백 지옥에서 벗어날 수 있지만, 대신에 여전히 코드가 세로로 늘어나고 가독성이 떨어질 수 있습니다.</p>
<p>프라미스 체이닝을 보완하고자 ES2017에서 새로 도입된 개념이 바로 async/await 개념입니다. async/await는 내부적으로는 프라미스와 동일하게 작동하나, 동기식 함수와 유사하게 직관적이고 간결하게 코드를 작성할 수 있도록 마련된 syntactic sugar 입니다. async 함수 내에서 비동기 await 식을 사용하는 방식입니다.</p>
</li>
</ul>
</li>
<li>
<p>이벤트 위임과 이벤트 전파에 대해서 설명해보세요.</p>
</li>
<li>
<p>addEventListener를 cleanup해야하는 이유에 대해서 설명해보세요.</p>
</li>
</ul>
<h2>프론트엔드</h2>
<h3>HTML</h3>
<ul>
<li>
<p>HTML5에 대해 아는대로 설명하세요.</p>
<ul>
<li>HTML5는 웹 표준을 주관하는 국제 연합체인 World Wide Web Consortium(W3C)에 의해 2008년 처음으로 릴리즈 된 새로운 버전의 HTML 입니다. 정적 컨텐츠 표현에 국한되었던 HTML을 client-side를 강화하여 멀티미디어 및 웹 애플리케이션의 영역으로 대폭 확장한 것에 의의가 있습니다. 디바이스 하드웨어에의 접근과 제어, 클라이언트와 서버의 양방향 통신, 그래픽 기능과 이펙트, 자체적 멀티미디어 지원, semantics의 도입, 오프라인 로컬 스토리지 등 현대적 컴퓨팅 환경에 발맞춘 HTML 언어 표준으로서 꾸준히 개선과 기능 추가를 통해 버전업이 이루어지고 있습니다.</li>
</ul>
</li>
<li>
<p>HTML doctype은 무엇을 의미하나요?</p>
</li>
<li>
<p>CSS 링크를 head 태그 사이에 두는 이유는 무엇인가요?</p>
</li>
<li>
<p>script 태그를 body 태그 닫기 전 사용하는 이유는 무엇인가요?</p>
<ul>
<li>DOM parsing이 먼저 끝나야 하기 때문입니다. body element들을 아직 불러오지 않은 상태에서는 자바스크립트가 DOM manipulation을 제대로 수행할 수 없습니다. 하지만 모던 웹에서는 body 태그 끝에서 script를 불러오는 방식은 사용하지 않는 것이 좋습니다. 대신 async와 defer 옵션을 선택적으로 사용하는 것이 권장됩니다.</li>
</ul>
</li>
<li>
<p>script async와 script defer의 차이점에 대해 아는대로 설명하세요.</p>
<ul>
<li>
<p>async 방식과 defer 방식 모두 페이지 렌더링을 방해하지 않고 자바스크립트 파일들을 백그라운드에서 다운로드받아 비동기적으로 실행할 수 있게 해줍니다.</p>
<ol>
<li>
<p>async 방식의 경우 스크립트가 다운로드되면 곧바로 독립적으로 실행됩니다. 이 경우 HTML 파싱은 스크립트가 실행되는 동안 잠시 멈추지만 대신 페이지의 컨텐츠는 계속 처리됩니다. 스크립트의 실행이 끝나면 다시 HTML 파싱이 재개됩니다. async 방식의 경우 순서라던가 다른 스크립트에 영향을 받지 않아서, 여러 동기식 및 async 방식의 스크립트들이 있더라도 서로를 기다리지 않고 다운로드 완료 시점에 따라(load-first) 제각각 실행됩니다.</p>
</li>
<li>
<p>defer 방식의 경우 스크립트의 다운로드가 먼저 완료되더라도 HTML이 완전히 파싱되고 다른 동기 스크립트들이 먼저 실행된 다음에서야 실행되게 됩니다. defer 방식으로 다운로드된 스크립트들간의 실행 순서는 코드상의 순서를 따릅니다.</p>
</li>
</ol>
<p>async와 defer는 그 특징에 맞게 필요에 따라 사용하면 됩니다. 예를 들어, 페이지가 사용자에게 보여지기 전에 먼저 실행이 되어야 하는 스크립트, 웹페이지의 로드 여부와 상관없는 독립적인 기능의 스크립트에는 async를 사용하면 됩니다. 그리고 여러 스크립트들의 실행 순서가 중요한 경우, 페이지 전체를 먼저 불러와 모든 DOM에 접근할 수 있어야 하는 스크립트의 경우에는 defer를 사용하면 됩니다.</p>
</li>
</ul>
</li>
<li>
<p>프로그레시브 렌더링이란 무엇인가요?</p>
</li>
<li>
<p>다국어 사이트를 위해 마크업을 어떻게 해야하나요?</p>
</li>
</ul>
<h3>CSS</h3>
<ul>
<li>
<p>class와 id 차이점은 무엇인가요?</p>
</li>
<li>
<p>float가 어떻게 동작하는지 설명하세요.</p>
<ul>
<li>container의 왼쪽 또는 오른쪽으로 element를 정렬해 텍스트가 그 주위를 감싸면서 flow하게 만드는 CSS 속성입니다. 모던 웹에서는 레거시 취급을 받고 있으며, grid와 flexbox로 대체되었습니다.</li>
</ul>
</li>
<li>
<p>z-index에 관해 설명하세요.</p>
</li>
<li>
<p>Block Formatting Context, block/inline에 대해 설명하세요.</p>
</li>
<li>
<p>Clearing 기술에 대해 설명하세요.</p>
</li>
<li>
<p>스프라이트에 대해 설명하세요.</p>
</li>
<li>
<p>CSS media query에 대해 설명하세요.</p>
</li>
<li>
<p>CSS preprocessor 사용한 경험이 있다면 설명하세요</p>
<ul>
<li>CSS preprocessor은 CSS에다가 독자적인 문법의 programmability를 접목해 재사용성을 늘리고 효율성을 향상시키며 유지보수를 용이하게 하는 전처리기 입니다. Sass에 대해서 배운 적이 있는데, 실제로 사용한 경험은 없습니다. Tailwind CSS로 CSS postprocessor를 사용한 경험은 있습니다.</li>
</ul>
</li>
<li>
<p>position의 relative, fixed, absolute, static 차이점은 무엇인가요요?</p>
</li>
<li>
<p>CSS 선택자(selector)를 아는대로 설명하세요.</p>
</li>
<li>
<p>box model에 대해서 설명하세요.</p>
</li>
<li>
<p>브라우저는 CSS 선택자를 어떻게 해석하나요? 그리고 CSS 측면에서 성능을 향상시키려면 어떻게 해야하나요?</p>
<ul>
<li>
<p>CSS를 작성할 때 선택자는 왼쪽에서 오른쪽으로, 상위 요소에서 하위 요소로, 구체적인 방향으로 지정하게 됩니다. 브라우저는 여기서 가장 구체적인 맨 오른쪽 선택자부터 선택해서 해당 선택자와 일치하는 요소가 있는지를 계층 구조를 타고 올라가서 검색하게 됩니다. 만약 일치하는 요소가 있다면 검색을 끝내고 CSS 스타일을 적용하며, 적용이 되었다면 그 다음 왼쪽 선택자를 선택하고 같은 과정을 반복합니다. 브라우저는 맨 오른쪽 선택자부터 왼쪽 방향으로 선택자들을 차례대로 하나씩 선택해서 검색을 수행합니다.</p>
<p>CSS 성능을 향상시키려면 &quot;어떻게하면 선택자를 통한 요소의 '검색' 작업 연산처리를 최소화할 수 있을까&quot;를 생각하면 됩니다. 계층 구조를 타고 올라가지 않고 바로 특정 요소를 겨냥할 수 있도록 최대한 구체적이고 작은 범위의 선택자, 즉 class나 id를 사용하는 것이 좋습니다. tag를 사용하더라도 class나 id들을 조합하면 구체성이 증폭되므로 유리합니다. 만약 선택자의 범위를 좁히기 어렵다면 인접한 트리 거리에 있는 요소를 활용할수도 있습니다.</p>
</li>
</ul>
</li>
<li>
<p>Utility-first CSS에 대해서 설명해보세요.</p>
</li>
</ul>
<h3>렌더링</h3>
<ul>
<li>
<p>AJAX란 무엇인가요?</p>
<ul>
<li>(작성중) 바닐라 자바스크립트로는 fetch API를 사용해서 구현할 수 있습니다.</li>
</ul>
</li>
<li>
<p>브라우저 렌더링 과정을 설명하세요.</p>
<ul>
<li>브라우저는 우선 HTML 파일과 CSS 파일을 해석하는 parse 작업을 수행합니다. HTML 파일의 경우 파일 내부의 요소들, 즉 HTML 태그들을 각각 '노드'로 변환하고, 노드간의 계층 관계를 tree 구조로 나열해 DOM tree를 생성합니다. CSS파일 역시 CSS 선택자들을 마찬가지의 과정으로 CSSOM tree로써 생성합니다. 이렇게 만들어진 DOM tree와 CSSOM tree를 결합시켜서 하나의 렌더링 트리로써 만듭니다. 이 과정에서 실제로 사용자에게 표시될 요소들만을 남기고 그렇지 않은 부분들은 드랍시키게 됩니다. 이렇게 만들어진 렌더링 트리를 브라우저는 루트로부터 순회를 하면서 각 노드들의 위치와 크기를 상대값에서 절대값으로 계산하게 됩니다. 그렇게 페이지의 레이아웃이 정확하게 산출되면, 그것을 그래픽 자원을 사용해 실제 픽셀로 그려내는 paint 작업이 완료되면 사용자는 웹페이지를 실제로 볼 수 있게 됩니다.</li>
</ul>
</li>
<li>
<p>Single Page Application은 무엇인가요? Server-side rendering과 Client-side rendering의 차이점은 무엇인가요?</p>
<ul>
<li>
<p>SPA란 하나의 웹페이지를 가진 웹 어플리케이션을 의미합니다.</p>
<p>CSR의 경우 최초 웹앱 접속시에 HTML, CSS, Javascript 등 각종 리소스를 단일 페이지로써 한꺼번에 받아오고, 이후 자바스크립트를 사용해서 클라이언트 단독으로 뷰를 별도로 처리하고 렌더링하는 방식입니다. 초기에 리소스를 한꺼번에 불러오므로 첫 페이지 로딩은 느릴 수 있으나, 한번 로딩이 완료되면 그 이후에는 페이지 갱신이나 이동 없이 빠르게 뷰를 변화시킬 수 있습니다. 실제 웹페이지는 비어있고 클라이언트에서 사실상 모든 컨텐츠와 뷰를 자바스크립트를 사용해 가상으로 처리한다는 측면에서 CSR 방식으로는 SEO를 구현하기 어렵습니다. CSR의 대표적인 예시로는 React가 있습니다.</p>
<p>SSR의 경우 일반적인 웹사이트와 유사하게 사용자가 페이지를 이동할 때, 클라이언트가 해당 페이지를 애플리케이션 서버측에 요청하고, 서버는 요청에 맞게 데이터베이스로부터 가져온 데이터를 반영시킨 새로운 페이지를 만들어서 클라이언트로 보내주며, 클라이언트는 이렇게 받은 페이지를 렌더링하는 방식입니다. 대표적인 예시로는 Next.js가 있습니다. 단일 페이지를 사용하지 않으므로 SPA라고 할 수는 없습니다. 하지만 사용자가 요청한 데이터를 반영해 새로 만들어진 페이지를 서버로부터 받아 클라이언트에서 렌더링한 다음, 그렇게 이미 만들어진 DOM에다가 자바스크립트를 사용해서 동적으로 컴포넌트를 끼얹는 hydration 개념을 활용하면 hybrid SPA를 구현할 수 있고, CSR에서 구현하기 어려운 SEO를 보완할 수 있습니다.</p>
</li>
</ul>
</li>
<li>
<p>프론트엔드에서의 퍼포먼스 최적화 기법에 대해서 설명해보세요.</p>
<ul>
<li>(작성중) 코드 스플리팅, 다이나믹 임포트, 윈도우 윙 (부표트 렌더링 집중), 프리페치, 이미지 크기를 정적으로 지정해서 레이아웃 시프트 방지, 리렌더가 잦은 영역에 스프라이트 이미지 사용, 정적 파일 생성기, 등등</li>
</ul>
</li>
</ul>
<h3>프론트엔드 라이브러리/프레임워크</h3>
<ul>
<li>Node.js가 무엇인가요?</li>
<li>jQuery란 무엇인가요?</li>
<li>Static Site Generator란 무엇인가요?
<ul>
<li>SSG는 사용자가 사용하게 될 모든 웹페이지들을 static하게 미리 만들어놓고, 사용자의 요청에 따라 파일 서버로부터 있는 그대로 보내주기만 하는 방식 및 그러한 웹사이트 생성기를 의미합니다. 별도의 애플리케이션 서버가 필요 없는 headless CMS를 사용하는 블로그를 예로 들어보겠습니다. 블로그 운영자가 컨텐츠를 추가하고 그렇게 업데이트된 상태의 블로그를 배포할 준비가 되면, SSG는 추가된 컨텐츠, 즉 변경 사항을 반영해서 웹사이트 전체를 build하고, 이렇게 만들어진 정적 웹페이지들로만 구성된 웹사이트가 사용자에게 있는 그대로 제공하게 됩니다. 클라이언트는 일반적인 웹페이지처럼 미리 만들어진 간결한 HTML, CSS, JS만 브라우저 상에서 렌더링을 해주면 되므로 사용자가 사용할때는 속도가 매우 빠르고, 사용자의 요청에 맞게 컨텐츠를 동적으로 갱신하기 위한 서버가 필요하지 않으므로 보안 측면에서도 우수하다는 장점이 있습니다. 대신에 컨텐츠에 변경 사항이 있을 경우 웹사이트 전체를 build하는 과정이 필요하고 여기에는 시간이 많이 소요될 수 있어 컨텐츠나 데이터가 자주 변경되는 웹사이트에는 적합하지 않습니다. SSG는 SPA를 만드는데 사용하기 부적합합니다. SSG의 대표적인 예시로는 Gatsby, Jekyll 등이 있습니다.</li>
</ul>
</li>
<li>CSR에서 hydration 개념에 대해서 설명해보세요.</li>
</ul>
<h3>React</h3>
<ul>
<li>React Server Component에 대해서 설명해보세요.</li>
<li>Incremental Static ReGeneration에 대해서 설명해보세요.</li>
<li>Lifting State Up이 무엇인가요?</li>
<li>Props drilling을 개선하기 위한 방법을 설명해보세요.</li>
<li>Recoil이 무엇이고 언제 사용하나요?</li>
</ul>
<h3>프론트엔드 네트워크</h3>
<ul>
<li>
<p>쿠키, sessionStorage, localStorage차이점을 설명해주세요.</p>
</li>
<li>
<p>브라우저가 내려받는 리소스의 종류에 대해 설명하세요.</p>
</li>
<li>
<p>웹페이지 로드 속도를 줄이는 방법에 대해 아는대로 설명하세요.</p>
</li>
<li>
<p>웹사이트에서 assets/resources를 최적화 하는 방법에 대해 설명하세요.</p>
</li>
<li>
<p>세션 기반 인증과 JWT에 대해서 설명해보세요.</p>
<ul>
<li>
<p>세션이란 서버 사이드에서 유지하는 상태 정보입니다. 우선 사용자가 로그인을 하게 되면 서버는 인증된 해당 사용자의 정보를 유지관리하기 위한 '세션'을 생성해 DB 또는 서버 메모리에 저장하고, 클라이언트측에 세션의 ID를 부여합니다. 이후 클라이언트는 일반적으로 쿠키 형태로 이러한 세션 ID를 보관하고 있다가, 서버에 요청할 때 세션 ID를 함께 실어 서버로 보내고, 서버는 이렇게 받은 세션 ID를 세션 저장소에 있는 인증 정보와 대조해서 클라이언트의 신원을 확인하고 해당 요청을 승인하는 방식을 세션 기반 인증이라고 합니다. 일반적으로 보안을 위해서 세션 ID는 암호화된 상태로 전송됩니다.</p>
<ul>
<li>세션 기반 인증은 세션 ID가 서버에서 보관되고 처리되므로 세션 하이재킹과 같은 공격이 아니라면 비교적 안전합니다. 세션 ID의 용량은 매우 작은데, 그렇다고 하더라도 서버 사이드에서 클라이언트의 상태를 유지하고 관리해야 하므로 서버의 부담이 증가하고, stateful한 이런 특성으로 인해 사용자의 규모가 큰 경우에는 서버의 분산이나 확장 등의 scalability에 악영향을 주는 단점이 있습니다.</li>
</ul>
</li>
<li>
<p>토큰이란 클라이언트 사이드에서 보유하는 인증 정보입니다. 토큰 기반 인증에는 대표적으로는 JSON Web Token이 있습니다. 사용자가 로그인을 하게 되면 서버에서는 해당 사용자를 인증하는 토큰을 secret key를 통해 생성해서 클라이언트에게 발급해줍니다. 클라이언트에서는 이 토큰을 쿠키, localStorage, sessionStorage 등의 공간에서 저장해두고 있다가, 서버에 요청할 때 HTTP 헤더에 담아서 서버로 보내줍니다. 이 토큰에는 토큰의 타입과 암호화 방식이 담겨있는 header, base64 형태로 사용자/발급/관리/식별 정보가 담긴 payload, 그리고 토큰의 무결성을 증명하기 위해 secret key를 사용해 암호화한 서명인 signature 이렇게 세가지 정보가 담기게 됩니다. 서버에서는 이렇게 받은 토큰을 사용해 해당 요청을 검증하고 승인해주는 방식을 토큰 기반 인증이라고 합니다.</p>
<ul>
<li>토큰 기반 인증은 토큰이 클라이언트에 저장이 되어 있고 payload 안에 각종 정보가 이미 포함되어 있어서 쿼리의 필요성이 경감되고 서버의 부담이 대폭 줄어든다는 장점이 있습니다. 서버에서 상태를 유지하지 않는 stateless한 방식이므로 scalability에 악영향도 없습니다. 각 클라이언트마다 토큰을 보유하므로 중복 로그인 관리와 멀티 디바이스 환경에도 적합합니다. 단점으로는 payload가 암호화되어있지 않고 클라이언트에 저장되어 있으므로 보안에 취약합니다. XSS/CSRF 공격으로 인한 토큰 탈취가 발생할 수 있으므로 payload에는 민감정보를 담지 않아야 하며, 토큰의 변조 여부를 검증하는 암호화가 깨지더라도 토큰을 사용하지 못하도록 만료기간을 짧게 설정하는 것이 좋습니다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>URL Encoding은 무엇인가요?</p>
</li>
</ul>
<h3>기타</h3>
<h2>백엔드</h2>
<h3>백엔드 네트워크</h3>
<ul>
<li>
<p>HTTP 프로토콜에 대해 설명하세요.</p>
</li>
<li>
<p>RESTful API 설계란 무엇인가요?</p>
</li>
<li>
<p>GET과 POST의 차이점은 무엇인가요?</p>
</li>
<li>
<p>CORS란 무엇인가요?</p>
</li>
<li>
<p>미들웨어란 무엇인가요?</p>
</li>
<li>
<p>멱등성이란 무엇인가요? REST API에서 멱등성 개념은 어떻게 연관되어 있나요?</p>
<ul>
<li>
<p>멱등성이란 '연산을 여러번 반복 적용해도 그 결과값이 달라지지 않는 성질'을 의미합니다. HTTP 통신에 있어서 멱등성이란 클라이언트에서 요청을 한번 보내든 여러번 보내든 서버에서 받게 되는 영향과 결과가 다르지 않은, 즉 서버의 상태가 동일하게 유지되는 성질을 의미합니다.</p>
<ul>
<li>
<p>GET 메소드의 경우 정보의 read만을 수행하기 때문에 당연히 멱등성이 보장됩니다.</p>
</li>
<li>
<p>POST 메소드의 경우 create를 수행할 때마다 서버를 통해 데이터베이스에 새로운 정보가 추가되게 되고, 그렇게 반복 추가된 정보는 서버의 상태를 바꾸므로 멱등성을 위반합니다.</p>
</li>
<li>
<p>PUT 메소드의 경우 기존에 있는 정보를 새로운 정보로 update하며, 여러번 반복하더라도 동일한 정보만이 갱신되고 상태는 변하지 않으므로 멱등성을 보장합니다.</p>
</li>
<li>
<p>DELETE 메소드의 경우 기존에 있는 정보의 delete를 수행하며, 여러번 반복하더라도 존재하지 않는 정보에 대한 삭제 시도를 오류로써 나타낼 뿐 정보가 지워진 상태 자체는 변하지 않으므로 멱등성을 보장합니다.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>사용자가 웹브라우저에서 주소를 입력하고 실행하면 어떤 일이 일어나나요?</p>
<ol>
<li>
<p>브라우저는 입력된 웹사이트 주소와 일치하는 IP 주소를 DNS 레코드 캐시에서 또는 DNS 서버에 쿼리를 넣어서 찾기 시작합니다. (애플리케이션 7 레이어)</p>
</li>
<li>
<p>일치하는 IP 주소가 발견되면 웹브라우저와 해당 IP주소의 서버간에 handshake를 통해 TCP 연결을 수립합니다. (전송 4 레이어)</p>
</li>
<li>
<p>연결이 수립되면 브라우저가 HTTP 요청을 서버로 보냅니다. 서버는 요청을 받아 처리한 후 응답을 브라우저로 보냅니다. (애플리케이션 7 레이어)</p>
</li>
<li>
<p>브라우저는 응답으로 받은 HTML/CSS/JS 파일을 캐싱하고 실행하고 렌더링하거나 또는 오류에 대한 status code를 받아 처리합니다.</p>
</li>
</ol>
</li>
</ul>
<h2>SQL / ORM</h2>
<ul>
<li>
<p>SQL Subquery란 무엇이고, 어떤 상황에서 사용되는지 설명하세요.</p>
</li>
<li>
<p>SQL Join 의 종류에 대해 설명하세요.</p>
</li>
<li>
<p>N+1 문제와 해결책에 대해서 설명해보세요.</p>
<ul>
<li>
<p>연관 관계가 설정된 엔티티를 조회하려는 경우에, 특정 엔티티를 1번 조회하고, 그렇게 조회된 데이터 개수 N개 만큼 연관 관계의 엔티티에 대한 조회가 별도로 발생하는 상황을 N+1 문제라고 합니다. 대표적으로는 Java의 ORM 표준인 JPA에서 이 문제가 발생하는데, 항상 사용되지는 않는 연관 엔티티 조회로 인한 자원 낭비를 방지하고 성능과 저장공간의 균형을 맞추기 위해서 이러한 방식을 사용하고 있습니다.</p>
<p>eager loading 방식의 fetch에서 이런 현상이 발생하므로 lazy loading 방식으로 바꾸는 것도 대안이 될 수 있지만 호출 시점이 늦춰질 뿐 N+1개의 쿼리가 발생하는 것은 마찬가지이므로 유의해야 합니다. 한번에 연관 관계에 속한 데이터까지 가져오는 fetch join도 활용할 수 있지만, 지정한 조건에 따라 카테시안 곱이 발생할 수 있으므로 유의해야 합니다. 이 외에도 BatchSize, SUBSELECT, EntityGraph 등을 활용할 수 있으며 각각 특징과 단점들이 있으므로 상황에 따라 적절하게 활용해서 최적화를 이룰 수 있습니다.</p>
</li>
</ul>
</li>
</ul>
<h2>NoSQL / ODM</h2>
<ul>
<li>문서형 데이터베이스와 관계형 데이터베이스의 차이점을 설명해보세요.</li>
</ul>
<hr>
<h1>데이터 과학</h1>
<h2>파이썬</h2>
<h3>Python3</h3>
<ul>
<li>Collection의 종류에 대해 설명하세요.</li>
<li>Decorator에 대해 설명하세요.</li>
<li>List와 Tuple의 차이점에 대해 설명하세요.</li>
<li>파이썬의 함수 파라미터 종류에 대해 설명하세요.</li>
<li>클래스 메소드에 대해 설명하세요.</li>
<li>파이썬의 Docstring에 대해 설명하세요.</li>
<li>Callable 객체에 대해 설명하세요.</li>
<li>GIL에 대해 설명하세요.</li>
<li>파이썬의 패키지 관리자에 대해 설명하세요.</li>
<li>파이썬 가상 환경이란 무엇인지 설명하세요.</li>
<li>PEP-8 스타일 가이드에 대해 설명하세요.</li>
<li>매직 메소드란 무엇이며 사용 예시를 설명하세요.</li>
<li>이터레이터를 생성하는 방법이 무엇인지 설명하세요.</li>
<li>제네레이터와 코루틴이 무엇인지 설명하세요.</li>
<li>파이썬은 어떻게 메모리를 추가/삭제하는지 설명하세요.</li>
<li>파이썬의 인터프리터와 bytecode 에 대해서 설명하세요.</li>
</ul>
<h2>통계학</h2>
<ul>
<li>정규화에 대해서 설명하세요.</li>
</ul>
<h2>이산수학</h2>
<ul>
<li>행렬의 전치와 내적에 대해서 설명하세요.</li>
</ul>
<h2>머신러닝</h2>
<ul>
<li>퍼셉트론에 대해서 설명하세요.</li>
<li>하이퍼파라미터에 대해서 설명하세요.</li>
<li>경사하강법에 대해서 설명하세요.</li>
<li>활성화 함수에 대해서 설명하세요.</li>
<li>one-hot-encoding에 대해서 설명하세요.</li>
</ul>
<hr>
<h1>DevOps / Cloud</h1>
<h2>Version control</h2>
<ul>
<li>코드 형상 관리란 무엇인가요?</li>
<li>CI/CD에 대해 아는대로 설명하세요.</li>
<li>Git Flow에 대해 아는대로 설명하세요.</li>
</ul>
<h2>DevOps</h2>
<ul>
<li>모니터링 도구에 대해 아는대로 설명하세요.</li>
<li>인프라 프로비저닝에 대해 아는대로 설명하세요.</li>
</ul>
<h2>클라우드</h2>
<ul>
<li>도커에 대해 아는대로 설명하세요.</li>
</ul>

    </div>
    
    <div class="mt-20 md:mt-32 lg:mt-32 xl:mt-32"></div>
</article>
        
    </main>
    <footer class="mt-20 px-10 py-8 bg-gray-200">
    <div class="max-w-5xl mx-auto text-gray-700 text-center">
        © 2022 <a href="/" class="font-medium" target="_blank" rel="noopener">devfreedom.github.io</a> by 
        <a href="https://devfreedom.github.io" target="_blank" rel="noopener">devfreedom</a> 
    </div>
</footer>
    <script src="/assets/js/bundle.js"></script>
</body>

</html>