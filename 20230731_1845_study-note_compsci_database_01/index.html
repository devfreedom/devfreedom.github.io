<!DOCTYPE html>
<html>
    
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>[필기] 컴퓨터공학과 &lt;데이터베이스&gt; 과목 - 전반부 | devfreedom.github.io</title>
    <meta name="title" content="[필기] 컴퓨터공학과 &lt;데이터베이스&gt; 과목 - 전반부 | devfreedom.github.io">
    <meta name="description" content="devfreedom&#39;s personal blog">
    <meta name="keywords" content="❮필기❯,컴퓨터공학,데이터베이스,DBMS,RDBMS,SQL,eleventy,template,simple,clean">
    <meta name="author" content="devfreedom">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://devfreedom.github.io/20230731_1845_study-note_compsci_database_01/">
    <link rel="shortcut icon" type="image/png" href="/assets/img/favicon.svg">
    <link rel="apple-touch-icon" href="/assets/img/apple-touch-icon.png">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="/assets/css/main.css">
    
</head>	

<body class="flex flex-col h-screen bg-white text-gray-800 break-words">
    <header id="header" class="header-shadow bg-black px-6 py-5 z-50 fixed w-full top-0 transition-all transform ease-in-out duration-500">
    <div class="max-w-5xl mx-auto flex items-center flex-wrap justify-between">
        <div class="sm:mr-8">
            <a class="flex items-center" href="/">                              
                <span class="text-lg text-white font-semibold self-center">devfreedom.github.io</span>
            </a>
        </div>
        <nav id="menu" class="order-last md:order-none items-center flex-grow w-full md:w-auto md:flex hidden mt-2 md:mt-0">
            
            <a href="/tags" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">Categories</a>
            
            <a href="https://github.com/devfreedom" target="_blank" rel="noopener" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">GitHub</a>
            
            <a href="/about" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">About</a>
            
        </nav>
        <form id="search" action="/search" class="order-last sm:order-none flex-auto w-32 items-center justify-end hidden sm:block mt-6 sm:mt-0">
            <label class="visually-hidden" for="header-searchbox">Search here ...</label>
            <input type="text" id="header-searchbox" name="q" placeholder="Search..." class="w-full sm:max-w-xs bg-gray-200 border border-transparent float-right focus:bg-white focus:border-gray-300 focus:outline-none h-8 p-4 placeholder-gray-700 rounded text-gray-700 text-sm">
        </form>
        <div id="menu-toggle" class="flex items-center md:hidden text-gray-700 hover:text-teal-600 cursor-pointer sm:ml-6">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
    <line x1="3" y1="12" x2="21" y2="12"></line>
    <line x1="3" y1="6" x2="21" y2="6"></line>
    <line x1="3" y1="18" x2="21" y2="18"></line>
</svg>
        </div>
    </div>
</header>
    <main class="mx-7 lg:mx-6 mt-32 flex-grow">
        
        
<article class="max-w-5xl mx-auto">
    <header class="mb-14">
        <h1 class="text-3xl text-center font-bold leading-normal text-gray-900 mt-0 mb-3">[필기] 컴퓨터공학과 &lt;데이터베이스&gt; 과목 - 전반부</h1>
        <div class="text-center">Published on 31 July 2023 06:45 PM</div>
        
        <div class="mt-3 text-center">
            
            <a href="/tags/❮필기❯" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#❮필기❯</a>
            
            <a href="/tags/컴퓨터공학" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#컴퓨터공학</a>
            
            <a href="/tags/데이터베이스" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#데이터베이스</a>
            
            <a href="/tags/DBMS" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#DBMS</a>
            
            <a href="/tags/RDBMS" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#RDBMS</a>
            
            <a href="/tags/SQL" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#SQL</a>
            
        </div>
        
        
        <div class="mt-10 -mx-7 md:mx-0">
            <img class="w-full max-w-2xl mx-auto" src="/assets/img/database.jpg" width="960" height="500" alt="This post thumbnail">
        </div>
        
    </header>
    <div id="content" class="prose text-gray-800 max-w-none">
        <h1>1. 데이터베이스의 개념</h1>
<h2>1-1. 데이터와 데이터베이스</h2>
<h3>데이터와 정보</h3>
<ul>
<li>데이터는 관측/수집된 사실을 특정 기준으로 정리한 값입니다.
<ul>
<li>예: 연간 강수일 174일</li>
</ul>
</li>
<li>정보는 이 데이터를 의사결정과 같은 특정 목적을 위해 해석하거나 가공한 형태입니다.
<ul>
<li>예: 강수 확률 평균 39%</li>
</ul>
</li>
</ul>
<h3>데이터베이스란?</h3>
<ul>
<li>어떠한 조직의 여러 프로그램들이 공동으로 사용하는 데이터들을 통합해서 저장한 운영 데이터의 집합입니다.</li>
<li>데이터베이스에 저장되는 데이터들은 다음의 특성을 충족합니다.
<ul>
<li>공용 데이터
<ul>
<li>여러 부서가 유사한 집합의 데이터를 사용합니다.</li>
<li>예: 학생 관련 데이터를 교무과, 학적과, 학생과에서 사용</li>
</ul>
</li>
<li>통합된 데이터
<ul>
<li>데이터들을 하나의 원천(single source of truth)으로 모아 사용합니다.</li>
<li>중복성을 통제 하에 제거/최소화하고 일관성 유지가 가능합니다.</li>
</ul>
</li>
<li>저장 매체에 저장된 데이터</li>
<li>운영에 필수적인 데이터</li>
</ul>
</li>
</ul>
<h3>데이터베이스의 특징</h3>
<ul>
<li>실시간 접근성
<ul>
<li>쿼리를 실시간으로 처리하고 응답할 수 있습니다.</li>
</ul>
</li>
<li>계속적인 변화
<ul>
<li>시간의 흐름에 따라 데이터베이스의 상태가 지속적으로 동적으로 변동됩니다.</li>
<li>현실 세계의 변화를 반영하고 그것을 표현하기 때문입니다.</li>
</ul>
</li>
<li>동시 공용
<ul>
<li>다른 목적을 지닌 조직들과 프로그램들이 동일한 데이터베이스를 공용으로 사용합니다.</li>
<li>같은 내용을 여러 사용자가 동시에 공유할 수 있습니다.</li>
</ul>
</li>
<li>내용에 의한 참조
<ul>
<li>데이터베이스의 내용은 데이터가 저장된 위치가 아닌 '데이터의 내용'을 기준으로 검색됩니다.
<ul>
<li>프로그래밍 언어: 위치에 의한 참조 (예: 0xFFF26BCF 또는 <code>const ref = &quot;data&quot;</code>)</li>
<li>데이터베이스 언어: <code>SELECT name FROM student WHERE student_id = 237</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>파일 시스템과 데이터베이스의 비교</h3>
<ul>
<li>파일 시스템의 문제
<ul>
<li>데이터 고립 문제
<ul>
<li>파일마다 형식과 위치가 제각각 달라서, 데이터가 사용되지 못하고 방치되는 일이 발생할 수 있습니다.</li>
</ul>
</li>
<li>데이터 종속성 문제
<ul>
<li>응용 프로그램의 가용성이 파일의 형식에 구속되는 '데이터 종속성'이 발생합니다.
<ul>
<li>예: 파일 데이터가 xls 형식에서 csv 형식으로 변경되는 경우, xls 파일만 읽도록 설계된 응용 프로그램은 더이상 사용할 수 없음</li>
</ul>
</li>
<li>데이터를 담고 있는 파일의 내부 구조가 바뀔때마다 응용 프로그램도 그에 맞게 바뀌어야 합니다.</li>
<li>파일 시스템은 '내용에 의한 참조'가 아닌 '위치에 의한 참조'를 사용하기 때문입니다.</li>
</ul>
</li>
<li>데이터 중복 및 일관성 문제
<ul>
<li>동일한 정보가 여러 파일에 중복되어 저장될 가능성이 높습니다.
<ul>
<li>데이터가 어디에 있든 그 상태와 내용이 모두 동일하게 유지/갱신되어야 하는 '일관성'을 유지하기 어렵습니다.</li>
<li>저장 공간이 낭비됩니다.</li>
</ul>
</li>
</ul>
</li>
<li>무결성 문제
<ul>
<li>파일 형태로 저장되다보니 데이터 그 자체에다가 제약 조건을 부여하고 강제하기 어렵습니다.
<ul>
<li>예: 전화번호는 반드시 '13자리 이하의 정수'여야 하는데, 이러한 제약 조건은 평문 텍스트 파일 형식에서는 부여할 수 없음</li>
</ul>
</li>
<li>제약 조건에 변경이 생겨도 이를 파일과 프로그램 모두에 반영하기 까다롭습니다.</li>
</ul>
</li>
<li>원자성 문제
<ul>
<li>하나의 트랜잭션은 그 작업 내용이 '모두 수행됨' 또는 '모두 수행되지 않음' 중 하나의 상태만을 가져야 합니다.</li>
<li>파일 시스템에서는 이를 보장하기 어렵습니다.
<ul>
<li>예: 12개의 파일이 반드시 한꺼번에 삭제되어야 하는데 오류로 인해서 8개만 삭제되고 작업이 끝나버리는 경우</li>
</ul>
</li>
</ul>
</li>
<li>동시 접근 문제
<ul>
<li>동일 시점에 동일한 데이터를 여러 사용자가 동시에 접근해 변경하는 경우 문제가 발생할 수 있습니다.
<ul>
<li>예: FTP를 통해 공유되고 있는 1학년_3반_학사정보.csv 파일을 세 명의 선생님이 동시에 편집을 시도해 race condition이 발생하는 경우</li>
</ul>
</li>
</ul>
</li>
<li>보안 문제
<ul>
<li>시스템 운영에는 데이터 제약 조건 뿐만 아니라 보안 제약 조건도 필요합니다.
<ul>
<li>예: 특정 민감정보를 담고 있는 특정 데이터셋에는 특정 사용자들의 접근을 차단해야 함</li>
</ul>
</li>
<li>세밀한 접근 권한을 수많은 파일 데이터에 일일이 반영하기 어렵고, 응용 프로그램을 통해서만 통제해야 하므로 보안 유지가 어렵습니다.</li>
</ul>
</li>
</ul>
</li>
<li>데이터베이스의 장점
<ul>
<li>데이터베이스의 장점은 자동적으로 발생하는 것은 아니며, 적절하고 효율적인 설계가 중요합니다.
<ul>
<li>데이터 중복 최소화</li>
<li>데이터 일관성 유지</li>
<li>데이터 독립성 유지</li>
<li>데이터 무결성 유지</li>
<li>데이터의 공용과 가용성</li>
<li>데이터 표준화에 유리</li>
<li>데이터 요구사항 조정 가능</li>
<li>데이터 보안 구현 가능</li>
</ul>
</li>
</ul>
</li>
<li>데이터베이스의 단점
<ul>
<li>운영 비용 문제
<ul>
<li>고가의 소프트웨어, 많은 컴퓨터 자원, 고사양의 장비가 필요할 수 있습니다.</li>
</ul>
</li>
<li>자료처리 방법의 복잡성
<ul>
<li>하나의 데이터베이스 아래에 수많은 데이터들이 수많은 형식으로 수많은 제약사항 하에 서로 연관되고 연동될 수 밖에 없습니다.</li>
<li>시스템 구조 및 프로그램 로직이 복잡해질 수 있습니다.</li>
</ul>
</li>
<li>백업과 회복의 어려움
<ul>
<li>데이터의 동시 사용과 공유를 보장해야 하므로 장애 발생시 그 원인과 상태의 분석이 어려울 수 있습니다.</li>
<li>정교한 백업 및 회복 기법을 사용해야 합니다.</li>
</ul>
</li>
<li>통합된 시스템의 취약성
<ul>
<li>모든 데이터가 중앙집중화된 시스템이므로 일부 장애가 전체 시스템을 마비시킬 수 있습니다.</li>
<li>시스템의 신뢰성과 가용성에 DBMS가 의존하게 됩니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>1-2. DBMS</h2>
<h3>데이터베이스 관리 시스템 (DBMS)</h3>
<ul>
<li>데이터베이스를 생성하고 관리해주는 시스템입니다.
<ul>
<li>데이터베이스와 애플리케이션 사이에서 데이터와 관련된 작업을 중개해주는 역할을 합니다.</li>
<li>사용자가 생각하는 데이터베이스의 논리적 구조와, 저장소에 실제로 저장되어 있는 데이터의 물리적 구조를 대응(mapping)시켜줍니다.</li>
<li>대부분의 DBMS는 하드웨어로부터 독립적으로 운영됩니다.</li>
</ul>
</li>
<li>목적
<ul>
<li>데이터 독립성 보장
<ul>
<li>데이터의 논리적/물리적 구조가 변경되더라도 애플리케이션은 영향을 받지 않도록 합니다.</li>
<li>DBMS는 '내용에 의한 참조'를 사용하기 때문입니다.</li>
</ul>
</li>
<li>데이터 중복성 최소화
<ul>
<li>중복되는 데이터로 인해 발생하는 일관성, 보안성, 경제성, 무결성 관련 문제를 해소합니다.</li>
</ul>
</li>
</ul>
</li>
<li>기능
<ul>
<li>데이터 정의
<ul>
<li>데이터 모델에 따라 여러 사용자의 데이터를 통합/저장/공유할 수 있도록 정의합니다.</li>
<li>데이터베이스와 애플리케이션 사이의 프로토콜, 데이터베이스와 사용자 사이의 인터페이스를 정의합니다.</li>
</ul>
</li>
<li>데이터 조작
<ul>
<li>데이터베이스상의 데이터에 삽입/삭제/변경/검색 등의 접근/조작을 수행할 수 있도록 해줍니다.</li>
<li>사용자가 사용하기 쉬워야 하고, 데이터 조작 처리를 자연스럽게 표현할 수 있어야 합니다.</li>
</ul>
</li>
<li>데이터 제어
<ul>
<li>데이터베이스의 내용을 일관되고 정확하게 유지할 수 있게 해줍니다.
<ul>
<li>데이터 일관성 유지</li>
<li>데이터 무결성 유지</li>
<li>데이터 인증 및 보안 유지</li>
<li>백업 및 회복</li>
<li>병행 제어 (concurrency control)
<ul>
<li>여러개의 트랜잭션이 실행될 때, 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않고 다른 트랜잭션에 영향을 주지 않도록 제어합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>구성 요소
<ul>
<li>데이터베이스 언어</li>
<li>사용자
<ul>
<li>일반 사용자
<ul>
<li>비절차적 DML을 사용해 데이터에 접근 및 사용합니다.</li>
</ul>
</li>
<li>프로그래머
<ul>
<li>프로그래밍 언어와 비절차적 DML을 사용해, 데이터를 활용하는 애플리케이션을 개발합니다.</li>
</ul>
</li>
<li>DBA
<ul>
<li>DDL과 DCL을 통해서 데이터베이스 자체를 정의하고 제어합니다.</li>
<li>데이터베이스를 '설계'와 '관리'하는 역할로 나누기도 합니다.
<ul>
<li>설계
<ul>
<li>데이터베이스 개체, relation, 구조, 접근 방법 설계</li>
<li>보안, 권한, 데이터 유효성/무결성 정책 수립</li>
<li>백업 및 회복 절차 수립</li>
</ul>
</li>
<li>운영/관리
<ul>
<li>시스템 카탈로그 유지 관리</li>
<li>데이터베이스 표준화 및 문서화</li>
<li>자원 점유율, 병목 현상, 시스템/장비 성능 및 오류 감시</li>
<li>요구조건 충족과 성능 향상을 위한 데이터베이스 튜닝</li>
</ul>
</li>
<li>분석
<ul>
<li>데이터 접근 방법 및 저장 구조 분석</li>
<li>사용자의 요구조건 변화 파악</li>
<li>데이터 관련 각종 통계 등</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DBMS
<ul>
<li>각 단계별 스키마를 도표화해서 데이터 독립성 구현</li>
<li>스키마를 비롯해 '데이터에 관한 데이터'인 metadata들을 data dictionary를 통해 유지/관리</li>
</ul>
</li>
<li>3단계 데이터베이스
<ul>
<li>외부/개념/내부 스키마</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Schema</h3>
<ul>
<li>스키마는 데이터베이스의 구조와 제약조건을 기술한 명세서
<ul>
<li>데이터 구조를 나타내는 '개체'</li>
<li>개체를 구성하는 '속성'</li>
<li>'개체간 관계(relation)'에 대한 정의</li>
<li>이들이 유지해야 될 '제약조건(constraint)'</li>
</ul>
</li>
<li>외부 스키마 (subschema)
<ul>
<li>사용자 및 응용 관점에서의 데이터베이스 스키마
<ul>
<li>view 단계에서 여러개의 사용자 관점으로 구성
<ul>
<li>각각의 사용자가 보게 되는 개인적 DB 스키마</li>
</ul>
</li>
<li>'시스템 외부'적인 스키마</li>
<li>전체 데이터베이스 중 논리적인 일부분의 스키마</li>
</ul>
</li>
<li>예: 학생과 (학번, 성적) / 교무과 (학번, 이름) / 학적과 (학번, 주소)</li>
</ul>
</li>
<li>개념 스키마 (schema)
<ul>
<li>조직 전체 관점에서의 데이터베이스 스키마
<ul>
<li>통합된 전체적 스키마</li>
</ul>
</li>
<li>예: 학번, 이름, 성적, 주소</li>
</ul>
</li>
<li>내부 스키마
<ul>
<li>저장장치 관점에서 정의한 데이터베이스 스키마
<ul>
<li>'시스템 내부'적인 스키마</li>
</ul>
</li>
<li>예: 학번(INTEGER 10), 이름(VARCHAR), 성적(DECIMAL 3), 주소(VARCHAR)</li>
</ul>
</li>
</ul>
<h3>데이터베이스 언어</h3>
<ul>
<li>데이터베이스를 정의/조작/제어하기 위한 언어입니다.
<ul>
<li>데이터베이스 언어는 1세대 기계어, 2세대 어셈블리어를 넘어, 3세대 언어는 '절차적 언어'를 사용합니다.
<ul>
<li>'무엇'을 '어떻게' 하는지 순서적으로 기술하는 방식입니다.</li>
<li>이후 객체지향 개념이 포함된 3.5세대 언어가 출현합니다.</li>
</ul>
</li>
<li>4세대 언어는 '비절차적 high-level language'로써 '무엇'만을 언급하면 '어떻게'는 시스템이 알아서 수행하도록 합니다.
<ul>
<li>SQL이 여기에 해당됩니다.
<ul>
<li>한번에 하나의 record를 만들어 일괄적으로 처리합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>종류
<ul>
<li>Data Definition Language
<ul>
<li>데이터베이스의 구조를 정의/변경하기 위한 언어</li>
<li>예: CREATE, ALTER, DROP</li>
</ul>
</li>
<li>Data Manipulation Language
<ul>
<li>데이터베이스에 있는 데이터를 변경/처리하기 위한 언어</li>
<li>예: INSERT, DELETE, UPDATE, SELECT</li>
</ul>
</li>
<li>Data Control Language
<ul>
<li>데이터베이스 시스템 자체를 관리(admin)하는 기능을 제공하는 언어</li>
<li>예: GRANT, REVOKE, COMMIT, ROLLBACK</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1>2. 관계형 데이터 모델</h1>
<h2>2-1. 데이터 모델</h2>
<h3>데이터 모델이란?</h3>
<ul>
<li>Structure + Operation + Constraint
<ul>
<li>구조
<ul>
<li>데이터의 정적인 성질</li>
<li>개체의 특성과 개체간 관계를 표현</li>
</ul>
</li>
<li>연산
<ul>
<li>데이터의 동적인 성질</li>
<li>개체 처리 작업과 조작에 관한 명세</li>
</ul>
</li>
<li>제약조건
<ul>
<li>데이터의 논리적 제약</li>
<li>데이터 조작의 한계를 규정</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>관계형 데이터 모델</h3>
<ul>
<li>Relational structure + Relational algebra/calculus + Integrity constraints</li>
<li>특성
<ul>
<li>단순한 모델 구조</li>
<li>수학적 집합이론에 기반한 강건한 모델</li>
<li>비절차적 언어인 SQL을 사용해 간편하게 데이터 처리 가능</li>
</ul>
</li>
<li>개념적 구성 요소
<ul>
<li>개체 (entity)
<ul>
<li>표현하고자 하는 '현실 세계의 고유한 유/무형 객체'</li>
<li>데이터베이스에서 표현되는 정보의 단위</li>
<li>개체의 성질
<ul>
<li>유일한 식별자에 의해 식별 가능해야 함</li>
<li>영속적으로 존재하는 개체의 집합이어야 함</li>
<li>시스템이 추구하는 업무와 관리에 필요한 정보여야 함</li>
<li>업무 프로세스가 반드시 해당 개체를 이용해야 함</li>
<li>반드시 하나 이상의 속성을 포함해야 함
<ul>
<li>속성(attribute)은 가장 작은 논리적 단위로써 내부의 구조를 가지고 있지 않은 atomic한 값</li>
</ul>
</li>
<li>반드시 다른 개체와 최소 한 개 이상의 관계를 맺어야 함</li>
</ul>
</li>
</ul>
</li>
<li>관계 (relationship)
<ul>
<li>개체들 사이에 존재하는 연관성</li>
</ul>
</li>
</ul>
</li>
<li>구조
<ul>
<li>2차원 테이블 구조<pre><code>2024 Q1 Personnel Transfer List

ATTRIBUTE               ATTRIBUTE   ATTRIBUTE
↓       ↓                   ↓           ↓  
id     name                state      dept           ...
--------------------------------------------------------
01     Adam Jenkins        NY         accounting     ...   ← TUPLE
02     Nadia Williams      MD         finance        ...   ← TUPLE
03     Cameron Anderson    CA         marketing      ...   ← TUPLE
04     Lisa McCarthy       NY         finance        ...   ← TUPLE
...    ...                 ...        ...
</code></pre>
<ul>
<li>각각의 행 = tuple = entity
<ul>
<li>예: 첫번째 행 = Adam Jenkins라는 이름을 가진 사람이라는 하나의 entity</li>
</ul>
</li>
<li>각각의 열 = attribute + integrity constraint (= domain)
<ul>
<li>예: 일련번호를 나타내는 id라는 속성 + id라는 속성에 부여되는 무결성 제약조건(2자리 정수)을 따르는 실제 값들</li>
<li>도메인이란?
<ul>
<li>'무결성 제약조건'으로써 특정 속성이 반드시 지켜야 하는 제약조건을 의미합니다.
<ul>
<li>사전적 의미: 하나의 속성이 취할 수 있는 값들의 집합(범위)</li>
</ul>
</li>
<li>프로그래밍 언어에서 특정 변수에 지정되는 '타입'과 유사합니다.
<ul>
<li>예: <code>int x</code> 라고 선언한 변수 x는 반드시 정수형 값만을 가짐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>릴레이션 = tuple들의 집합 = table</li>
<li>스키마 = attribute들의 집합</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>릴레이션</h3>
<ul>
<li>수학적 정의
<ul>
<li>Relation R ⊆ D₁ × D₂ × ... × Dₙ
<ul>
<li>여기서 하나의 도메인 D는 해당 제약조건이 걸려있는 하나의 속성 A에 대응됩니다.</li>
<li>각 도메인들이 카티션 프로덕트(곱셈) 연산을 거쳐, 가능한 모든 pair의 집합으로써 만들어지게 됩니다.</li>
<li>예시: 2024 Q1 Personnel Transfer List
<ul>
<li>id = (01, 02, 03)</li>
<li>state = (NY, MD, CA)</li>
<li>id × state = {(01, NY), (02, MD), (03, CA)}
<ul>
<li>이 릴레이션의 차수(degree) = 속성의 수 = id, state = 2</li>
<li>이 릴레이션의 cardinality = 튜플의 수 = 01, 02, 03 = 3</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>특성
<ul>
<li>튜플의 유일성
<ul>
<li>릴레이션은 튜플들의 '집합'입니다.</li>
<li>집합은 중복을 허용하지 않으므로 모든 튜플은 고유해야 합니다.</li>
</ul>
</li>
<li>튜플의 무순서성
<ul>
<li>릴레이션은 튜플들의 '집합'입니다.</li>
<li>집합에서 원소들간의 순서는 없습니다.</li>
</ul>
</li>
<li>속성의 무순서성
<ul>
<li>스키마는 속성들의 '집합'입니다.</li>
<li>마찬가지로 속성들간의 순서는 없습니다.</li>
</ul>
</li>
<li>속성의 원자성
<ul>
<li>속성은 더 이상 논리적으로 분해할 수 없는 가장 작은 단위의 원자값입니다.</li>
<li>속성값들의 집합은 허용되지 않습니다. 이를 '정규화'라고 합니다.
<ul>
<li>예: 2024 Q1 Personnel Transfer List
<ul>
<li>Adam Jenkins라는 엔티티는 NY라는 state 속성을 가지고 있는데, 여기에 또다시 state라는 속성을 추가할수는 없습니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>2-2. 관계 해석과 관계 대수</h2>
<p>릴레이션을 조작하기 위한 연산에는 두 가지가 있습니다.</p>
<h3>관계 해석(calculus)</h3>
<ul>
<li>쿼리에 대한 검색 조건을 기술합니다.
<ul>
<li>'무엇'을 할 것인가?</li>
</ul>
</li>
<li>튜플 기반 vs 도메인 기반
<ul>
<li>SQL 언어는 '튜플 관계 해석'을 수행합니다.
<ul>
<li>'행'을 기반으로 합니다.</li>
</ul>
</li>
<li>QBE 언어는 '도메인 관계 해석'을 수행합니다.
<ul>
<li>'열'을 기반으로 합니다.</li>
</ul>
</li>
<li>두 해석 방식은 유사하지만 사용하는 변수로써 '행'을 사용하는지 '열'을 사용하는지가 차이점입니다.</li>
</ul>
</li>
</ul>
<h3>관계 대수(algebra)</h3>
<ul>
<li>SQL 쿼리를 실제로 DBMS가 처리를 할 때는 '관계 대수'를 사용합니다.</li>
<li>쿼리에 대한 수행 절차를 기술합니다.
<ul>
<li>'무엇'을 '어떻게' 할 것인가?</li>
</ul>
</li>
<li>중요성
<ul>
<li>관계형 모델에서 실질적인 연산을 위한 공식적 토대입니다.</li>
<li>쿼리 구현 및 최적화를 위한 기반 이론입니다.</li>
<li>관계 대수의 일부 개념은 SQL 표준 쿼리에도 반영됩니다.</li>
</ul>
</li>
<li>연산 종류
<ul>
<li>모델 기반의 분류
<ul>
<li>수학적 집합 연산
<ul>
<li>수학적 집합이론에 근거</li>
<li>예: 합집합, 교집합, 차집합, 카티션 프로덕트</li>
</ul>
</li>
<li>순수 관계 연산
<ul>
<li>2차원 테이블 형태의 형식적 모형에 기반</li>
<li>예: SELECT, PROJECT, JOIN</li>
</ul>
</li>
</ul>
</li>
<li>피연산자 수 기반의 분류
<ul>
<li>단항 연산자
<ul>
<li>연산 대상이 되는 릴레이션을 하나만 가짐</li>
<li>예: SELECT, PROJECT, RENAME</li>
</ul>
</li>
<li>이항 연산자
<ul>
<li>연산 대상이 되는 릴레이션을 두 개 가짐</li>
<li>예: JOIN, 합집합, 교집합, 차집합, 카티션 프로덕트</li>
</ul>
</li>
</ul>
</li>
<li>합성 여부 및 표현 기반의 분류
<ul>
<li>근원 연산
<ul>
<li>관계대수 연산 대부분을 처리할 수 있는 근원적 연산자</li>
<li>합집합, 차집합, 카티션 프로덕트, 프로젝트, 셀렉트</li>
</ul>
</li>
<li>복합 연산
<ul>
<li>근원 연산으로부터 합성이 가능한 연산
<ul>
<li>관계대수 연산 능력을 강화하지는 않지만 '표현 능력'을 향상시킴</li>
</ul>
</li>
<li>교집합, JOIN, DIVISION</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>폐쇄 성질</h3>
<ul>
<li>피연산자와 연산자의 결과가 같은 자료형을 의미합니다.</li>
<li>관계 대수의 모든 연산은 릴레이션에 대해서 폐쇄 성질을 가집니다.
<ul>
<li>특정 릴레이션에 관계 대수 연산을 수행하면, 그 결과도 그대로 릴레이션입니다.</li>
<li>폐쇄 성질에 따라 연산자의 nesting 순서를 표현하게 됩니다.
<ul>
<li><code>OPERATION3( OPERATION2( OPERATION1(RELATION) ) )</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>일반 집합 연산자</h3>
<ul>
<li>합집합, 교집합, 차집합 연산은 '합병 호환성'을 만족해야만 합니다.
<ul>
<li>합병 호환성
<ul>
<li>릴레이션은 튜플의 집합이어야 함</li>
<li>집합은 homogenous한 원소들로 구성되어 있어야만 함</li>
<li>연산의 결과가 릴레이션이어야 함 (=폐쇄 성질)</li>
<li>피연산자의 제약조건
<ul>
<li>차수(=속성의 수)가 같아야 함</li>
<li>대응되는 속성 pair별로 도메인/타입/제약조건이 같아야 함</li>
<li>대응되는 속성 pair별로 의미(semantic)가 같아야 함
<ul>
<li>'의미'가 같은지는 컴퓨터가 스스로 판단할 수 없으므로 사람이 직접 목적에 맞게 확인해서 진행해야 합니다.
<ul>
<li>예: '몸무게'와 '키'라는 전혀 다른 의미의 속성을 union 연산해봤자 그 결과는 아무런 의미가 없음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>연산자 종류
<ul>
<li>합집합 (union)
<ul>
<li>집합간 덧셈 연산</li>
<li>교환 법칙 성립</li>
<li>결합 법칙 성립</li>
<li>중복되는 원소가 제거됨</li>
</ul>
</li>
<li>교집합 (intersect)
<ul>
<li>공통된 원소만 추출</li>
<li>교환 법칙 성립</li>
<li>결합 법칙 성립</li>
<li>중복되는 원소가 제거됨</li>
<li>합집합과 차집합으로도 표현 가능</li>
</ul>
</li>
<li>차집합 (difference)
<ul>
<li>집합간 뺄셈 연산</li>
<li>교환 법칙이 성립하지 않음</li>
</ul>
</li>
<li>카티션 프로덕트 (Cartesian product = cross join)
<ul>
<li>집합간 곱셈 연산
<ul>
<li>R × S = R에 속한 튜플들과 S에 속한 튜플들을 결합해 새로운 튜플을 생성
<ul>
<li>결과의 차수 = R의 차수 + S의 차수</li>
</ul>
</li>
</ul>
</li>
<li>합병 호환성이 필요하지 않음</li>
<li>다른 연산자를 연동해서 적용하면 유용함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>순수 관계 연산자</h3>
<ul>
<li>2차원 테이블 구조 릴레이션을 기반으로 하는 연산자입니다.</li>
<li>연산자 종류
<ul>
<li>SELECT
<ul>
<li>선택조건을 만족하는 튜플들만 걸러냅니다.
<ul>
<li>일항 연산자</li>
<li>선택율 (selectivity)
<ul>
<li>릴레이션 R 전체 중에서 선택조건에 의해 선택된 튜플의 비율</li>
</ul>
</li>
<li>교환성 (commutative)
<ul>
<li>여러 선택조건들을 릴레이션에 적용하는 순서가 바뀌어도 결과는 동일합니다.</li>
<li>다만 선택율이 작은 SELECT 연산을 먼저 수행하는 것이 좋습니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>PROJECT
<ul>
<li>릴레이션에서 일부 속성(열)만 선택하고 나머지를 버립니다.
<ul>
<li>일항 연산자</li>
<li>속성 리스트
<ul>
<li>릴레이션 R 전체 중에서 선택하고자 하는 속성들의 리스트</li>
</ul>
</li>
<li>결과에 속한 중복 튜플들은 모두 제거됨</li>
<li>교환법칙이 성립하지 않음</li>
</ul>
</li>
<li>SELECT와 PROJECT만 있으면 단일 테이블에서 원하는 정보를 충분히 추출 가능합니다.</li>
</ul>
</li>
<li>DIVISION
<ul>
<li>R ÷ S = S에 속한 모든 튜플과 연관이 있는 R 튜플을 찾아냄
<ul>
<li>&quot;모든 ~에 대한&quot; 이라는 쿼리에 적합함</li>
<li>카티션 프로덕트와의 교환법칙이 성립하지 않음
<ul>
<li>R을 S로 나누고, 다시 S를 곱해도 원래의 릴레이션 R로 복원되지 않을 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
<li>SQL에서는 직접적으로 지원하지는 않습니다.</li>
</ul>
</li>
<li>RENAME
<ul>
<li>연산의 중간 결과물에 편의상 이름을 지정하고자 사용합니다.</li>
</ul>
</li>
<li>GROUP
<ul>
<li>릴레이션에 저장된 튜플들의 통계정보를 추출할 때 사용합니다.</li>
<li>테이블에 속한 세부 튜플들을 작은 그룹들로 나누고 각 그룹의 통계정보를 파악할 때 사용합니다.</li>
<li>SUM, MAX, MIN, AVG, COUNT 등의 집단 함수를 리스트로 엮어 사용합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>JOIN 연산자</h3>
<ul>
<li>두 개 이상의 릴레이션이 가지는 관계를 처리할 수 있는 연산입니다.
<ul>
<li>이항 연산자</li>
<li>실제로 두 릴레이션을 합치거나 빼는 것이 아니라, 두 릴레이션 모두에 해당되는 선택조건을 적용해줍니다.
<ul>
<li>concatenation 개념으로써, 여기에 다른 연산을 추가적으로 적용해 활용합니다.</li>
</ul>
</li>
</ul>
</li>
<li>Theta join
<ul>
<li>조인 조건으로써 <code>&gt;, &lt;, =, &gt;=, &lt;=, !=</code> 등을 사용합니다.</li>
<li>일반적으로 동등 비교만을 조건으로 사용하는 equal join을 사용합니다.</li>
</ul>
</li>
<li>Natural join
<ul>
<li>조인 결과에서 조인 속성을 하나 제거해서, 중복된 값이 나타나지 않도록 한 조인입니다.
<ul>
<li>예: 경영학 학위와 영문학 학위를 둘 다 취득한 학생 목록을 학생의 '학번'을 기준으로 불러오고자 할 때,
<ul>
<li>동등 조인: 경영학과 졸업생 목록 릴레이션과 영문학과 졸업생 목록 릴레이션으로부터 '학번', '이름' 등의 공통된 속성들이 중복되어 나타납니다.</li>
<li>자연 조인: 공통된 속성들은 중복 없이 하나만 표시됩니다.</li>
</ul>
</li>
</ul>
</li>
<li>조인 조건을 기술하지 않으며, 조건 없이 두 테이블을 조인한다면 '자연 조인'을 의미합니다.</li>
<li>동등 조인과 자연 조인의 차이점은 '스키마' 입니다.
<ul>
<li>동일한 조인 속성들이 결과 릴레이션에 하나만 나타나는지(자연 조인), 아니면 중복되어 나타나는지(동등 조인) 여부</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>SEMI JOIN</h3>
<ul>
<li>분산 데이터베이스에서 활용합니다.
<ul>
<li>두 릴레이션이 서로 다른 컴퓨터에 저장이 되어 있는 경우, 조인에 참여하는 튜플들만 찾아서 다른 컴퓨터로 해당 릴레이션을 전송합니다.</li>
<li>네트워크 부담을 최소화하는 조인 방법입니다.</li>
</ul>
</li>
</ul>
<h3>OUTER JOIN</h3>
<ul>
<li>조인에 참여하는 릴레이션의 모든 튜플들이 조인 여부와 관계없이 결과 릴레이션에 나타나는 조인 연산입니다.</li>
<li>상대방 릴레이션에 대응되는 튜플이 없으면 NULL값을 채워서 포함시킵니다.</li>
<li>종류
<ul>
<li>LEFT OUTER JOIN
<ul>
<li>릴레이션 R과 릴레이션 S가 있을 때, 릴레이션 R의 모든 튜플들이 결과 릴레이션에 나타나도록 합니다.</li>
</ul>
</li>
<li>RIGHT OUTER JOIN
<ul>
<li>릴레이션 R과 릴레이션 S가 있을 때, 릴레이션 S의 모든 튜플들이 결과 릴레이션에 나타나도록 합니다.</li>
</ul>
</li>
<li>FULL OUTER JOIN
<ul>
<li>릴레이션 R과 릴레이션 S가 있을 때, 릴레이션 R과 S의 모든 튜플들이 결과 릴레이션에 나타나도록 합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>OUTER UNION</h3>
<ul>
<li>합병 호환성을 만족하지 않는 두 릴레이션을 합병해야 하는 경우에 사용합니다.
<ul>
<li>릴레이션의 모든 속성들을 포함하는 확장된 릴레이션을 만듭니다.</li>
<li>확장된 결과 릴레이션에 해당하는 속성값이 없을 때에는 NULL로 채웁니다.</li>
</ul>
</li>
</ul>
<h2>2-3. 제약 조건</h2>
<h3>Key</h3>
<ul>
<li>하나의 릴레이션 내에서 각 튜플을 유일하게 식별해낼 수 있는 속성들의 집합을 '키(key)'라고 합니다.
<ul>
<li>릴레이션이라는 집합의 원소로써, 튜플은 중복되지 않고 고유합니다.<pre><code>2024 Q1 Personnel Transfer List

PK   ATTRIBUTE          ATTRIBUTE   ATTRIBUTE                      PK (= R1's FK)
↓        ↓                   ↓           ↓                          ↓
id     name                state      dept           ...           emp     branch          date
--------------------------------------------------------           ----------------------------------
01     Adam Jenkins        NY         accounting     ...           01      Singapore       2024-01-21    ← TUPLE
02     Nadia Williams      MD         finance        ...           02      London          2024-01-21    ← TUPLE
03     Cameron Anderson    CA         marketing      ...           03      Stockholm       2024-02-07    ← TUPLE
04     Lisa McCarthy       NY         finance        ...           04      Munich          2024-02-13    ← TUPLE
...    ...                 ...        ...                          ...     ...             ...

[R1: EMPLOYEE ROSTER]                                              [R2: 2024 Q1 TRANSFER PLAN]

</code></pre>
<ul>
<li>고유한 튜플이 가지고 있는 모든 속성값들을 사용하면 튜플을 식별해낼 수 있습니다.
<ul>
<li>이 예시에서 id가 01이면서 name이 Adam Jenkins면서 state가 NY면서 dept가 accounting인 튜플은 단 하나밖에 없습니다.</li>
</ul>
</li>
<li>하지만 모든 속성값들이 아니라 각 튜플이 유일하게 보유하고 있는 속성 하나만 있으면 우리는 튜플을 특정해낼 수 있습니다.
<ul>
<li>name도 state도 dept도 중복된 값을 가질 수 있다고 할 때, 중복되지 않은 일련번호인 id를 사용하면 우리는 03번 id를 검색해 Cameron Anderson의 튜플을 곧바로 찾아낼 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
<li>관계형 데이터베이스 모델에서는 내용, 즉 값에 의한 참조를 사용하기 때문에 key가 중요합니다.</li>
</ul>
</li>
<li>특징
<ul>
<li>릴레이션 내에서 해당 키 값을 가지는 속성 집합(열)은 항상 하나만 존재함</li>
<li>시간이 지나도 key의 성질은 불변함</li>
</ul>
</li>
<li>종류
<ul>
<li>후보키 (candidate key)
<ul>
<li>다음 조건을 만족하는 모든 속성들은 후보키가 될 수 있음
<ul>
<li>유일성 (uniqueness)
<ul>
<li>튜플의 유일성을 유지시키는 최소 속성의 집합</li>
<li>서로 다른 두 튜플의 속성 집합의 값이 같지 않고 유일함</li>
</ul>
</li>
<li>최소성 (minimality)
<ul>
<li>서로 다른 두 튜플을 식별하기 위한 최소한의 속성들로만 구성됨</li>
</ul>
</li>
</ul>
</li>
<li>하나의 릴레이션 안에 후보키는 여러 개가 있을 수 있음</li>
</ul>
</li>
<li>기본키 (primary key; PK)
<ul>
<li>여러 개의 후보키들 중에서 사용하기로 결정한 단 하나의 키</li>
</ul>
</li>
<li>슈퍼키 (super key)
<ul>
<li>유일성을 만족하되 최소성을 만족하지 않는 키들</li>
</ul>
</li>
<li>대체키 (alternative key)
<ul>
<li>기본키를 제외한 나머지 후보키들</li>
</ul>
</li>
<li>외래키 (foreign key; FK)
<ul>
<li>참조(referencing) 릴레이션 R1의 튜플과 피참조(referenced) 릴레이션 R2의 튜플간의 연관 관계를 표시하기 위해서 사용
<ul>
<li>위의 예시에서 R1 릴레이션의 기본키인 id를 사용해 R2 릴레이션을 참조하고자 한다면, R2 릴레이션의 기본키 emp는 R1 릴레이션 입장에서는 '외래키'가 됩니다.</li>
</ul>
</li>
<li>두 개의 서로 다른 릴레이션이 아니라 하나의 릴레이션 안에서도 기본키와 외래키가 함께 있을 수 있습니다.
<ul>
<li>외래키는 '참조' 여부에 따라 결정되기 때문입니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>무결성 제약조건</h3>
<ul>
<li>무결성 종류
<ul>
<li>개체 무결성
<ul>
<li>서로 다른 두 튜플의 모든 값이 같을 수는 없음 = 릴레이션에는 기본키가 필요함
<ul>
<li>각 엔티티는 중복되지 않고 고유해야 하며 식별 가능해야 함</li>
<li>릴레이션에서 기본키는 바로 이 고유함을 보장하는 역할을 함
<ul>
<li>만약 기본키가 null이라면 튜플을 유일하게 식별할 수 없으므로, 엔티티의 정의를 위반함</li>
</ul>
</li>
</ul>
</li>
<li>모든 튜플은 반드시 중복되지 않는 고유한 기본키 값을 가져야 한다는, NOT NULL 제약조건을 걸어서 개체 무결성을 보장할 수 있음</li>
</ul>
</li>
<li>참조 무결성
<ul>
<li>참조 릴레이션 R의 외래키 값은 피참조 릴레이션 S의 기본키 값이거나 null이어야 함
<ul>
<li>릴레이션은 참조할 수 없는 외래키를 가질 수 없음
<ul>
<li>참조할 수 없는 외래키를 가진다는 것은, 존재하지 않는 튜플을 참조한다는 의미이기 때문</li>
<li>위의 예시에서 R1의 기본키 id가 R2의 date를 외래키로써 가질수는 없음</li>
</ul>
</li>
<li>다만 외래키 값이 null일 수는 있음</li>
</ul>
</li>
</ul>
</li>
<li>도메인 무결성
<ul>
<li>속성 값은 해당 속성 도메인에 속한 값들 중 하나여야 함
<ul>
<li>예: 대학생의 학년 도메인은 1, 2, 3, 4의 값만 가질 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>이러한 무결성 제약조건들은 데이터베이스 상태가 항상 만족하고 있어야 하는 기본 규칙입니다.
<ul>
<li>DBMS는 이러한 무결성 제약조건들을 항상 확인하고 위반 사항을 감시합니다.</li>
</ul>
</li>
<li>무결성 위반 처리
<ul>
<li>삽입 연산
<ul>
<li>제약조건 위반 시 작업을 거부하거나 위반 사실을 사용자에게 통보</li>
</ul>
</li>
<li>삭제 연산
<ul>
<li>튜플 삭제시 다른 테이블에서 이를 참조하고 있지 않은 상황에서만 삭제 = 참조 무결성 보존</li>
<li>참조 무결성 위반시 옵션
<ul>
<li>삭제 거부</li>
<li>삭제될 튜플을 참조하는 튜플들도 함께 연쇄 삭제</li>
<li>삭제될 튜플을 참조하는 튜플에서 외래키 값을 null로 바꾸거나 다른 유효한 튜플을 참조하도록 변경</li>
</ul>
</li>
</ul>
</li>
<li>갱신 연산
<ul>
<li>기본키나 외래키가 아닌 속성값의 변경은 문제가 없음</li>
<li>갱신 작업은 '삭제 후 삽입' 작업이므로 두 연산에 관한 문제가 모두 발생할 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1>3. 데이터 모델링</h1>
<h2>3-1. 데이터 모델링의 개념</h2>
<h3>데이터 모델링이란?</h3>
<ul>
<li>모델링
<ul>
<li>복잡한 현실 세계를 단순화시켜 표현하는 것</li>
<li>사물/현상에 관한 양상이나 관점을 연관된 사람이나 그룹을 위해 명확화 하는 것</li>
<li>현실 세계의 추상화된 반영</li>
</ul>
</li>
<li>데이터 모델링은 사용자의 요구사항으로부터 데이터의 실체를 나타내는 일입니다.
<ul>
<li>특징
<ul>
<li>추상화
<ul>
<li>다양한 현상을 일정한 양식인 표기법을 통해 표현합니다.</li>
</ul>
</li>
<li>단순화
<ul>
<li>복잡한 현실 세계를 약속된 규약으로 표현해 쉽게 이해할 수 있도록 단순화합니다.</li>
</ul>
</li>
<li>명확화
<ul>
<li>대상에 대한 애매모호함을 제거하고 정확하게 기술해 누구나 이해하기 쉽게 만듭니다.</li>
</ul>
</li>
</ul>
</li>
<li>관점
<ul>
<li>데이터 관점
<ul>
<li>&quot;업무가 어떤 데이터와 관련이 있는지? 데이터간의 관계는? What data, which data?&quot;</li>
<li>데이터베이스의 구조를 온전히 이해하고 쿼리문을 어떻게 효율적으로 구성할지에 필요한 관점입니다.</li>
</ul>
</li>
<li>프로세스 관점
<ul>
<li>&quot;무슨 업무를? 어떻게? How to perform what processes?&quot;</li>
<li>업무에 대한 종합적인 이해를 바탕으로, 데이터에 존재하는 business rule에 따라 참/거짓을 판별할 수 있는 사실을, 데이터로부터 독립적으로 바라보는 관점입니다.</li>
</ul>
</li>
<li>데이터 + 프로세스 관점
<ul>
<li>&quot;업무처리에 영향을 받는 데이터를 어떻게? How data interacts with processes?&quot;</li>
<li>데이터 모델링과 프로세스 모델링은 상호보완적 관계</li>
<li>프로세스를 잘 반영하면서도 동시에 프로세스에 종속되지 않고 유연한 설계가 필요합니다.</li>
</ul>
</li>
<li>정보공학 관점
<ul>
<li>데이터와 프로세스를 분리해서 모델링</li>
</ul>
</li>
<li>객체지향 관점
<ul>
<li>데이터와 프로세스를 '비즈니스 로직'을 기반으로 동시에 모델링</li>
</ul>
</li>
</ul>
</li>
<li>필요성과 목적
<ul>
<li>시스템 구조와 프로세스를 명세화/가시화/문서화</li>
<li>필요한 영역에 집중하기 위해 다른 영역의 세부사항은 숨기는 추상화</li>
<li>정보 요구사항과 한계를 파악하는 가장 직관적인 방법
<ul>
<li>이를 바탕으로 애플리케이션을 개발하고 데이터 정합성을 유지</li>
</ul>
</li>
<li>데이터 품질 향상과 전략적 활용에 필요함</li>
</ul>
</li>
<li>데이터 모델링에서의 유의점
<ul>
<li>중복 (duplication)
<ul>
<li>하나의 원천으로 모일 수 있는 데이터가 잘못 모델링될 경우 불필요하게 중복/낭비/고립될 수 있음</li>
</ul>
</li>
<li>비유연성 (inflexibility)
<ul>
<li>데이터가 프로세스에 종속되거나 고착화될 우려가 있음</li>
</ul>
</li>
<li>비일관성 (inconsistency)
<ul>
<li>데이터의 중복이 없더라도 비일관성은 발생할 수 있음</li>
</ul>
</li>
<li>데이터간의 상호 연관 관계를 명확하게 정의해서 이러한 문제들을 사전에 에방할 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>좋은 데이터 모델링의 조건</h3>
<ul>
<li>완전성: 필요로 하는 모든 데이터가 모델상에 정의되어 있어야 함</li>
<li>중복 배제: 동일한 사실은 반드시 한 번만 기록되어야 함</li>
<li>데이터 재사용: 데이터의 통합성과 독립성에 기반해 재사용이 용이함</li>
<li>업무 규칙: 수많은 business rules를 데이터 모델에 담아내고, 모든 사용자가 그것을 이해하고 공유할 수 있음</li>
<li>안정성 및 확장성: 비즈니스의 변화에 대응할 수 있어야 함</li>
<li>간결성: 관리하고자 하는 데이터를 균형잡히고 단순하게 분류하는 것</li>
<li>의사소통: 좋은 데이터 모델은 그 자체로 의사소통을 원활하게 함</li>
<li>통합성: 동일한 데이터는 조직의 전체에서 한 번만 정의되고, 이를 여러 영역에서 참조/활용하는 방식이어야 함</li>
</ul>
<h2>3-2. 모델링 방법론</h2>
<h3>3단계 모델링</h3>
<ol>
<li>개념 데이터 모델링 = 계획/분석 단계
<ul>
<li>전사적이고 추상적이고 업무적인 포괄적 모델링
<ol>
<li>업무를 주제별로 분석한 후 핵심 엔티티 추출</li>
<li>엔티티간의 관계를 정의</li>
<li>전체 데이터 모델의 골격 생성</li>
<li>엔티티/업무간의 관계를 표현하기 위한 entity-relationship diagram (ERD)를 작성</li>
</ol>
</li>
</ul>
</li>
<li>논리 데이터 모델링 = 분석 단계
<ul>
<li>시스템으로 구축하고자 하는 업무에 대해서 key, attribute, relationship 등을 정확하게 표현하며, 재사용성이 높음
<ol>
<li>ERD를 바탕으로 상세 속성을 정의</li>
<li>식별자 확정</li>
<li>정규화와 같은 상세화 과정 수행</li>
</ol>
</li>
</ul>
</li>
<li>물리 데이터 모델링 = 설계 단계
<ul>
<li>실제로 데이터베이스에 이식할 수 있도록 성능과 저장 장치 등 물리적 성격을 고려함
<ol>
<li>DBMS의 특성과 구현 환경 등을 감안해 스키마를 도출</li>
<li>테이블 컬럼의 데이터 타입과 크기를 정의</li>
<li>효율적으로 데이터베이스를 사용할 수 있도록 사용량 분석 및 예측</li>
<li>인덱스 정의 및 역정규화 등의 세부 작업 수행</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3>데이터 독립성과 3단계 모델링</h3>
<ul>
<li>Service-oriented architecture(SOA)에서 '서비스'란 독립적 비즈니스로 처리 가능한 단위를 의미합니다.
<ul>
<li>과거에는 '데이터가 있는 파일'과 '데이터에 접근하기 위한 인덱스'를 별도로 구현하여 접근했습니다.</li>
<li>요즘은 '사용자의 접근 방법(트랜잭션 유형)'에 따라 파일/인덱스의 정렬 순서와 구성을 별도로 구성합니다.
<ul>
<li>즉, 서비스의 트랜잭션에 따라 데이터의 구성 방법이 영향을 받게 됩니다.</li>
</ul>
</li>
</ul>
</li>
<li>데이터 독립성 확보의 효과
<ul>
<li>각 view의 독립성을 유지
<ul>
<li>계층별 view에 영항을 주지 않고 변경 가능</li>
</ul>
</li>
<li>단계별 스키마에 따라 DDL과 DML을 다르게 제공</li>
</ul>
</li>
<li>ANSI 표준 모델
<ul>
<li>3단계 구조
<ul>
<li>외부 스키마</li>
<li>개념 스키마</li>
<li>내부 스키마</li>
</ul>
</li>
<li>독립성
<ul>
<li>논리적 독립성
<ul>
<li>개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않아야 함</li>
<li>논리적 구조가 변경되어도 애플리케이션에는 영향이 없어야 함</li>
</ul>
</li>
<li>물리적 독립성
<ul>
<li>내부 스키마가 변경되어도 개념 및 외부 스키마는 영향을 받지 않아야 함</li>
<li>저장 장치의 구조가 변경되어도 개념 스키마와 애플리케이션은 영향을 받지 않아야 함</li>
</ul>
</li>
</ul>
</li>
<li>사상 (mapping)
<ul>
<li>논리적 사상
<ul>
<li>사용자에게 인터페이스하기 위한 외부 스키마는 개념 스키마와 연결되어 있어야 함</li>
</ul>
</li>
<li>물리적 사상
<ul>
<li>개념 스키마 구조는 물리적으로 저장되어 있는 테이블 공간과 연결되어 있어야 함</li>
</ul>
</li>
</ul>
</li>
<li>DBA가 필요에 따라 사상을 위한 DDL을 변경하거나, 변경 사항이 있을 때 DBMS가 자동으로 처리해줌으로써 데이터 독립성을 확보할 수 있습니다.</li>
</ul>
</li>
</ul>
<h2>3-3. 개념 데이터 모델</h2>
<ul>
<li>주로 전사적 데이터 모델링에서 사용되며, 조직 전체에서 사용/관리되는 데이터의 골격을 만들어 '전사적으로 동일한 관점에서 데이터를 바라보고 참조할 수 있도록' 합니다.
<ul>
<li>전사의 모든 엔티티를 포함하되 '핵심 엔티티'를 중심으로 핵심 엔티티를 명확하게 정의하고 엔티티간의 관계를 정의합니다.</li>
</ul>
</li>
<li>필요성
<ul>
<li>개념 데이터 모델링을 하지 않으면 개괄 및 전사 데이터 모델과의 불일치가 발생할 수 있음</li>
<li>개념 데이터 모델링을 하지 않으면 논리 및 물리 데이터 모델 작성시 사용자 요구사항 반영이 누락되거나 잘못될 수 있음</li>
<li>개념 데이터 모델링을 하지 않으면 주제 영역간 또는 업무간 데이터 연관에 있어 범위가 불명확해지고 오류가 발생할 수 있음</li>
<li>단, 시스템의 특성이 대부분 연산처리 중심이거나, 업무에 연관된 데이터를 저장하지 않는 경우에는 생략할 수 있음</li>
</ul>
</li>
<li>접근법
<ul>
<li>정방향
<ul>
<li>개괄 데이터 모델로부터 상세화
<ol>
<li>개괄 또는 전사 데이터 모델을 기반으로, 개념 데이터 모델을 작성할 단위 주제 영역을 결정</li>
<li>도출된 핵심 엔티티를 주제 영역과 매핑</li>
<li>주제 영역별로 해당 엔티티들간의 관계를 정의해 개념 데이터 모델 작성</li>
<li>개념 데이터 모델을 상위 애플리케이션/프로세스 모델과 비교해 검증</li>
</ol>
</li>
<li>수집된 후보 엔티티로부터 작성
<ol>
<li>수집된 엔티티 후보들을 검토하고 분류해 핵심 엔티티 도출</li>
<li>수집된 엔티티 후보들과 핵심 엔티티들을 분류해 데이터 주제 영역을 정의</li>
<li>데이터 주제 영역별로 해당되는 핵심 엔티티들을 배치하고, 이들간의 관계를 정의해 개념 데이터 모델 작성</li>
<li>개념 데이터 모델을 상위 애플리케이션/프로세스 모델과 비교해 검증</li>
</ol>
</li>
</ul>
</li>
<li>역방향
<ul>
<li>현행 물리 데이터 모델을 리버스 엔지니어링을 통해 개념 데이터 모델로써 도출
<ol>
<li>현행 물리 데이터 모델을 생성하고 상세화 및 논리화</li>
<li>현행 논리 데이터 모델의 엔티티들을 분류하고, 핵심 엔티티를 도출하고, 이를 현행 데이터 주제 영역에 매핑</li>
<li>현행 논리 데이터 모델로부터 현행 핵심 엔티티간의 관계를 정의해 현행 개념 데이터 모델 작성</li>
<li>사용자 요구사항, 현행 시스템 분석 결과, 참고 사례들을 검토해 개선 사항을 반영하고 '목표 개념 데이터 모델' 생성</li>
<li>목표 개념 데이터 모델을 상위 애플리케이션/프로세스 모델과 비교해 검증</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>세부 모델
<ul>
<li>개념 모델
<ul>
<li>업무 처리에 필요한 주요 엔티티들을 모두 도출하고, 식별자 및 관계 등이 모두 그려진 구체적인 모델</li>
<li>'개념적'이라고 해서 '추상적'인 것은 아닙니다.
<ul>
<li>여기서 말하는 개념은 전체적인 concept를 제대로 잡는다는 의미에서의 개념입니다.</li>
<li>위에서 언급되었듯 전체적인 밑그림을 그리기 위해 필요한 모든 요소들이 포함되어 있어야 합니다.</li>
</ul>
</li>
</ul>
</li>
<li>논리 모델
<ul>
<li>개념 모델을 상세화한 것</li>
<li>주요 엔티티 뿐만 아니라 개별 엔티티들의 속성도 모두 도출된 구체적인 모델</li>
<li>정보 요구사항을 인간이 이해하기 적합한 수준으로 통합/분리해 온전히 구현한 모델</li>
</ul>
</li>
<li>물리 모델
<ul>
<li>DBMS가 데이터를 담는 논리적인 구조</li>
<li>데이터를 현실에서 효율적으로 관리하기 위한 구조</li>
<li>제약 조건의 상세한 명세서</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>주제 영역 (subject area)</h3>
<ul>
<li>기업이 사용하는 데이터의 최상위 집합이며, 주제 영역을 분해하면 하위 영역이나 엔티티가 나오므로 이를 계층적으로 표현 가능
<ul>
<li>데이터는 기본적으로 상호 연결된 관계 구조이므로, top-down이나 bottom-up과 같은 수직적 분석이 쉽지 않습니다.
<ul>
<li>계획 수립 단계에서 주제 영역을 정의하게 되면 데이터를 하향식으로 분석하기에 유용합니다.</li>
<li>검증 단계에서는 상향식 분석을 부분적으로 사용합니다.</li>
</ul>
</li>
</ul>
</li>
<li>특징
<ul>
<li>업무 영역을 구분해 효율적 데이터 모델링을 가능하게 함</li>
<li>대규모 시스템의 데이터 모델링에서 시스템 복잡도를 줄이고 모듈화를 통해 직관성 향상</li>
<li>시스템의 확장성과 개발 품질 향상에 도움을 줌</li>
<li>구축을 넘어 지속적인 운영관리와 현행화를 통해 효용 도출</li>
</ul>
</li>
<li>장점
<ul>
<li>데이터의 계층적 구조 파악에 용이</li>
<li>주제 영역 계층과 업무 기능 계층간 대응관계 확인</li>
<li>전사적 데이터 구성에 대한 청사진 제공</li>
<li>데이터 구성과 통합의 방향을 선언적으로 제시</li>
<li>효율적 데이터 관리 기준 제공</li>
</ul>
</li>
<li>도출 방법
<ol>
<li>주요 데이터 집합의 유형 정의
<ul>
<li>업무 변화에 민감하지 않도록, 기존 시스템별로 제공되는 데이터의 특성을 고려
<ul>
<li>데이터 발생 주체별로 분류
<ul>
<li>예: 관계자, 상품, 서비스, 자산, 채널</li>
</ul>
</li>
<li>주체간의 상호작용으로 발생하는 대상별로 분류
<ul>
<li>예: 계약, 리스크, 상품, 조건</li>
</ul>
</li>
<li>공통 및 관리 성격의 상위 개념으로 분류
<ul>
<li>예: 경영관리, 정책, 지원</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>업무 활동에 필요한 데이터 분류
<ul>
<li>기본/상세/관계 등 데이터의 기능적 구성 관점에서 1차 분류를 더욱 세분화
<ul>
<li>예: 관계자 기본, 관계자 상세, 관계자 관계</li>
</ul>
</li>
</ul>
</li>
<li>2차 영역의 세부 주제 영역 분류
<ul>
<li>사용자에게 제공되는 실제 데이터로서의 관점에 근거해 정의
<ul>
<li>예: 관계자 기본 -&gt; 고객, 법인, 조직, 직원</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>주제 영역의 분류 원칙
<ul>
<li>데이터 관점에서의 분류
<ul>
<li>데이터를 중심으로 바라보고 주제 영역을 분류해야 합니다.
<ul>
<li>데이터와 비즈니스 로직이 혼재되지 않는 것이 중요합니다.</li>
<li>데이터 독립성을 보장해야 합니다.</li>
</ul>
</li>
</ul>
</li>
<li>데이터의 중복 최소화
<ul>
<li>불필요하게 낭비되는 비용과 데이터를 방지하기 위해 체계적 분류가 필요합니다.</li>
</ul>
</li>
<li>데이터의 확장성 보장
<ul>
<li>미래에 추가될 수 있는 정보에 대한 최대한의 확장성을 고려해야 합니다.</li>
</ul>
</li>
<li>데이터의 관련성 및 편의성
<ul>
<li>다른 자원/정보/영역과의 인접성을 고려해야 합니다.</li>
</ul>
</li>
<li>요구사항 변경에 따른 데이터 구조 변화에 대응할 수 있도록 유연성 확보
<ul>
<li>동일 유형의 데이터를 그 본질이 희석되지 않는 한도 내에서 '최대한의 집합'으로 통합시킵니다.
<ul>
<li>그러면 신규 및 변경 요건이 있더라도 기존의 분류 구조에서 적절하게 수용 가능합니다.</li>
</ul>
</li>
</ul>
</li>
<li>주제 영역간의 균형
<ul>
<li>특정 영역들만 너무 상세하거나 방식이 달라서는 안됩니다.</li>
<li>다른 영역의 분류 체계와의 형평성과 균형을 고려해야 합니다.</li>
</ul>
</li>
<li>데이터의 원자성 보장</li>
<li>시간의 흐름에 수직적으로 분할된 주제 영역 분류
<ul>
<li>예: 학원에서 사용할 데이터를 모델링할 때
<ul>
<li>업무 진행의 시간적 흐름이 아니라 각 업무 유형별로 분류를 하게 되면 서비스별로 유사한 엔티티들이 생기게 됩니다.
<ul>
<li>주제 영역을 '강의 과목'별로 분류하게 되면 다음과 같이 정보가 중복되어 담기게 됩니다.
<ul>
<li>A 과목: 수강생, 강의실, 강사</li>
<li>B 과목: 수강생, 강의실, 강사</li>
<li>C 과목: 수강생, 강의실, 강사</li>
</ul>
</li>
</ul>
</li>
<li>따라서 시간의 흐름에 수직적으로 분할해 분류하는 것이 적절합니다.
<ul>
<li>주제 영역을 '수강신청'이라던가 '강좌' 등으로 분류하게 되면 다음과 같이 데이터가 적절하게 분리됩니다.
<ul>
<li>수강신청: 수강생, 강의 과목</li>
<li>강의: 강사, 강의실</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>단, 업무간 관계와 결과물들을 먼저 검토 및 검증한 이후에 수직적으로 분할해야 합니다.
<ul>
<li>자동차 보험, 화재 보험, 생명 보험과 같이 업무 흐름/구조/역할이 각각 크게 다르다면 시간적 흐름이 아닌 업무의 유형별로 분류를 해야 합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>핵심 엔티티</h3>
<ul>
<li>엔티티 종류
<ul>
<li>유/무형 기준
<ul>
<li>유형 엔티티
<ul>
<li>물리적 형태가 있고 지속적으로 활용되는 개체</li>
<li>예: 강사, 물품, 사원</li>
</ul>
</li>
<li>개념 엔티티
<ul>
<li>물리적인 형태가 없으나 관리해야 할 개념</li>
<li>예: 조직, 장소</li>
</ul>
</li>
<li>사건 엔티티
<ul>
<li>업무 수행 과정에서 발생되는 개체로써 비교적 발생량이 많음</li>
<li>예: 주문, 청구, 미납 등</li>
</ul>
</li>
</ul>
</li>
<li>발생 시점 기준
<ul>
<li>기본(key) 엔티티
<ul>
<li>업무에 원래 존재하는 정보로써 독립적으로 생성됨</li>
<li>다른 엔티티들의 최상위 엔티티로써, 상위 엔티티를 가지지 않은 독립적인 엔티티</li>
<li>ERD 상에서 주어가 되는 엔티티
<ul>
<li>예: 사원, 고객, 강좌, 학생, 교수, 상품, 계정</li>
</ul>
</li>
</ul>
</li>
<li>주요(main) 엔티티
<ul>
<li>기본 엔티티에 의해 발생하며 업무에서 중심적인 역할 수행</li>
<li>다른 엔티티와의 관계를 통해 행위 엔티티를 생성
<ul>
<li>예: 기본 엔티티 '상품' -&gt; 주요 엔티티 '상품 주문'</li>
</ul>
</li>
<li>발생량이 비교적 많음
<ul>
<li>파생된 주요 엔티티는 업무적으로 다른 엔티티들을 파생시키기도 함
<ul>
<li>예: 주요 엔티티 '계약' -&gt; '가입 계약, 납입 계약'</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>행위(action) 엔티티
<ul>
<li>두 개 이상의 상위 엔티티를 가짐</li>
<li>내용이 자주 바뀌거나 데이터 양이 증가함</li>
<li>분석 초기보다는 이후 상세 설계 과정에서 도출될 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>핵심 엔티티 후보군 수집</h3>
<ul>
<li>기존 시스템 문서로부터 수집
<ul>
<li>기존 시스템을 그대로 따르는 것이 아니라 참조만 하고, 현재 업무에서 그 엔티티 타입이 유효한지만을 검증하면 됨</li>
<li>주로 업무처리가 명사화 되어있는 장표를 이용해서 엔티티 타입 도출
<ul>
<li>이 외에도 현업 인터뷰, 데이터 흐름도, 유사 시스템, 현장 조사 등을 활용</li>
</ul>
</li>
</ul>
</li>
<li>과정
<ol>
<li>후보 엔티티의 명확한 개념 정립
<ul>
<li>&quot;이 단어가 의미하는 진정한 집합이 무엇인가?&quot;</li>
</ul>
</li>
<li>현재 및 향후 관리 여부 확인
<ul>
<li>현재 관리할 대상 뿐만 아니라 앞으로 관리하게 될 것들에 대한 전략적 판단 필요</li>
</ul>
</li>
<li>집합 개념 여부 확인
<ul>
<li>엔티티는 집합이어야 하지만, 모든 집합이 엔티티화 되는 것은 아님</li>
</ul>
</li>
</ol>
</li>
<li>후보 엔티티 식별 과정
<ol>
<li>기존 시스템 문서에서 '명사'형을 추출</li>
<li>포괄적인 업무 프로세스에 해당하는 명사를 비롯해 불분명하고 광범위한 개념 제거
<ul>
<li>예: 회사, 취소, 확인</li>
</ul>
</li>
<li>엔티티 타입의 특성이나 속성 제거
<ul>
<li>예: 크기, 길이, 이름 등은 엔티티의 '세부 속성'이어야지 '엔티티'로 선정하기는 어려움</li>
</ul>
</li>
<li>중복되는 명사 제거
<ul>
<li>명사의 일반적인 사전적 의미와 특정 업계/산업/부서/업무에서 사용되는 의미가 다른 경우에 유의해야 함</li>
</ul>
</li>
<li>누락된 엔티티 타입이 존재하는지 검토</li>
<li>도출된 엔티티들을 기본 엔티티와 주요 엔티티로 분류 수행</li>
<li>나머지 엔티티들을 행위 엔티티로 분류 수행</li>
<li>데이터 주제 영역별로 분류 수행
<ul>
<li>예:
<ul>
<li>사람 -&gt; 직원, 고객, 가입자, 회원 ...</li>
<li>사건 -&gt; 계약, 수주, 주문, 발주 ...</li>
<li>재무 -&gt; 입금, 청구, 차입금, 예적금...</li>
</ul>
</li>
</ul>
</li>
<li>핵심 엔티티로써의 조건을 만족하는지 확인하여 최종 선정 및 정의</li>
</ol>
</li>
</ul>
<h3>식별자 (identifier)</h3>
<ul>
<li>어떠한 엔티티 집합에서 각각의 개별 엔티티들을 구분할 수 있는 고유한 결정자
<ul>
<li>모든 엔티티들은 반드시 하나 이상의 식별자를 가지고 있어야 함
<ul>
<li>예: 대한민국 국민이라면 누구나 가지고 있는 주민등록번호</li>
</ul>
</li>
<li>데이터 모델링이 오류 없이 수행되었는지를 판단하는 근거</li>
<li>설계된 모델이 데이터베이스로써 실제로 구현이 될 때 primary key, foreign key 등의 역할을 수행하게 됨
<ul>
<li>식별자는 '논리적 모델링'에서 사용되는 개념</li>
<li>key는 '물리적 모델링'에서 사용되는 개념</li>
</ul>
</li>
</ul>
</li>
<li>의미
<ul>
<li>핵심 엔티티의 주 식별자 결정에 따라 전체 데이터 모델의 복잡성이 결정됨</li>
<li>시스템 구축 작업에서 매우 중요한 작업임</li>
</ul>
</li>
<li>조건
<ul>
<li>엔티티 집합의 모든 엔티티는 식별자에 의해서 유일하게 구분되어야 함</li>
<li>특정 엔티티 타입에 식별자가 지정되면 해당 식별자는 변하지 않아야 함</li>
<li>주 식별자가 지정이 되었다면 그 속성에는 반드시 어떠한 값이 존재해야 함</li>
</ul>
</li>
<li>종류
<ul>
<li>대표성 여부 기준
<ul>
<li>주 식별자
<ul>
<li>해당 업무에서 자주 이용되는 속성을 주 식별자로 지정함
<ul>
<li>예: '사원' 엔티티 관리에 '사원번호' 속성을 주 식별자로 사용</li>
</ul>
</li>
<li>원칙
<ul>
<li>속성값의 길이가 가변적인 경우는 주 식별자로 부적합함
<ul>
<li>예: 각 부서를 구분하기 위해 '부서명'을 사용하는 것은 부적합함</li>
<li>이 경우 다른 마땅한 속성이 없다면 새로운 식별자를 생성해서 사용함
<ul>
<li>예: 각 부서를 구분하기 위해 '부서 번호'라는 식별자를 만들어 사용하고, '부서명'은 보조 식별자로 활용하는 방법</li>
</ul>
</li>
</ul>
</li>
<li>속성값이 자주 변하는 속성은 주 식별자로 부적합함
<ul>
<li>예: 직원이 독자적으로 자주 바꿀 수 있는 '이메일 주소'를 주 식별자로 사용하는 것은 좋지 않음</li>
<li>주 식별자와 연동되는 모든 엔티티들로 그 영향이 파급되므로 시스템 전반에 악영향을 끼침</li>
</ul>
</li>
<li>주 식별자의 속성 수는 최소화하는 것이 좋음
<ul>
<li>주 식별자가 여러 속성들로 이루어진 복합 식별자인 경우, 해당 속성의 숫자가 7개를 넘지 않는 것이 좋음
<ul>
<li>예: '접수' 엔티티의 주 식별자 속성 = '접수일자', '담당부서', '지사', '접수방법', '신청인 구분' '신청인 이름', '신청횟수'</li>
<li>이 이상으로 숫자가 늘어나면 JOIN 연산이 복잡해질 수 있어서 성능 저하 유발</li>
</ul>
</li>
<li>7개 이상의 속성이 필요한 경우 별도의 주 식별자를 생성하여 사용
<ul>
<li>예: '접수' 엔티티의 주 식별자로 '접수번호'를 새로 만들어서 사용</li>
</ul>
</li>
</ul>
</li>
<li>주 식별자의 속성에는 반드시 실제로 값이 들어 있어야 함
<ul>
<li>예: '사원' 엔티티에 '사원번호'가 주 식별자인 경우, 모든 사원은 실제로 사원번호를 가지고 있어야 함</li>
<li>예: 외국 국적의 직원들은 '주민등록번호'를 가지고 있지 않고 대신 '외국인등록번호'를 가지고 있으므로, 다국적 조직에서의 사원 엔티티의 경우 '주민등록번호'를 주 식별자로 사용할 수 없음.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>대체/보조 식별자
<ul>
<li>원래의 식별자를 대신할 수 있는 또다른 속성들이나 관계
<ul>
<li>예: '사원' 엔티티에 공식적으로 부여된 '사원번호' 대신 '주민등록번호'를 식별자로 사용하는 경우</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>본질 식별자
<ul>
<li>속성들 중에서 집합의 본질을 명확하게 설명할 수 있는 의미상의 주어</li>
<li>상속 관계를 규명해 올라갔을 때 최종적으로 최상위 기본 엔티티를 발견할 수 있는 식별자
<ul>
<li>예: 본질 식별자 '고객번호, 상품코드' -&gt; 행위 엔티티 '결제' -&gt; 주요 엔티티 '신용카드' -&gt; 기본 엔티티 '고객, 상품'</li>
</ul>
</li>
</ul>
</li>
<li>인조 식별자
<ul>
<li>기존의 본질 식별자를 실질적으로 사용하거나 인정할 수 없는 경우가 발생했을 때 이를 일부/전부 대체해 새롭게 구성한 식별자
<ul>
<li>예: '주민등록번호' 식별자를 사용하기에는 관리상 불편해서 이보다 짧은 '사원번호'를 공식 식별자로 대체하는 경우</li>
</ul>
</li>
</ul>
</li>
<li>후보 식별자
<ul>
<li>각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성들의 집합</li>
</ul>
</li>
<li>실질 식별자
<ul>
<li>인스턴스를 식별하기 위해 공식적으로 부여된 식별자</li>
<li>본질 식별자와 인조 식별자 모두가 실질 식별자가 될 수 있음</li>
</ul>
</li>
<li>그 외의 기준
<ul>
<li>생성된 기원 기준
<ul>
<li>내부 식별자</li>
<li>외부 식별자</li>
</ul>
</li>
<li>단일 속성 식별 여부
<ul>
<li>단일 식별자</li>
<li>복합 식별자</li>
</ul>
</li>
<li>대체 여부
<ul>
<li>원조 식별자</li>
<li>대리 식별자</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1>4. 관계 (relationship)</h1>
<h2>4-1. 관계의 개념</h2>
<ul>
<li>데이터 모델에서의 정의
<ul>
<li>엔티티 사이의 논리적인 연관성</li>
<li>존재의 형태나 행위로써 서로에게 연관성이 부여된 상태</li>
<li>엔티티 안에 있는 인스턴스가 개별적으로 연관 관계를 가지고 있음
<ul>
<li>이것들의 집합을 '관계'라고 표현함</li>
<li>각 인스턴스가 각각 다른 종류의 관계를 가지는 경우 두 엔티티 사이에 두 개 이상의 관계가 형성될 수 있음</li>
</ul>
</li>
<li>개체 = 논리적으로 표현된 '인스턴스의 집합'</li>
<li>관계 = 논리적으로 표현된 '관계 페어링(pairing)과 어커런스(occurrence)'</li>
</ul>
</li>
<li>관계의 분류
<ul>
<li>존재에 의한 관계
<ul>
<li>특정 이벤트를 필요로 하지 않고 자연적인 존재상태에 의해 발생하는 관계
<ul>
<li>주로 '기본 식별자/엔티티'가 여기에 해당됨</li>
</ul>
</li>
<li>예: '총무과'에 '김진성 사원'이 소속되어 있음</li>
</ul>
</li>
<li>행위에 의한 관계
<ul>
<li>특정 사건/이벤트/행위에 의해 발생하는 관계
<ul>
<li>주로 '주요/행위 식별자/엔티티'가 여기에 해당됨</li>
</ul>
</li>
<li>예: 고객이 카드 결제를 시도해서 '승인번호'가 생성됨
<ul>
<li>'카드 결제'라는 행위로 인해 발생</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>관계 표현
<ul>
<li>이항(binary) 관계
<ul>
<li>예: '강의'가 '교수'와 '과목'과 연결되어 있는 경우</li>
</ul>
</li>
<li>삼항(ternary) 관계
<ul>
<li>예: '소속'이 '교수'와 '학과'와 '학생'과 연결되어 있는 경우</li>
</ul>
</li>
<li>N항(N-ary) 관계
<ul>
<li>실제로 나타나는 경우는 거의 없음</li>
</ul>
</li>
</ul>
</li>
<li>멤버십 (membership)
<ul>
<li>각 관계에는 두 개의 상호 연결, 즉 '멤버십'이 나타나고, 두 가지의 관점으로써 표현됨
<ul>
<li>예: '총무과'는 '김진형 사원'을 포함 = '김진형 사원'은 '총무과'에 소속</li>
<li>관계의 시작점 = 엔티티에서 관계가 시작되는 쪽</li>
<li>관계의 끝점 = 엔티티에서 관계를 받는 쪽</li>
</ul>
</li>
</ul>
</li>
<li>관계명
<ul>
<li>관점에 따라 능동적이거나 수동적으로 명명됨</li>
<li>원칙
<ul>
<li>현재형으로 표현할 것
<ul>
<li>예: '수강신청 예정'이 아닌 '수강신청'</li>
</ul>
</li>
<li>애매한 동사를 피할 것
<ul>
<li>예: '회계 관련 업무'가 아닌 '회계 업무'</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>관계의 선택성
<ul>
<li>&quot;관계에 참여하는 엔티티 집합의 인스턴스가 항상 관계에 참여해야 하는가?&quot;의 여부
<ul>
<li>필수(mandatory) or 선택(optional)</li>
<li>여기서 '선택' 참여 처리되는 속성은 foreign key로 참조될 경우 null값을 허용할 수 있게 됨</li>
</ul>
</li>
<li>만약 선택참여로 지정해야 할 관계를 필수참여로 지정해버리면?
<ul>
<li>데이터가 발생하면 이를 반드시 한 개의 트랜잭션으로써 제어해야 하는 제약사항이 생기는 문제가 발생함</li>
<li>관계의 선택 사양 설정을 잘못하면 참조 무결성 제약조건에 영향을 미칠 수 있음</li>
<li>비즈니스 로직 개발에 큰 영향을 미치므로 설계 과정에서 신중하게 결정해야 함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>관계의 차수</h3>
<ul>
<li>두 엔티티간 관계에서의 '참여자의 수'를 의미함</li>
<li>one-to-many (1:M)
<ul>
<li>가장 흔하게 나타나는 매우 일반적인 형태</li>
<li>부모-자식 관계처럼 계층적이라고 이해하면 쉬움</li>
<li>참조하는 대상이 상위 항목이어야 집합에 변화가 생기지 않으므로, many가 아니라 one을 참조하는 관계
<ul>
<li>필수-필수 관계
<ul>
<li>현실에서 가끔 발생하는 형태</li>
<li>예: '구매'라는 업무에 있어서 하나의 '주문'이 한 개 이상의 '제품'들을 반드시 포함해야만 하는 경우
<ul>
<li>주문이 발생하면 제품도 반드시 존재해야 함 = 구입할 제품이 없는 주문은 의미가 없음</li>
<li>구매할 제품이 있다면 주문도 발생해야 함 = 주문이 없는 제품은 구매의 의미가 없음</li>
</ul>
</li>
</ul>
</li>
<li>선택-필수 관계
<ul>
<li>가장 흔하게 발생하는 형태</li>
<li>예: '인사관리' 업무에 있어서 하나의 '부서'와 한 명 이상의 '사원'들의 관계
<ul>
<li>모든 부서가 '사원'을 포함하지는 않으나, = 선택
<ul>
<li>신생 부서의 경우 사원이 없을 수 있음</li>
</ul>
</li>
<li>모든 '사원'은 어떠한 '부서'에든 속해야 함 = 필수</li>
</ul>
</li>
</ul>
</li>
<li>필수-선택 관계
<ul>
<li>현실에서 가끔 발생하는 형태</li>
<li>예: 여러 구매자들이 모여 그 규모에 비례하는 할인율로 특정 제품을 구입하는 '소셜 공동구매'라는 업무에 있어서, 하나의 '상품'과 한 명 이상의 '고객'들의 관계
<ul>
<li>소셜 공동구매를 통해 판매가 이루어져야 할 '상품'은 반드시 존재해야 하지만, = 필수</li>
<li>모든 고객들이 해당 상품을 구매해야 하는 것은 아님 = 선택
<ul>
<li>제품 구매 의사에 따라 고객은 소셜 공동구매에 참여를 할 수도 있고 안할 수도 있음</li>
<li>소셜 공동구매에 참여할 고객의 목록이 최종 결정되고 나서야 상품 판매가 의미를 가짐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>선택-선택 관계
<ul>
<li>흔하게 발생하는 형태</li>
<li>관계의 선택성이 증가할수록 모델의 모호성이 증가될 수 있으므로 이를 해소해야 함</li>
<li>예: '여행상품 판매'에 있어서 '고객'과 '예약'의 관계
<ul>
<li>고객이 없더라도 예약을 미리 잡을 수 있음</li>
<li>예약이 없더라도 고객은 존재할 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>one-to-one (1:1)
<ul>
<li>엔티티 타입이 독립적으로 분리되면서 상호간에 하나의 관계만 성립함
<ul>
<li>필수-선택 관계
<ul>
<li>한 엔티티에 대응되는 상대 엔티티는 반드시 존재하나, 그 반대는 존재하지 않을수도 있음</li>
</ul>
</li>
<li>필수-필수 관계
<ul>
<li>두 엔티티가 같은 경우</li>
</ul>
</li>
<li>선택-선택 관계
<ul>
<li>거의 발생하지 않음</li>
</ul>
</li>
</ul>
</li>
<li>현실적으로 흔하게 나타나지는 않음</li>
<li>개체의 수직 분할에서 많이 나타나며, 업무 흐름에 따라 데이터가 설계된 형태에서 주로 발생</li>
</ul>
</li>
<li>many-to-many (M:M)
<ul>
<li>관계를 가진 양쪽 당사자 모두에서 1:M 관계가 존재하는 형태</li>
<li>데이터 모델링이 완료되었다면 M:M 관계는 더이상 존재하지 않음
<ul>
<li>M:M 관계가 발견되었다면 데이터 모델링이 완전하지 않은 상태이므로 M:M 관계를 해소해야 함</li>
<li>M:M 관계를 해소하면 새로운 릴레이션 엔티티가 생성되게 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>4-2. 관계 도출</h2>
<h3>관계 정의 과정</h3>
<ol>
<li>관계를 정의할 수 있는 두 핵심 엔티티간의 관계를 도출
<ul>
<li>두 엔티티간에 업무적 연관성을 가지고 쌍방의 관점을 가지고 있는 핵심 엔티티를 선정
<ul>
<li>기존 시스템 문서에서 동사 구분</li>
<li>도출된 핵심 엔티티와 관계를 이용해 관계 정의 작성 후 세분화</li>
</ul>
</li>
</ul>
</li>
<li>핵심 엔티티간의 관계성을 정의
<ul>
<li>관계를 통해 정보의 활용가치를 상승시키도록 정합성을 유지</li>
<li>기수성/차수/degree/cardinality를 검토
<ul>
<li>one or many</li>
</ul>
</li>
<li>선택성을 검토
<ul>
<li>주로 one(선택/referenced)-to-many(필수/referencing) 관계가 가장 흔함</li>
<li>one쪽 엔티티에 many쪽 엔티티들이 필수적으로 참여하도록 설계하는 것이 바람직함</li>
</ul>
</li>
<li>관계명 정의
<ul>
<li>두 개의 관계 멤버십에 상대방 입장에서의 관계명을 기술하도록 각각 부여</li>
<li>업무적 연관성을 나타내는 이름을 현업에서 사용하는 간결한 현재 시제 동사형으로 부여</li>
<li>업무적 의미가 없거나 애매모호한 용어 배제</li>
</ul>
</li>
</ul>
</li>
<li>식별 관계 설정
<ul>
<li>식별 관계 = 강한 엔티티와 약한 엔티티의 관계 = 존재/존속 관계
<ul>
<li>식별 = 부모 엔티티의 식별자가 자식 엔티티의 주 식별자의 일부가 되는 경우</li>
<li>비식별 = 부모 엔티티의 주 식별자가 자식 엔티티의 non-key 영역으로 이주하고 자식을 식별하는 데 관여하지 않음</li>
</ul>
</li>
</ul>
</li>
<li>관계의 성격을 구분해 관계를 확정하기
<ol>
<li>관계 도출해내기
<ul>
<li>엔티티 타입 도출에 사용되었던 6가지 방법과 동일
<ul>
<li>엔티티가 '명사형'이라면 관계는 '동사형'으로써 구분될 수 있음
<ul>
<li>예: 학원
<ul>
<li>강사는 여러개의 강좌를 강의할 수 있다.</li>
<li>학원에서는 여러 명의 강사를 관리한다.</li>
<li>학원해서 개설한 강좌는 강사 1명이 강의를 진행한다.</li>
<li>동사: 강의한다, 관리한다, 개설한다</li>
</ul>
</li>
</ul>
</li>
<li>이를 관계 정의서 또는 ERD로 표현한 후 정제 과정을 거침</li>
</ul>
</li>
<li>관계라는 것은 기존 업무 문서에 정확하게 기술되어 있는 경우는 거의 없으므로 내용을 보고 관계를 유추해내야 함</li>
</ul>
</li>
<li>도출된 엔티티들과 관계를 기반으로 관계 정의서를 작성
<ul>
<li>예: '사원' 엔티티 타입의 관계 정의서
<ul>
<li>관계: 각 사원은 한 부서에 속한다. 각 부서에는 여러 사원들이 존재할 수 있다.
<ul>
<li>참여: 사원(필수) - 부서(선택)</li>
<li>관련 엔티티 타입: 부서</li>
</ul>
</li>
<li>관계: 각 사원은 여러 주문을 접수할 수 있다. 각 주문은 한 명의 사원에 의해서만 접수된다.
<ul>
<li>참여: 사원(선택) - 주문(필수)</li>
<li>관련 엔티티 타입: 주문</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>고객에게 질문과 인터뷰를 통해 도출된 관계를 세분화/구체화하기
<ul>
<li>&quot;각 (기준 엔티티)는 (하나의 or 여러) (관련 개체) (만/항상) (소속할/소속될) 수 있는가?&quot;
<ul>
<li>&quot;각 (엔티티1)은 하나의 (엔티티2)에 속합니까?&quot; = 1:1?</li>
<li>&quot;각 (엔티티1)은 여러 (엔티티2)에도 소속될 수 있습니까? = 1:M?</li>
<li>&quot;각 (엔티티1)은 (엔티티2)에 속하지 않을 수도 있습니까?&quot; = 선택참여/필수참여?</li>
</ul>
</li>
</ul>
</li>
<li>데이터 모델링 도구 등을 이용해 모델을 직접 그려보기
<ul>
<li>의사소통 향상</li>
<li>엔티티 타입 배치 용이</li>
<li>관계 설정/수정이 쉬움</li>
</ul>
</li>
<li>고객과 질문하고 협의해 모델을 검토
<ul>
<li>ERD를 그리기 전에는 고객과 인터뷰를 진행</li>
<li>ERD를 그리고 나면 관계가 정확히 설정되었는지, 누락된 것은 없는지 고객과 검토</li>
<li>고객의 의견을 모두 반영해야 하는 것은 아님
<ul>
<li>현업 현직자들은 현재의 업무 흐름에 익숙해져 있으므로 변화에 보수적일 수 있음</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3>관계 검토</h3>
<ul>
<li>엔티티 타입간의 업무적 연관성을 정의한 결과물을 검증해야 할 필요가 있음</li>
<li>엔티티 타입간에 M:M 관계가 남아있는가?
<ul>
<li>M:M 관계는 남아있지 않아야 함
<ul>
<li>프로젝트를 진행하던 도중 도출되지 않은 업무 규칙이 발견되거나, 업무 규칙이 새로 추가되는 상황에서 발생함</li>
<li>관계 타입을 발생시키는 업무 규칙이 발견되었다면 일단 무조건 ERD상에 표현해야 함</li>
<li>그리고 나서 관계 타입이 반드시 별도로 존재해야 하는지를 검토</li>
</ul>
</li>
<li>M:M 해소 방법
<ul>
<li>관계 타입의 분리
<ul>
<li>예: 요금 납부 업무
<ul>
<li>하나의 요금이 여러번 납부될 수 있음 = 1:M</li>
<li>여러 요금이 한 번에 납부될 수 있음 = M:1</li>
<li>이렇게 M:M 관계가 발생한 경우 1:M 형식으로 분리해서 해소를 해야 함
<ul>
<li>여기서는 엔티티 발생 순서대로 '요금'과 '납부'를 이어 붙여 명명한 새로운 '요금납부'라는 관계 타입을 만들어 분리함
<ul>
<li>'요금'과 '요금납부' = 1:M</li>
<li>'요금납부'와 '납부' = M:1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>주 식별자 통합
<ul>
<li>관계 타입의 분리를 통해 M:M을 해소하게 되면 ERD가 복잡해질 수 있음</li>
<li>PK를 사용해 하나의 엔티티 타입으로 통합하는 방식으로도 해소가 가능함
<ul>
<li>예: 요금 납부 업무
<ul>
<li>요금의 주 식별자 = 요금번호</li>
<li>납부의 주 식별자 = 납부번호
<ul>
<li>납부의 주 식별자를 '납부번호 + 요금 납부 순차 번호' 형식으로 바꾸면 됨
<ul>
<li>한 번의 납부로도 여러 요금고지서의 납부가 가능한 형태가 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>장점
<ul>
<li>엔티티 타입의 통합을 통해 데이터 모델 복잡도 감소</li>
<li>물리적 테이블에서 데이터를 가져올 때 여러 테이블에 대한 JOIN을 하지 않음</li>
<li>트랜잭션 수가 적지만 반드시 업무에 필요한 경우에 적용함</li>
</ul>
</li>
<li>유의사항
<ul>
<li>부모 엔티티와 자식 엔티티의 생사가 같아야만(존재 종속) 가능함</li>
<li>통합되는 엔티티 타입의 속성이 많고, 데이터 수정이 빈번하며, 쓰기 작업 위주의 엔티티 타입에는 사용하기 어려움
<ul>
<li>데이터 수정이 빈번한 경우에는 여러 튜플에 대한 작업이 발생하므로 좋지 않음</li>
</ul>
</li>
<li>속성이 많아질 경우 데이터의 불필요한 반복과 중복이 발생</li>
</ul>
</li>
</ul>
</li>
<li>부모 엔티티 타입에 대한 속성 추가
<ul>
<li>예: 요금 납부 업무에서 만약 분할 납부가 최대 2번까지만 가능하다는 규칙이 있는 경우
<ul>
<li>요금(요금번호) -&gt; 요금(요금번호, 납부번호1 FK, 납부번호2 FK)</li>
</ul>
</li>
<li>유의사항
<ul>
<li>해당 업무 규칙의 최대값이 지정되어 있고, 그것이 변경될 가능성이 낮아야 함
<ul>
<li>최대값이 3~4개 이상이거나 지속적으로 변동될 가능성이 크다면 이에 따라 애플리케이션도 변경되어야 하므로 확실한 경우에만 적용해야 함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>엔티티 타입간의 관계는 업무 흐름과 프로토콜에 일치하는가?
<ul>
<li>선택성 관련 이슈
<ul>
<li>한쪽을 필수 관계로 지정하는 이유 = 참조하는 쪽에서 물리 테이블을 생성하면 FK로써 참조하기 때문
<ul>
<li>FK 참조 무결성을 보장하기 위함</li>
</ul>
</li>
<li>양쪽 모두를 선택 관계로 지정하는 경우는 모델의 모호성이 증가되므로 바람직하지는 않음
<ul>
<li>다만 실무의 특수성으로 인해 불가피한 경우가 있음</li>
</ul>
</li>
</ul>
</li>
<li>예: 사원에게 급여를 지급할 건이 발생되면 계산된 급여가 일단 급여 목록에 기록되고, 급여가 확정되면 그 때 전표가 자동 발생하는 업무 흐름
<ul>
<li>전표(전표번호)와 급여(사원번호, 전표번호 FK)는 1(필수):1(필수) 관계일까?
<ul>
<li>NO = 급여 지급건이 발생하더라도 그것이 확정되지 않는다면 전표가 생성되는 것이 아니므로 전표는 선택 참여 관계임</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>업무 흐름에 비추어 봤을때, 도출되지 않거나 못한 관계가 남아있는가?
<ul>
<li>엔티티 타입만 도출하고 관계 정의를 나중에 하려는 경우
<ul>
<li>모델링을 수행하는 사람이 정확하게 인식하고 있는 경우라면 큰 문제는 없음</li>
</ul>
</li>
<li>단위 시스템간의 업무 연계가 정의되지 않은 경우
<ul>
<li>매우 큰 문제가 됨</li>
<li>팀 단위로 이루어지는 프로젝트 개발에서는 단위 시스탬 내부의 연계는 대부분 도출되나 타 시스템과의 연계에는 취약함
<ul>
<li>시스템 통합 관점에서의 전사적 모델링 통합 작업이 필요함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>관계에 대한 표현이 적절한 수준에서 이루어졌는가?
<ul>
<li>엔티티 타입간의 PK들을 보면 마치 모든 엔티티 타입들과 관계를 가지고 있는 것처럼 그물망 형식으로 나타남</li>
<li>코드라던가 통계와 같이, 업무 흐름에 관여하는 모습을 직접 나타내지 않더라도 상식적으로 알 수 있는 엔티티 타입의 관계는 생략함
<ul>
<li>나머지 주요 업무 흐름에 관련된 관계를 정의해서 표현해야 함</li>
</ul>
</li>
<li>PK를 상속받은 엔티티 타입과 조상 엔티티 타입간의 관계 연결
<ul>
<li>예: 사원(사원번호) -&gt; 급여이력(사원번호 FK) -&gt; 수당이력(사원번호 FK)
<ul>
<li>사원과 수당이력 사이의 관계만 표현하여 간소화</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    <div class="mt-20 md:mt-32 lg:mt-32 xl:mt-32"></div>
</article>
        
    </main>
    <footer class="mt-20 px-10 py-8 bg-gray-200">
    <div class="max-w-5xl mx-auto text-gray-700 text-center">
        © 2022 <a href="/" class="font-medium" target="_blank" rel="noopener">devfreedom.github.io</a> by 
        <a href="https://devfreedom.github.io" target="_blank" rel="noopener">devfreedom</a> 
    </div>
</footer>
    <script src="/assets/js/bundle.js"></script>
</body>

</html>