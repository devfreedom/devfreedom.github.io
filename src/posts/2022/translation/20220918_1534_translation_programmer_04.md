---
title: "[번역] 4. 당신이 유능한 프로그래머라는 신호들"
date: 2022-09-18T15:34
thumb: "programmer.jpg"
tags: 
    - ❮번역❯
    - 프로그래밍
    - 컴퓨터공학
---

1. [당신이 프로그래머가 되어서는 안된다는 신호들](https://devfreedom.github.io/20220917_2047_translation_programmer_01)
2. [당신이 형편없는 프로그래머라는 신호들](https://devfreedom.github.io/20220918_1400_translation_programmer_02)
3. [당신이 평범한 프로그래머라는 신호들](https://devfreedom.github.io/20220918_1510_translation_programmer_03)
4. [당신이 유능한 프로그래머라는 신호들](https://devfreedom.github.io/20220918_1534_translation_programmer_04)
5. [당신이 대단한 프로그래머라는 신호들](https://devfreedom.github.io/20220918_1546_translation_programmer_05)

---

## Signs that you're a good programmer
## 당신이 유능한 프로그래머라는 신호들

The most frequently viewed page on this site is Signs you're a bad programmer, which has also now been published on dead trees by Hacker Monthly, and I think that behoves me to write its antithesis. "Bad programmer" is also considered inflammatory by some who think I'm speaking down to them. Not so; it was personal catharsis from an author who exhibited many of those problems himself. And what I think made the article popular was the "remedies"--I didn't want someone to get depressed when they recognized themselves, I wanted to be constructive.

제 웹사이트에서 사람들이 가장 많이 본 페이지는 '당신이 좋지 못한 프로그래머라는 신호들'이었습니다. 인쇄판 잡지 Hacker Monthly에 실려 출판되기도 했는데, 그래서 이제는 정반대의 시각을 적어볼 필요가 있겠다는 생각이 듭니다. '좋지 못한 프로그래머'라는 표현은 제가 그들을 깔보고 있다고 생각하는 사람들이 문제를 삼고 있는 것 같은데, 아닙니다. '좋지 못한 프로그래머'가 보여주는 여러 문제들을 가졌던 당사자가 바로 제 자신이었고 그걸 제 스스로 성찰하면서 쓴 글입니다. 그리고 제 글이 인기가 있었던 이유는 바로 제가 치료법, 즉 해결책을 제시했기 때문이라고 생각합니다. 저는 그저 건설적이고 싶었을 뿐, 누군가가 자신의 문제점을 깨닫고 우울해지기를 원하지는 않았습니다.

Therefore if you think you're missing any of the qualities below, don't be offended. I didn't pick these up for a while, either, and many of them came from watching other programmers or reading their code.

그러므로 만약 당신이 아래의 특징들을 가지고 있지 않다고해서 마음 상하지는 마세요. 저 역시 이러한 특징들을 한동안 터득할 수 없었습니다. 그리고 여러 특징들은 다른 프로그래머들을 보고 배우거나 그들의 코드를 읽어보면서 얻은 것들이죠.


### 1. The instinct to experiment first (먼저 실험해보고자 하는 본능)

The compiler and runtime can often answer a question faster than a human can. Rather than seek out a senior programmer and ask them "will it work if I do this?", a good programmer will just try it and see if it works before bringing their problem to someone else.

컴파일러와 런타임은 종종 인간의 능력보다 더 빠르게 정답을 제공하고는 합니다. 시니어급 프로그래머를 찾아가 "이렇게 하면 제대로 작동할까요?"라고 묻는 대신, 바람직한 프로그래머는 자신이 마주한 문제를 다른 사람에게 가져가기 전에 일단은 먼저 방법을 시도해보고 그것이 될지 안될지를 확인할 겁니다.

**Symptoms 증상**

- Side projects
    - 사이드 프로젝트
- Dabbling in other programming languages, especially ones from a different "family" (procedural, stack-based, concurrent, etc.)
    - 익숙하지 않은 다른 프로그래밍 언어들을 다뤄보기, 특히 절차형, 스택 기반, 동시성 프로그래밍 등 다른 '언어군'을 시도해보기
- Knows what you're talking about when you mention "Arduino"
    - "아두이노"같은 말을 언급할 때 그게 무엇인지 본인이 잘 알고 있음
- Old, uncommitted code that duplicates other code's functionality but isn't referenced elsewhere in the project
    - 프로젝트의 다른 곳에서 참조되지는 않았지만 다른 코드의 기능을 똑같이 수행하는, 커밋되지 않은 오래된 코드
- A tendency to suggest wacky and unrealistic solutions in meetings
    - 회의에서 비현실적이고 괴상한 해결책을 제안하려는 경향 
- A cubicle or desk populated with toys that came from ThinkGeek
    - 전자제품 전문점에서 구입한 장난감으로 가득한 사무실 및 책상

**How to acquire this trait 터득하는 방법**

Are you excessively cautious? Are you only comfortable when you have permission? Has anyone ever said that you were passive aggressive? You might consider inviting some friends to visit the local Six Flags or some other roller-coaster park. If you want baptism by fire, then make your first ride the scariest (for me, it was the "Drop Zone" at King's Dominion, with some reinforcement a few years later on the Kingda Ka at Six Flags). If you consider yourself ready to get off the kiddie rides you might try your hand at hang gliding and windsurfing, which have the benefit of teaching you what you can and cannot control.

당신은 과도하게 조심스러운 사람입니까? 허락이 주어졌을 때만 편안하신가요? 누군가가 당신에게 수동적 공격 성향이 있는 것 같다고 말한 적이 있나요? 그럼 친구들을 몇 명 초대해서 롤러코스터가 있는 놀이공원에 가보는 것을 고려해보세요. 만약 당신이 물이 아닌 불로 세례를 받고 싶다면 첫번째 놀이기구는 가장 무서운 것으로 고르시죠. 아동용 놀이기구에서 내릴 준비가 되었다면 행글라이딩이나 윈드서핑같은 활동을 체험해보세요. 당신이 무엇을 통제할 수 있고 무엇을 통제할 수 없는지를 가르쳐주는 장점이 있습니다.

Much of what makes people timid to experiment is chemical--your brain has a small number of adrenergic receptors, so a little bit of adrenaline excites your fight-or-flight reflexes too much. But consider why people grow tolerant to coffee: the caffeine's byproducts force their brain to grow more adenosine receptors. So if you force your brain to grow more adrenaline receptors then the same amount of "fear juice" will trigger a lower percentage of them. Find some experience that scares the shit out of you, do it a few times, and you will lose your fear of venture on a physical level.

사람들을 실험에 소극적으로 만드는 것은 바로 화학작용입니다. 당신의 뇌는 소수의 아드레날린 수용체를 가지고 있습니다. 약간의 아드레날린은 당신의 투쟁-도피 반응을 너무 많이 자극하게 되죠. 하지만 사람들이 커피에 내성이 생기는 과정을 생각해보세요. 카페인의 부산물은 뇌로 하여금 더 많은 아데노신 수용체를 자라게 합니다. 그러므로 만약 뇌가 아드레날린 수용체를 더 많이 만들도록 당신이 강요하게 되면, 동일한 수준의 공포감은 전체에 비해 더 적은 수의 수용체를 자극할겁니다. 당신을 어마어마하게 겁에 질리게 하는 경험을 시도해보세요. 여러 번 하다보면 모험을 두려워하는 공포를 신체적인 차원에서 극복하게 될 겁니다.

Note: A programmer who "suggests wacky and unrealistic solutions" is not always a bad programmer. It can be a sign of creative thinking from someone who assumes confirmation or correction will come from somewhere else down the line. 

참고로 "회의에서 비현실적이고 괴상한 해결책을 제안하려는 경향"을 가진 프로그래머는 나쁜 프로그래머가 아닐 수 있습니다. 그건 업무 과정에서 어차피 확인이나 교정이 이루어질거라고 추정하는 사람이 하는 창의적인 사고의 조짐일 수 있습니다.


### 2. Emotional detachment from code and design (코드와 설계로부터의 감정적 분리)

Code is like kleenex: you use it when it's useful and throw it away when it no longer serves. We all like to think that code-reuse is important, and while it is, it's not meant to be about raising a child. Code doesn't feel. Code doesn't care. Code will turn on you like a Frankenstein monster. Code is just bytes. Code is a liability.

코드는 마치 크리넥스 티슈와 같습니다. 필요할 때 쓰고 필요가 없어지면 버리십시오. 우리는 코드 재사용을 중요하다고 생각하고 싶어하지만, 뭐 일부 맞는 말이긴 합니다만, 마치 아이를 키우는 것처럼 하라는 의미는 아닙니다. 코드에겐 감정따윈 없습니다. 코드는 신경쓰지 않아요. 코드는 마치 전기 신호를 주면 움직이는 프랑켄슈타인 괴물과도 같습니다. 코드는 그저 바이트 묶음일 뿐입니다. 코드는 책무입니다.

**Symptoms 증상**

- Almost no committed code that is commented out
    - 주석 처리를 시킨 코드가 거의 없음
- Willingly throws away weeks or months of work in order to adopt another programmer's superior code
    - 다른 프로그래머의 우월한 코드를 채택하기 위해서라면 몇 주 몇 달 동안 작성했던 코드마저 갖다 버릴줄 앎
- Puts finger to lips, furrows brow and says "hmm" when faults in their work are pointed out, while looking at the code and not the critic
    - 자신의 작업물이 지적을 받을 때, 그 상대방이 아닌 코드를 쳐다보면서 입술에 손가락을 갖다대고 눈썹을 치켜올려 "흠..." 이라고 함
- Indifferent to the way the IDE wants to auto-format code, uninterested in "tabs-vs-spaces" arguments
    - '탭 vs 빈칸' 논쟁 따위에 관심이 없고 IDE가 수행하는 코드 자동 포맷팅 방식에 무관심함
- Refers to it as "the code" rather than "my code", unless accepting blame
    - 오류에 대한 자신의 책임을 받아들일 때를 제외하고는 코드를 "내 코드"가 아닌 그저 "코드"로 부름
- Has abandoned a design of theirs that was previously used in a successful product
    - 과거에 성공적인 제품에 사용되었던 설계를 버릴 줄 앎줄
- Doesn't become defensive when the boss mentions that they're looking for an off-the-shelf alternative to what they've been writing for the past few years
    - 지난 몇 년간 작성해온 코드 대신 기성 솔루션이나 소프트웨어를 사용하자고 상사가 언급하더라도 방어적인 태도를 보이지 않음


**How to acquire this trait 터득하는 방법**

Konrad Lorenz, the author of On Aggression, suggested that a scientist should begin each day by throwing out one of his pet theories in order to remain sharp. Consider throwing out one of your pet algorithms or design patterns or exquisite one-line Sodoku solvers every morning to remind yourself that it's you who controls the idea, not the idea that controls you.

과학 서적 <공격성에 관하여>의 저자인 동물학자 콘라트 로렌츠(Konrad Lorenz)는 과학자들이 학문적 감각을 날카롭게 유지하기 위해서는 자신만의 지론을 매일 아침마다 하나씩 버려야 한다고 주장했습니다. 발상이 당신을 통제하는 것이 아니라 바로 당신이 발상을 통제한다는 것을 매일 아침 스스로에게 상기시키기 위해서, 당신이 아끼는 알고리즘이나 설계 패턴, 한줄 코드로 짜여진 기발한 스도쿠 계산기 등을 갖다 버리십시오.

Find the code that you're the most proud of and delete it, now re-write it from scratch in a different way. Use a "design pattern" that confuses you, or that you hate (e.g.: the Singleton) and figure out how to make it work. If necessary, delete that after you've got it working and try again with a new pattern or language. Not only will you learn that there's More Than One Way To Do It, but you'll learn that your code is transitory. Code, by its nature, is not just inextricably glued to its language, platform, and the APIs it consumes, but written in the form of ephemeral static charges, orientations of magnetic particles, subject to the whims of the market, Moore's Law, and your employer.

당신이 가장 자부심을 느끼는 코드를 찾아 그것을 지워버리십시오. 그리고 나서 그것을 다른 방식으로 처음부터 다시 작성하세요. 당신을 혼란스럽게, 또는 (싱글턴과 같이) 열받게 만드는 '설계 패턴'을 사용하고 그것이 작동하게끔 하세요. 만약 필요하다면 그것을 해내고 난 다음에 지워버리고 새로운 설계 패턴이나 언어로 다시 시도해보세요. 어떤 것을 할 때 한 가지 방법만 있는게 아니라는 사실을 배울 뿐만 아니라, 당신의 코드가 전환될 수 있다는 것 또한 배울 것입니다. 코드라는 것은 그 성격상 특정 언어나 플랫폼이나 API에 완전히 접착되어 있지 않습니다. 코드라는 것은 순간적인 정전기, 자성을 띄는 입자의 움직임과도 같은 형태로 유연하게 작성되며, 업계의 트렌드, 무어의 법칙, 그리고 회사 사장의 변덕에 따라 달라지기도 합니다.

Other techniques to break the abusive relationship:

코드와의 건강하지 못한 연인관계를 깨뜨리기 위한 다른 방법들:

- Maintain somebody else's code
    - 다른 사람의 코드를 유지보수하기
- Experience, either by accident or bloody intention, what it's like to lose a week's work to a failed backup or a botched commit and have to re-write it all over again
    - 의도적으로든 아니면 예기치 못한 사고로든, 백업 실패 또는 잘못된 코드 커밋으로 인해 1주일 동안 노력해서 작성한 코드가 사라저벼리고 처음부터 다시 작성해야 하는 일을 경험해보기
- Work for start-ups where you'll get laid-off when the second or third round of financing doesn't come through
    - 2차 또는 3차 투자를 받지 못하면 직원들을 해고할 수 밖에 없는 스타트업에서 일하기
- Be stupid enough to post your best code on Reddit
    - 레딧에 당신이 가장 잘 만든 코드를 올릴 정도로 멍청하기
- Read the bit about "Destructive pursuit of perfection" further down in this article
    - 다음 글에 있는 '완벽을 파괴적으로 추구함' 문단을 읽어보기


### 3. Eager to fix what isn't broken (고장나지 않은 것을 고치려는 열성)

Programs are infrastructure: they're built to serve a specific need, but needs always change. Good programmers realize that hard-coded values buried in code are bad, that a destoryBaghdad() function is immoral, and that it's a priority to eliminate "code smells". Not for pride. Not for backslapping attaboys from your peers or the authors of methodology books. But because you will itch until it is fixed.

프로그램은 인프라스트럭쳐입니다. 프로그램은 특정한 요구를 충족하기 위해 설계되지만 그 '요구'라는 것은 항상 바뀝니다. 바람직한 프로그래머는 코드 속에 매몰된 하드코드된 값들은 좋지 않다는 것을 알고, '바그다드파괴하기()'라는 함수가 비도덕적이라는 것을 알며, '코드 냄새'들을 없애는 것이 우선순위라는 것을 압니다. 자존심 때문이 아닙니다. 실력이 뛰어난 동료들이나 프로그래밍 방법론 서적들의 저자들을 칭찬하기 위함이 아닙니다. 그저 당신은 그것을 고치기 전까지 견디지 못하기 때문입니다.

**Symptoms 증상**

- Doesn't take the spec by its word and tries to find out who wrote it and what they were thinking
    - 코드 명세서를 그대로 믿지 않고, 코드를 누가 작성했고 어떤 생각으로 작성했는지를 알아보고자 함
- Hunts down and talks to the people who will use the program each day
    - 작성하고 있는 프로그램을 매일 사용하게 될 사람들을 찾아나서고 그들과 대화함
- Owns a book written by a guy called Martin Fowler
    - 마틴 포울러(Martin Fowler)라는 사람이 쓴 책을 가지고 있음
        - *객체지향 분석 및 설계로 유명한 소프트웨어 엔지니어 입니다*
- Tends to express extreme like or dislike for popular technologies such as XML, ORM and REST, and has also switched positions on one or more of these in the past
    - XML, ORM, REST와 같은 인기있는 기술들을 아주 좋아하거나 아니면 아주 혐오하는 경향을 가지고 있으며, 그 경향을 과거에 바꾼 적이 있음
- Likes to use abstraction layers, but doesn't like to add more than one layer on top of what's already in the language or platform
    - 추상화 계층을 사용하기를 좋아하지만, 언어나 플랫폼에 이미 있는 계층 위에 하나 이상을 과도하게 추가하는 것은 좋아하지 않음 
- Talks about "low cohesion"
    - '낮은 응집도'에 대해서 이야기함
- At least 10% or more of their commits reduce the line-count of the project without adding new functionality
    - 전체 커밋의 10% 이상은 새로운 기능을 추가하지 않고 프로젝트의 라인카운트를 줄이는 것에 관한 것임
- Before adding a new feature, checks to see if an existing one can be re-designed to perform both tasks or replaced entirely with a better method
    - 새로운 기능을 추가하기 전에, 재설계를 통해 기존의 기능이 새로운 기능을 함께 수행할 수 있는지, 아니면 더 좋은 방식으로 완전히 교체될 수 있는지를 먼저 알아보기

**How to acquire this trait 터득하는 방법**

The first attempt to solve a program in code will always bear the artifacts of discovery: discovering the true nature of the problem, discovering the features of the platform, and discovering the best way to solve it. The second attempt will be more stable, but might inherit too much cautionary baggage and become a nightmare to extend. And so many programs today are like the Firth of Forth Bridge: disgustingly over-engineered. Sometimes it's the developer's first crack at the problem and looks like a lawn mowed by a dog, sometimes it's their second attempt and looks like the dog installed grass-cutting laser turrets every 2 feet. It can take a third try before the designer understands the problem completely and knows how much, or how little they need to do.

프로그램을 코드로써 해결하기 위한 첫번째 시도는 발견의 결과물을 가져옵니다. 그 문제의 생리를 발견하고, 플랫폼의 기능을 발견하고, 최적의 해법을 발견하는 것 말입니다. 두번째 시도는 그보다는 안정적일 것이지만 지나친 신중함에서 오는 부담을 동반하게 되어 더 이상 나아가기 어려울지 모릅니다. 요즘의 수많은 프로그램들은 포스 만에 있는 대교(Firth of Forth bridge)와 같습니다. 너무나 과도하게 엔지니어링되어 있습니다. 때로 그것은 문제를 해결하기 위한 개발자의 첫 일격이고 그건 마치 강아지가 깎은 잔디밭처럼 보입니다. 어떨때는 그것은 개발자의 두번째 시도고 그건 강아지가 잔디깎이용 레이저 포를 2피트마다 설치한 것 같이 보이기도 하죠. 설계자가 문제를 온전하게 파악하고 그것을 해결하기 위해 어떤 조치를 취하면 되는지를 알기 전까지 세번째 시도가 필요할지도 모릅니다.

> '포스 만 대교'란 스코틀랜드에 있는 교량으로써 1890년에 세계에서 가장 긴 철제 철교로 지어진 것으로 유명합니다.

Code lets you learn in stages where you don't need to re-write everything from scratch. You re-write pieces after you understand what they need to do and what they'll never need to do, make them simpler, shorter and beautiful.

모든 것을 처음부터 다시 작성할 필요가 없다는 것을 알기까지 코드는 당신을 단계적으로 가르칩니다. 당신은 어떤 방법을 취해야 할지 혹은 취하지 말아야 할지를 먼저 이해하고 나서 당신의 작업물을 다시 작성해야 합니다. 더욱 간단하고, 짧고, 미려하게 말이죠.

Go through your home and repair all the annoying things you've been putting off; fix the crooked picture on the wall, unclog the slow draining sink, repair that gutter drainpipe so your basement doesn't flood, buy a UPS and backup drive for your computer and configure them to shut-down/back-up automatically, replace all the incandescents with efficient bulbs, replace that ethernet cable draped down the hallway with WiFi or some proper wall-jacks and conduit, get a real food-dish for your cat instead of that old cheese-dip container.

당신의 집을 훑어보고 지금까지 미뤄왔던 짜증나는 일들을 해치우세요. 벽에 걸린 삐뚤어진 그림을 고치고, 막힌 싱크대를 뚫고, 배수구를 정비해서 지하실이 물에 잠기지 않도록 하고, 비상용 전원 공급장치(UPS)와 백업용 저장소를 구매해 당신의 컴퓨터가 자동으로 마무리하고 백업을 하도록 세팅하고, 구식 백열 전구를 효율이 좋은 전구들로 바꾸고, 복도까지 널브러진 유선 이더넷 케이블을 적절하게 선 정리 하거나 아니면 와이파이로 대체하고, 고양이 밥그릇으로 사용하던 낡은 양념그릇을 버리고 제대로 된 밥그릇을 사주세요.

Next you should go to your last project and read through the code. Think about what each piece does. There's a loop here, some sorting there, a bit of number crunching, screen updates, HTML generation, database CRUD, that sort of thing.

다음으로 당신이 최근에 하던 프로젝트를 열어 코드를 주욱 읽어보세요. 각 부분이 어떤 것들을 수행하는지를 생각해보세요. 여기에 반복문이 있고, 정렬 알고리즘이 있고, 계산 기능이 있고, 화면 갱신, HTML 생성, 데이터베이스 CRUD 등등 그런 것들 말이죠.

Now replace the hard-coded HTML with a templating system, get the database CRUD out of your business objects and re-write it to use proper parameterized queries instead of string concatenation, replace all the "writelns" and "MessageBoxes" in your error handlers with a logging framework, refactor code that's trying to borrow methods from other classes, use locale-aware string formatting, stop guessing how big an array should be and use a dynamic collection, delete orphaned code.

이제 하드코딩된 HTML을 템플릿 시스템으로 대체하고, 비즈니스 객체로부터 데이터베이스 CRUD를 떼어내서 스트링 컨캣 대신 적절히 매개변수화된 쿼리를 사용하도록 다시 작성하세요. 에러 핸들러에서의 writelns와 MessageBoxes같은 것들을 로깅 프레임워크로 대체하세요. 다른 클래스로부터 메소드를 빌리려고 하는 코드를 리팩터링하고, 로케일을 고려해 문자열을 포매팅하고, 배열이 얼마나 커야 할지를 고민하는 대신 동적 콜렉션을 사용하세요. 길을 잃은(orphaned) 코드를 지워버리세요.

Aim for these, in increasing order of importance:

다음 사항들을 추구하세요. 중요도는 오름차순입니다. 

1. Code that does the same thing, but is shorter or more efficient
    - 똑같은 역할을 수행하지만, 더 짧고 효율적인 코드
2. Code that does the same thing, but uses an appropriate "wheel" built-into the platform instead of reinventing its own
    - 똑같은 역할을 수행하지만, 자체적으로 설계한 기능을 사용하는 대신 플랫폼에 내장된 기능들을 사용하는 코드
3. Code that does the same thing, but is easier to modify for similar needs
    - 똑같은 역할을 수행하지만, 비슷한 요구사항을 충족하기 위해 변경하기 보다 쉬운 코드
4. Code that does the same thing, but is easier to read and understand
    - 똑같은 역할을 수행하지만, 읽고 이해하기 더욱 쉬운 코드
5. Code that doesn't exist
    - 존재하지 않는 코드

Hit #5 and you can call yourself a Zen Apprentice. Do it for a decade until you do it instinctively and you can call yourself a Zen Master.

5번에 다다르면 당신은 깨달음의 길에 오른 견습생이 됩니다. 이것들을 본능적으로 해낼 수 있을 정도로 10년간 노력하면 당신은 경지에 다다른 스승이 되는거죠.


### 4. Fascinated by the incomprehensible (이해할 수 없는 것들에 매료됨)

I am only just beginning to understand what a Fourier Transform does, but I've been studying them because I have the damn persistent feeling that I could be using them somehow. I don't know what I would use them for yet, but maybe I will someday. What I do know is that what I don't know will cost me in useless labor. 

저는 푸리에 변환이 무엇인지 이제 막 이해하기 시작하는 정도지만, 언젠가는 이걸 어떻게든 써먹을 수 있을거라는 확실한 느낌이 꾸준히 들어서 그동안 공부해 왔습니다. 푸리에 변환을 어디에 사용할지 아직도 모르지만 언젠가는 써먹을 겁니다. 저는 무언가를 모른다는 것은 나중에 그걸 메꾸기 위해서 시간과 노력이 소모될 것이라는 것 쯤은 압니다. 

**Symptoms 증상**

- Visits Lambda The Ultimate on a regular basis
    - 프로그래밍 블로그인 'Lambda The Ultimate' 을 자주 방문함
- Knows what ATP synthase is. Has extracted DNA from a banana in their kitchen
    - ATP 신타아제가 무엇인지를 알고 있고, 주방에서 바나나로부터 DNA를 추출해본 적이 있음
- Owns a book with a dragon on the cover, especially if they don't write compilers
    - 컴파일러를 작성하는 사람도 아니면서 용이 표지에 그려진 책을 소유하고 있음
        - *컴파일러의 설계에 관한 'Compilers: Principles, Techniques, and Tools' 라는 서적의 표지에 용이 그러져 있습니다.*
- Giggles when someone says the phrase "This is recorded on sticky-tape and rust"
    - 누군가가 "이것은 접착 테이프와 녹 가루를 사용해 녹음이 되어 있습니다"라는 말을 할 때 웃을 줄 앎
        - *'The Secret Life of Machines' 이라는 90년대 영국 TV 쇼에서 나온 멘트라고 합니다...*
- Shoves through a crowd at a party to get near someone who just used the word "Bayesian"
    - 사람들이 붐비는 파티에서 누군가가 '베이지안(Bayesian)' 이라는 단어를 말하는 것을 듣고는 군중을 헤치고 그 사람이 누구인지 찾으러 감
        - *수학자 '토마스 베이즈(Thomas Bayes)'와 그의 이론에 관해 알고 또 관심을 가질 줄 아는 사람이라는 의미입니다*
- Buys drinks for people who work in other industries and seem willing to talk shop when drunk
    - 다른 업계에서 일하는 사람들을 위해서 술을 사주고 그들이 취했을 때 말동무가 되어주고자 함
- Has a habit of boring people to tears explaining something tangentially related to the news, such as the cockpit layout of the Airbus 330
    - 세상 돌아가는 일에 관련된 것들을 설명하느라 사람들을 지루하게 만드는 습관이 있음. 예를 들면 에어버스 330의 조종석 구조라던가...
- Has foreign-language versions of popular songs on their iPod
    - 인기 있는 노래들의 외국어 버전을 들음
- Envies but doesn't resent people with degrees in something they don't know
    - 알지 못하는 분야에 학위가 있는 사람들을 부러워하면서도 원망하지 않음

**How to acquire this trait 터득하는 방법**

This tends to start in childhood but can be cultivated in adulthood if you can commit to exploring your horizons. Friends are a major gateway: seek social occasions where you'll bump into people you don't know under circumstances where they'll be unhurried and at ease. This may involve alcohol. Don't try to impress them, don't compete with them, but display your ignorance willingly to see if they lean forward to correct and enlighten you. Then shut your fool trap and listen.

이런 경향은 주로 유소년기에 시작되지만, 시야를 넓히고 모험하는 데에 확고하게 전념한다면 성인이 되어서도 기를 수 있습니다. 친구들이 바로 주요한 관문이 될 수 있겠네요. 당신을 모르는 사람들을 편안하고 느긋한 환경에서 마주칠 수 있는 사교적 여건을 만들어보세요. 술을 마시기도 할 겁니다. 그들에게 강한 인상을 남기려고 노력하지 마세요. 그들과 경쟁하지도 마세요. 그들이 당신을 정정해주고 당신이 깨닫게 해줄 수 있는지를 알아보기 위해 일부러 모르는 척을 해보세요. 그리고 나서 "바보 함정"을 닫아버리고 경청하세요. 

When you hear or read something you don't recognize then Google it or hit Wikipedia. For a programmer an equally superior resource is Ward Cunningham's Wiki, which deserves weeks of your life.

만약 당신이 모르는 어떤 것에 대해서 듣거나 읽는다면 위키피디아나 구글에 검색해보세요. 프로그래머들에게 있어서 저것들과 비슷하게 뛰어난 참고자료로는 워드 커닝험(Ward Cunningham)의 위키 웹사이트가 있습니다. 당신의 소중한 시간을 많이 절약해 줄 것입니다.

Computer programming has annexed all of the sciences and the feedback loop is so wide it stuns gods. From biology we took Genetic Algorithms. From climatology we took chaos theory. Biologists now use our work to fold proteins. Climatologists now use our simulations to predict armageddon. Everything informs us, and we inform everything. Either probe the unfathomable or retire on a "blub" programmer's salary. 

컴퓨터 프로그래밍은 모든 종류의 과학을 흡수해버린 나머지 그 피드백 순환은 너무 넓어서 신 조차도 어질어질하게 만들 정도입니다. 생물학으로부터는 '유전적 알고리즘'을 가져왔죠. 기상학에서는 '카오스 이론'을 가져왔습니다. 생물학자들은 이제 단백질 접힘을 구현하기 위해 오히려 컴퓨터공학의 산몰을 활용합니다. 기상학자들은 컴퓨터공학적 시뮬레이션을 사용해 기후 재앙을 예측하죠. 모든 것들이 우리에게 정보를 가져다주고 우리는 모든 정보를 알려줍니다. 세기적 미스테리를 탐구하거나, 아니면 그저 일개 프로그래머의 연봉을 받으며 은퇴하는 것, 둘 중 하나죠.


### 5. Compelled to teach (가르쳐주지 못해서 안달남)

I once knew someone who thought it was good advice to "never teach everything you know" because they once lost a job after bringing a co-worker up to speed with all their skills. I stared at them with genuine incomprehension. A good manager would never get rid of someone who's not only capable of all their tasks but also demonstrates ability to train new workers. It would be like shooting the goose that lays golden eggs. If you get fired, it's probably for some other reason.

저는 "당신이 아는 것 전부를 남들에게 가르쳐주지는 마라"라는 것이 좋은 조언이라고 생각했던 사람을 알고 있습니다. 왜냐면 그 사람은 동료에게 모든 기술을 전수해준 나머지 직장을 잃게 되었거든요. 저는 그런 사람들이 진정으로 이해가 되지 않았습니다. 진정으로 좋은 관리자는, 업무를 잘 수행할 뿐만 아니라 새로운 직원을 훈련시킬 줄 아는 능력을 보여주는 직원을 절대로 쫓아내지 않을 것입니다. 그건 마치 황금알을 낳는 거위에게 총을 쏘는 것과 같다고 할 수 있겠네요. 만약 당신이 해고된다면 거기에는 다른 이유가 있을 것입니다.

**Symptoms 증상**

- Blogs about their work
    - 자신이 하는 프로그래밍에 관한 블로그를 운영함
- Has an active Wikipedia account않
    - 활발하게 사용하는 위키피디아 계정이 있음
- Unhesitant to pick up a marker and approach a whiteboard
    - 마커펜을 들고 화이트보드로 가기를 주저하지 않음
- Commits changes to the repository that consist only of comments
    - 커멘트만으로 가득한 저장소에 코드 변경사항을 커밋함
- Lets new hires borrow books that cost them $100 to buy
    - 가격이 100달러씩이나 하는 책을 신참들이 빌려가도록 허락해줌
- Pauses "The Andromeda Strain" at the part about the sliver of paper getting between the bell and the ringer and grins like a madman
    - 영화 '안드로메다 스트레인' 에서 경보용 종과 그 종을 치는 방망이 사이에 종이를 끼워 경보기가 소리를 내는 것을 막아내는 부분에서 일시정지를 하고는 광인처럼 미소를 지음
        - *어떤 문제에 대한 기발한 해결책을 찾아내는 방법, 즉 프로그래머에게 필수적인 문제 해결력에 대한 애착을 보여주는 사람들을 향한 이 필자의 오마주로 추정됩니다*

**How to acquire this trait 터득하는 방법**

I can only do this when I'm inspired or "in the mood", and I think that this mood is a product of circumstance, one that's made up of confidence, space, opportunity and provocation. When you're in school your teacher has the space and opportunity already supplied for them and their confidence is hopefully given by their training, but the inspiration is tricky; it's the difference between a good lesson that both the teacher and the student enjoys and a laborious exercise in rote memorization.

저는 영감을 받거나 기분이 딱 맞을 때에만 이런 것들을 할 수 있고, 그래서 저는 이런 순간이 자신감, 공간, 기회, 그리고 도발로써 형성된 특정한 환경의 산물이라고 생각합니다. 학창시절에는 선생님에게 공간과 기회가 이미 있고 자신감 역시 훈련을 통해 그들에게 주어졌겠지만, 영감은 다릅니다. 그것은 학생과 선생님 모두가 즐길 수 있는 바람직한 수업과, 수고스러운 단순 암기 연습의 차이입니다.

Novices in computer programming aren't usually novices in general, because they have lives and friends and family and hobbies and interests that have been going on for even longer. Maybe you do need to bore someone to tears by explaining something that's cool to you, even if it has nothing to do with programming. Maybe you have a younger sibling you can teach the guitar, or your favorite recipe, or how to balance on a pogo stick. Maybe you have a coworker who doesn't know how to ski. It doesn't matter the subject, just that you get a taste of what it's like to program someone else's brain in a positive way.

컴퓨터 프로그래밍의 초보자는 주로 일반적으로는 초보가 아닙니다. 왜냐하면 그들에게는 프로그래밍보다 더 오래 해온 일과가 있고 친구와 가족이 있으며 취미와 관심사가 있기 때문입니다. 프로그래밍과 아무런 관련이 없더라도 당신은 남들이 지루해할 때까지 본인의 어떠한 관심사에 관해서 설명을 해야 할지도 모릅니다. 어쩌면 기타를 가르쳐 주거나 당신이 가장 좋아하는 요리법을 아려 주거나 스카이콩콩을 탈 때 균형을 어떻게 잡는지를 알려줄 수 있는 동생이 당신에게 있을지도 모릅니다. 어쩌면 스키를 탈 줄 모르는 동료가 당신에게 있을수도 있구요. 주제는 중요하지 않습니다. 다른 사람의 두뇌를 긍정적인 방향으로 프로그래밍하는 것이 어떤 것인지를 체험해볼 필요가 있습니다. 

If you've never taught anything before you will discover, to an embarrassing degree, just how many times you can say "um" and "er" per minute, how badly you're prepared, and how easily you can forget that the student doesn't know details you haven't explained yet.

만약 당신이 지금까지 무언가를 남들에게 가르쳐본 적이 전혀 없다면, 당신이 1분에 얼마나 자주 "음..." 이나 "어..." 와 같은 말을 하는지, 당신이 얼마나 준비가 안되어 있는지, 당신이 아직 설명하지 않은 내용을 그 학생은 모른다는 사실을 얼마나 쉽게 잊어버리는지를 부끄러울 정도로 깨닫게 될 것입니다.

One of the tricks that worked for me was to volunteer for an opportunity to teach a complex subject (microbiology) to laymen. The first time I tried it I used a Post-It easel and a bunch of markers and tried to draw everything. I was all over the place. It was humiliating. But the audience, fortunately, was friendly.

저에게 통한 방법 중 하나는 바로 복잡한 주제(생물학)에 대해서 일반인에게 가르치는 기회를 자원한 것입니다. 첫 수업에서 저는 포스트잇 메모들을 칠판 테두리에 붙여두고 수많은 마커펜들을 사용해서 모든 것들을 그리고자 했습니다. 저는 여기저기 허둥댔죠. 민망했습니다. 하지만 수업을 듣는 청중은 다행히도 친절했습니다.

The next year I tried again, but this time I had an iPad and used Keynote to put together a presentation, which was a lot of fun in itself, but this time the lesson went overwhelmingly more smoothly. I used lots of pictures, very little text, almost no bullet points, a handful of jokes, and just relied on my memory to talk about slides I had designed to provoke my memory more than illustrate anything to the audience.

그 다음 년도에 수업을 다시 진행했을 때, 이번에는 아이패드와 키노트 앱을 사용해 프리젠테이션을 정리했습니다. 그 자체로도 재미있는 일이었지만, 강의는 훨씬 더 부드럽게 진행되었습니다. 저는 그림을 많이 사용했고, 글자는 아주 조금만 사용했고, 약간의 농담들을 더하고, 요점 정리 목록은 거의 사용하지 않았습니다. 저는 그저 제 기억력에 의존했는데, 설명할 슬라이드들은 그 자체로 청중들에게 정보를 주기보다는 제가 기억한 내용을 상기시켜 제가 직접 설명하는 방식으로 준비해 두었습니다.

The experience of doing an awful job the first time informed my next attempt, and now that I've done it three or four more times I find I'm getting slightly better. Not only that, I now know ten times more about the subject because I studied like crazy to help temper my fear of being asked a difficult question. Teaching teaches the teacher.

처음으로 무언가를 할 때 형편없이 끝난 경험은 그 다음 시도에 영향을 미쳤고, 그것을 세번 네번 하다 보니 제 실력이 서서히 나아지고 있음을 깨달았습니다. 뿐만 아니라 저는 이제 그 주제에 대해서 열 배는 더 잘 알게 됐는데, 어려운 질문을 받을 상황에 대한 공포를 누그러뜨리기 위해서 미친듯이 공부를 했기 때문입니다. 가르치는 행위야말로 선생님을 가르친다고 할 수 있습니다.

---

