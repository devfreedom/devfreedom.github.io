---
title: "[필기] 컴퓨터공학과 <데이터베이스> 과목 - 전반부"
date: 2023-07-31T18:45
thumb: "database.jpg"
tags: 
    - ❮필기❯
    - 컴퓨터공학
    - 데이터베이스
    - DBMS
    - RDBMS
    - SQL
---

# 1. 데이터베이스의 개념

## 1-1. 데이터와 데이터베이스

### 데이터와 정보
- 데이터는 관측/수집된 사실을 특정 기준으로 정리한 값입니다.
    - 예: 연간 강수일 174일
- 정보는 이 데이터를 의사결정과 같은 특정 목적을 위해 해석하거나 가공한 형태입니다.
    - 예: 강수 확률 평균 39%

### 데이터베이스란?
- 어떠한 조직의 여러 프로그램들이 공동으로 사용하는 데이터들을 통합해서 저장한 운영 데이터의 집합입니다.
- 데이터베이스에 저장되는 데이터들은 다음의 특성을 충족합니다.
    - 공용 데이터 
        - 여러 부서가 유사한 집합의 데이터를 사용합니다.
        - 예: 학생 관련 데이터를 교무과, 학적과, 학생과에서 사용
    - 통합된 데이터
        - 데이터들을 하나의 원천(single source of truth)으로 모아 사용합니다.
        - 중복성을 통제 하에 제거/최소화하고 일관성 유지가 가능합니다.
    - 저장 매체에 저장된 데이터
    - 운영에 필수적인 데이터

### 데이터베이스의 특징
- 실시간 접근성
    - 쿼리를 실시간으로 처리하고 응답할 수 있습니다.
- 계속적인 변화
    - 시간의 흐름에 따라 데이터베이스의 상태가 지속적으로 동적으로 변동됩니다.
    - 현실 세계의 변화를 반영하고 그것을 표현하기 때문입니다.
- 동시 공용
    - 다른 목적을 지닌 조직들과 프로그램들이 동일한 데이터베이스를 공용으로 사용합니다.
    - 같은 내용을 여러 사용자가 동시에 공유할 수 있습니다.
- 내용에 의한 참조
    - 데이터베이스의 내용은 데이터가 저장된 위치가 아닌 '데이터의 내용'을 기준으로 검색됩니다.
        - 프로그래밍 언어: 위치에 의한 참조 (예: 0xFFF26BCF 또는 `const ref = "data"`)
        - 데이터베이스 언어: `SELECT name FROM student WHERE student_id = 237`

### 파일 시스템과 데이터베이스의 비교
- 파일 시스템의 문제
    - 데이터 고립 문제
        - 파일마다 형식과 위치가 제각각 달라서, 데이터가 사용되지 못하고 방치되는 일이 발생할 수 있습니다.
    - 데이터 종속성 문제 
        - 응용 프로그램의 가용성이 파일의 형식에 구속되는 '데이터 종속성'이 발생합니다.
            - 예: 파일 데이터가 xls 형식에서 csv 형식으로 변경되는 경우, xls 파일만 읽도록 설계된 응용 프로그램은 더이상 사용할 수 없음
        - 데이터를 담고 있는 파일의 내부 구조가 바뀔때마다 응용 프로그램도 그에 맞게 바뀌어야 합니다.
        - 파일 시스템은 '내용에 의한 참조'가 아닌 '위치에 의한 참조'를 사용하기 때문입니다.
    - 데이터 중복 및 일관성 문제
        - 동일한 정보가 여러 파일에 중복되어 저장될 가능성이 높습니다.
            - 데이터가 어디에 있든 그 상태와 내용이 모두 동일하게 유지/갱신되어야 하는 '일관성'을 유지하기 어렵습니다.
            - 저장 공간이 낭비됩니다.
    - 무결성 문제
        - 파일 형태로 저장되다보니 데이터 그 자체에다가 제약 조건을 부여하고 강제하기 어렵습니다.
            - 예: 전화번호는 반드시 '13자리 이하의 정수'여야 하는데, 이러한 제약 조건은 평문 텍스트 파일 형식에서는 부여할 수 없음
        - 제약 조건에 변경이 생겨도 이를 파일과 프로그램 모두에 반영하기 까다롭습니다.
    - 원자성 문제
        - 하나의 트랜잭션은 그 작업 내용이 '모두 수행됨' 또는 '모두 수행되지 않음' 중 하나의 상태만을 가져야 합니다.
        - 파일 시스템에서는 이를 보장하기 어렵습니다.
            - 예: 12개의 파일이 반드시 한꺼번에 삭제되어야 하는데 오류로 인해서 8개만 삭제되고 작업이 끝나버리는 경우
    - 동시 접근 문제
        - 동일 시점에 동일한 데이터를 여러 사용자가 동시에 접근해 변경하는 경우 문제가 발생할 수 있습니다. 
            - 예: FTP를 통해 공유되고 있는 1학년_3반_학사정보.csv 파일을 세 명의 선생님이 동시에 편집을 시도해 race condition이 발생하는 경우
    - 보안 문제
        - 시스템 운영에는 데이터 제약 조건 뿐만 아니라 보안 제약 조건도 필요합니다.
            - 예: 특정 민감정보를 담고 있는 특정 데이터셋에는 특정 사용자들의 접근을 차단해야 함
        - 세밀한 접근 권한을 수많은 파일 데이터에 일일이 반영하기 어렵고, 응용 프로그램을 통해서만 통제해야 하므로 보안 유지가 어렵습니다.
- 데이터베이스의 장점
    - 데이터베이스의 장점은 자동적으로 발생하는 것은 아니며, 적절하고 효율적인 설계가 중요합니다.
        - 데이터 중복 최소화
        - 데이터 일관성 유지
        - 데이터 독립성 유지
        - 데이터 무결성 유지
        - 데이터의 공용과 가용성
        - 데이터 표준화에 유리
        - 데이터 요구사항 조정 가능
        - 데이터 보안 구현 가능
- 데이터베이스의 단점
    - 운영 비용 문제
        - 고가의 소프트웨어, 많은 컴퓨터 자원, 고사양의 장비가 필요할 수 있습니다.
    - 자료처리 방법의 복잡성
        - 하나의 데이터베이스 아래에 수많은 데이터들이 수많은 형식으로 수많은 제약사항 하에 서로 연관되고 연동될 수 밖에 없습니다.
        - 시스템 구조 및 프로그램 로직이 복잡해질 수 있습니다.
    - 백업과 회복의 어려움
        - 데이터의 동시 사용과 공유를 보장해야 하므로 장애 발생시 그 원인과 상태의 분석이 어려울 수 있습니다.
        - 정교한 백업 및 회복 기법을 사용해야 합니다.
    - 통합된 시스템의 취약성
        - 모든 데이터가 중앙집중화된 시스템이므로 일부 장애가 전체 시스템을 마비시킬 수 있습니다.
        - 시스템의 신뢰성과 가용성에 DBMS가 의존하게 됩니다.

## 1-2. DBMS

### 데이터베이스 관리 시스템 (DBMS)
- 데이터베이스를 생성하고 관리해주는 시스템입니다.
    - 데이터베이스와 애플리케이션 사이에서 데이터와 관련된 작업을 중개해주는 역할을 합니다.
    - 사용자가 생각하는 데이터베이스의 논리적 구조와, 저장소에 실제로 저장되어 있는 데이터의 물리적 구조를 대응(mapping)시켜줍니다.
    - 대부분의 DBMS는 하드웨어로부터 독립적으로 운영됩니다.
- 목적
    - 데이터 독립성 보장
        - 데이터의 논리적/물리적 구조가 변경되더라도 애플리케이션은 영향을 받지 않도록 합니다.
        - DBMS는 '내용에 의한 참조'를 사용하기 때문입니다.
    - 데이터 중복성 최소화
        - 중복되는 데이터로 인해 발생하는 일관성, 보안성, 경제성, 무결성 관련 문제를 해소합니다.
- 기능
    - 데이터 정의
        - 데이터 모델에 따라 여러 사용자의 데이터를 통합/저장/공유할 수 있도록 정의합니다.
        - 데이터베이스와 애플리케이션 사이의 프로토콜, 데이터베이스와 사용자 사이의 인터페이스를 정의합니다.
    - 데이터 조작
        - 데이터베이스상의 데이터에 삽입/삭제/변경/검색 등의 접근/조작을 수행할 수 있도록 해줍니다.
        - 사용자가 사용하기 쉬워야 하고, 데이터 조작 처리를 자연스럽게 표현할 수 있어야 합니다.
    - 데이터 제어
        - 데이터베이스의 내용을 일관되고 정확하게 유지할 수 있게 해줍니다.
            - 데이터 일관성 유지
            - 데이터 무결성 유지
            - 데이터 인증 및 보안 유지
            - 백업 및 회복
            - 병행 제어 (concurrency control)
                - 여러개의 트랜잭션이 실행될 때, 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않고 다른 트랜잭션에 영향을 주지 않도록 제어합니다.
- 구성 요소
    - 데이터베이스 언어
    - 사용자
        - 일반 사용자
            - 비절차적 DML을 사용해 데이터에 접근 및 사용합니다.
        - 프로그래머
            - 프로그래밍 언어와 비절차적 DML을 사용해, 데이터를 활용하는 애플리케이션을 개발합니다.
        - DBA
            - DDL과 DCL을 통해서 데이터베이스 자체를 정의하고 제어합니다.
            - 데이터베이스를 '설계'와 '관리'하는 역할로 나누기도 합니다.
                - 설계
                    - 데이터베이스 개체, relation, 구조, 접근 방법 설계
                    - 보안, 권한, 데이터 유효성/무결성 정책 수립
                    - 백업 및 회복 절차 수립
                - 운영/관리
                    - 시스템 카탈로그 유지 관리
                    - 데이터베이스 표준화 및 문서화
                    - 자원 점유율, 병목 현상, 시스템/장비 성능 및 오류 감시
                    - 요구조건 충족과 성능 향상을 위한 데이터베이스 튜닝
                - 분석
                    - 데이터 접근 방법 및 저장 구조 분석
                    - 사용자의 요구조건 변화 파악
                    - 데이터 관련 각종 통계 등
    - DBMS
        - 각 단계별 스키마를 도표화해서 데이터 독립성 구현
        - 스키마를 비롯해 '데이터에 관한 데이터'인 metadata들을 data dictionary를 통해 유지/관리
    - 3단계 데이터베이스
        - 외부/개념/내부 스키마

### Schema
- 스키마는 데이터베이스의 구조와 제약조건을 기술한 명세서
    - 데이터 구조를 나타내는 '개체'
    - 개체를 구성하는 '속성'
    - '개체간 관계(relation)'에 대한 정의
    - 이들이 유지해야 될 '제약조건(constraint)'
- 외부 스키마 (subschema)
    - 사용자 및 응용 관점에서의 데이터베이스 스키마
        - view 단계에서 여러개의 사용자 관점으로 구성
            - 각각의 사용자가 보게 되는 개인적 DB 스키마
        - '시스템 외부'적인 스키마
        - 전체 데이터베이스 중 논리적인 일부분의 스키마
    - 예: 학생과 (학번, 성적) / 교무과 (학번, 이름) / 학적과 (학번, 주소)
- 개념 스키마 (schema)
    - 조직 전체 관점에서의 데이터베이스 스키마
        - 통합된 전체적 스키마
    - 예: 학번, 이름, 성적, 주소
- 내부 스키마 
    - 저장장치 관점에서 정의한 데이터베이스 스키마
        - '시스템 내부'적인 스키마
    - 예: 학번(INTEGER 10), 이름(VARCHAR), 성적(DECIMAL 3), 주소(VARCHAR)

### 데이터베이스 언어
- 데이터베이스를 정의/조작/제어하기 위한 언어입니다.
    - 데이터베이스 언어는 1세대 기계어, 2세대 어셈블리어를 넘어, 3세대 언어는 '절차적 언어'를 사용합니다.
        - '무엇'을 '어떻게' 하는지 순서적으로 기술하는 방식입니다.
        - 이후 객체지향 개념이 포함된 3.5세대 언어가 출현합니다.
    - 4세대 언어는 '비절차적 high-level language'로써 '무엇'만을 언급하면 '어떻게'는 시스템이 알아서 수행하도록 합니다.
        - SQL이 여기에 해당됩니다.
            - 한번에 하나의 record를 만들어 일괄적으로 처리합니다.
- 종류
    - Data Definition Language
        - 데이터베이스의 구조를 정의/변경하기 위한 언어
        - 예: CREATE, ALTER, DROP
    - Data Manipulation Language
        - 데이터베이스에 있는 데이터를 변경/처리하기 위한 언어
        - 예: INSERT, DELETE, UPDATE, SELECT
    - Data Control Language
        - 데이터베이스 시스템 자체를 관리(admin)하는 기능을 제공하는 언어
        - 예: GRANT, REVOKE, COMMIT, ROLLBACK

# 2. 관계형 데이터 모델

## 2-1. 데이터 모델

### 데이터 모델이란?
- Structure + Operation + Constraint
    - 구조
        - 데이터의 정적인 성질
        - 개체의 특성과 개체간 관계를 표현
    - 연산
        - 데이터의 동적인 성질
        - 개체 처리 작업과 조작에 관한 명세
    - 제약조건
        - 데이터의 논리적 제약
        - 데이터 조작의 한계를 규정

### 관계형 데이터 모델
- Relational structure + Relational algebra/calculus + Integrity constraints
- 특성
    - 단순한 모델 구조
    - 수학적 집합이론에 기반한 강건한 모델
    - 비절차적 언어인 SQL을 사용해 간편하게 데이터 처리 가능
- 개념적 구성 요소
    - 개체 (entity)
        - 표현하고자 하는 '현실 세계의 고유한 유/무형 객체'
        - 데이터베이스에서 표현되는 정보의 단위
        - 개체의 성질
            - 유일한 식별자에 의해 식별 가능해야 함
            - 영속적으로 존재하는 개체의 집합이어야 함
            - 시스템이 추구하는 업무와 관리에 필요한 정보여야 함
            - 업무 프로세스가 반드시 해당 개체를 이용해야 함
            - 반드시 하나 이상의 속성을 포함해야 함
                - 속성(attribute)은 가장 작은 논리적 단위로써 내부의 구조를 가지고 있지 않은 atomic한 값
            - 반드시 다른 개체와 최소 한 개 이상의 관계를 맺어야 함
    - 관계 (relationship)
        - 개체들 사이에 존재하는 연관성
- 구조
    - 2차원 테이블 구조
        ```
        2024 Q1 Personnel Transfer List

        ATTRIBUTE               ATTRIBUTE   ATTRIBUTE
        ↓       ↓                   ↓           ↓  
        id     name                state      dept           ...
        --------------------------------------------------------
        01     Adam Jenkins        NY         accounting     ...   ← TUPLE
        02     Nadia Williams      MD         finance        ...   ← TUPLE
        03     Cameron Anderson    CA         marketing      ...   ← TUPLE
        04     Lisa McCarthy       NY         finance        ...   ← TUPLE
        ...    ...                 ...        ...
        ```
        - 각각의 행 = tuple = entity
            - 예: 첫번째 행 = Adam Jenkins라는 이름을 가진 사람이라는 하나의 entity
        - 각각의 열 = attribute + integrity constraint (= domain)
            - 예: 일련번호를 나타내는 id라는 속성 + id라는 속성에 부여되는 무결성 제약조건(2자리 정수)을 따르는 실제 값들
            - 도메인이란?
                - '무결성 제약조건'으로써 특정 속성이 반드시 지켜야 하는 제약조건을 의미합니다.
                    - 사전적 의미: 하나의 속성이 취할 수 있는 값들의 집합(범위)
                - 프로그래밍 언어에서 특정 변수에 지정되는 '타입'과 유사합니다.
                    - 예: `int x` 라고 선언한 변수 x는 반드시 정수형 값만을 가짐
        - 릴레이션 = tuple들의 집합 = table
        - 스키마 = attribute들의 집합

### 릴레이션
- 수학적 정의
    - Relation R ⊆ D₁ × D₂ × ... × Dₙ 
        - 여기서 하나의 도메인 D는 해당 제약조건이 걸려있는 하나의 속성 A에 대응됩니다.
        - 각 도메인들이 카티션 프로덕트(곱셈) 연산을 거쳐, 가능한 모든 pair의 집합으로써 만들어지게 됩니다.
        - 예시: 2024 Q1 Personnel Transfer List
            - id = (01, 02, 03)
            - state = (NY, MD, CA)
            - id × state = {(01, NY), (02, MD), (03, CA)}
                - 이 릴레이션의 차수(degree) = 속성의 수 = id, state = 2
                - 이 릴레이션의 cardinality = 튜플의 수 = 01, 02, 03 = 3
- 특성
    - 튜플의 유일성
        - 릴레이션은 튜플들의 '집합'입니다.
        - 집합은 중복을 허용하지 않으므로 모든 튜플은 고유해야 합니다.
    - 튜플의 무순서성
        - 릴레이션은 튜플들의 '집합'입니다.
        - 집합에서 원소들간의 순서는 없습니다.
    - 속성의 무순서성
        - 스키마는 속성들의 '집합'입니다.
        - 마찬가지로 속성들간의 순서는 없습니다.
    - 속성의 원자성
        - 속성은 더 이상 논리적으로 분해할 수 없는 가장 작은 단위의 원자값입니다.
        - 속성값들의 집합은 허용되지 않습니다. 이를 '정규화'라고 합니다.
            - 예: 2024 Q1 Personnel Transfer List
                - Adam Jenkins라는 엔티티는 NY라는 state 속성을 가지고 있는데, 여기에 또다시 state라는 속성을 추가할수는 없습니다.

## 2-2. 관계 해석과 관계 대수

릴레이션을 조작하기 위한 연산에는 두 가지가 있습니다. 

### 관계 해석(calculus)
- 쿼리에 대한 검색 조건을 기술합니다.
    - '무엇'을 할 것인가?
- 튜플 기반 vs 도메인 기반
    - SQL 언어는 '튜플 관계 해석'을 수행합니다.
        - '행'을 기반으로 합니다.
    - QBE 언어는 '도메인 관계 해석'을 수행합니다.
        - '열'을 기반으로 합니다.
    - 두 해석 방식은 유사하지만 사용하는 변수로써 '행'을 사용하는지 '열'을 사용하는지가 차이점입니다.

### 관계 대수(algebra) 
- SQL 쿼리를 실제로 DBMS가 처리를 할 때는 '관계 대수'를 사용합니다.
- 쿼리에 대한 수행 절차를 기술합니다.
    - '무엇'을 '어떻게' 할 것인가?
- 중요성
    - 관계형 모델에서 실질적인 연산을 위한 공식적 토대입니다.
    - 쿼리 구현 및 최적화를 위한 기반 이론입니다.
    - 관계 대수의 일부 개념은 SQL 표준 쿼리에도 반영됩니다.
- 연산 종류
    - 모델 기반의 분류
        - 수학적 집합 연산 
            - 수학적 집합이론에 근거
            - 예: 합집합, 교집합, 차집합, 카티션 프로덕트
        - 순수 관계 연산
            - 2차원 테이블 형태의 형식적 모형에 기반
            - 예: SELECT, PROJECT, JOIN
    - 피연산자 수 기반의 분류
        - 단항 연산자
            - 연산 대상이 되는 릴레이션을 하나만 가짐
            - 예: SELECT, PROJECT, RENAME
        - 이항 연산자
            - 연산 대상이 되는 릴레이션을 두 개 가짐
            - 예: JOIN, 합집합, 교집합, 차집합, 카티션 프로덕트
    - 합성 여부 및 표현 기반의 분류
        - 근원 연산
            - 관계대수 연산 대부분을 처리할 수 있는 근원적 연산자
            - 합집합, 차집합, 카티션 프로덕트, 프로젝트, 셀렉트
        - 복합 연산
            - 근원 연산으로부터 합성이 가능한 연산
                - 관계대수 연산 능력을 강화하지는 않지만 '표현 능력'을 향상시킴
            - 교집합, JOIN, DIVISION

### 폐쇄 성질
- 피연산자와 연산자의 결과가 같은 자료형을 의미합니다.
- 관계 대수의 모든 연산은 릴레이션에 대해서 폐쇄 성질을 가집니다.
    - 특정 릴레이션에 관계 대수 연산을 수행하면, 그 결과도 그대로 릴레이션입니다.
    - 폐쇄 성질에 따라 연산자의 nesting 순서를 표현하게 됩니다.
        - `OPERATION3( OPERATION2( OPERATION1(RELATION) ) )`

### 일반 집합 연산자
- 합집합, 교집합, 차집합 연산은 '합병 호환성'을 만족해야만 합니다.
    - 합병 호환성
        - 릴레이션은 튜플의 집합이어야 함
        - 집합은 homogenous한 원소들로 구성되어 있어야만 함
        - 연산의 결과가 릴레이션이어야 함 (=폐쇄 성질)
        - 피연산자의 제약조건
            - 차수(=속성의 수)가 같아야 함
            - 대응되는 속성 pair별로 도메인/타입/제약조건이 같아야 함
            - 대응되는 속성 pair별로 의미(semantic)가 같아야 함
                - '의미'가 같은지는 컴퓨터가 스스로 판단할 수 없으므로 사람이 직접 목적에 맞게 확인해서 진행해야 합니다.
                    - 예: '몸무게'와 '키'라는 전혀 다른 의미의 속성을 union 연산해봤자 그 결과는 아무런 의미가 없음 
- 연산자 종류
    - 합집합 (union)
        - 집합간 덧셈 연산
        - 교환 법칙 성립
        - 결합 법칙 성립
        - 중복되는 원소가 제거됨
    - 교집합 (intersect)
        - 공통된 원소만 추출
        - 교환 법칙 성립
        - 결합 법칙 성립
        - 중복되는 원소가 제거됨
        - 합집합과 차집합으로도 표현 가능
    - 차집합 (difference)
        - 집합간 뺄셈 연산
        - 교환 법칙이 성립하지 않음
    - 카티션 프로덕트 (Cartesian product = cross join)
        - 집합간 곱셈 연산
            - R × S = R에 속한 튜플들과 S에 속한 튜플들을 결합해 새로운 튜플을 생성
                - 결과의 차수 = R의 차수 + S의 차수
        - 합병 호환성이 필요하지 않음
        - 다른 연산자를 연동해서 적용하면 유용함

### 순수 관계 연산자
- 2차원 테이블 구조 릴레이션을 기반으로 하는 연산자입니다.
- 연산자 종류
    - SELECT
        - 선택조건을 만족하는 튜플들만 걸러냅니다.
            - 일항 연산자
            - 선택율 (selectivity)
                - 릴레이션 R 전체 중에서 선택조건에 의해 선택된 튜플의 비율
            - 교환성 (commutative)
                - 여러 선택조건들을 릴레이션에 적용하는 순서가 바뀌어도 결과는 동일합니다.
                - 다만 선택율이 작은 SELECT 연산을 먼저 수행하는 것이 좋습니다.
    - PROJECT
        - 릴레이션에서 일부 속성(열)만 선택하고 나머지를 버립니다.
            - 일항 연산자
            - 속성 리스트
                - 릴레이션 R 전체 중에서 선택하고자 하는 속성들의 리스트
            - 결과에 속한 중복 튜플들은 모두 제거됨
            - 교환법칙이 성립하지 않음
        - SELECT와 PROJECT만 있으면 단일 테이블에서 원하는 정보를 충분히 추출 가능합니다.
    - DIVISION
        - R ÷ S = S에 속한 모든 튜플과 연관이 있는 R 튜플을 찾아냄
            - "모든 ~에 대한" 이라는 쿼리에 적합함
            - 카티션 프로덕트와의 교환법칙이 성립하지 않음
                - R을 S로 나누고, 다시 S를 곱해도 원래의 릴레이션 R로 복원되지 않을 수 있습니다.
        - SQL에서는 직접적으로 지원하지는 않습니다.
    - RENAME
        - 연산의 중간 결과물에 편의상 이름을 지정하고자 사용합니다.
    - GROUP
        - 릴레이션에 저장된 튜플들의 통계정보를 추출할 때 사용합니다.
        - 테이블에 속한 세부 튜플들을 작은 그룹들로 나누고 각 그룹의 통계정보를 파악할 때 사용합니다.
        - SUM, MAX, MIN, AVG, COUNT 등의 집단 함수를 리스트로 엮어 사용합니다.

### JOIN 연산자
- 두 개 이상의 릴레이션이 가지는 관계를 처리할 수 있는 연산입니다. 
    - 이항 연산자
    - 실제로 두 릴레이션을 합치거나 빼는 것이 아니라, 두 릴레이션 모두에 해당되는 선택조건을 적용해줍니다.
        - concatenation 개념으로써, 여기에 다른 연산을 추가적으로 적용해 활용합니다.
- Theta join
    - 조인 조건으로써 `>, <, =, >=, <=, !=` 등을 사용합니다.
    - 일반적으로 동등 비교만을 조건으로 사용하는 equal join을 사용합니다.
- Natural join
    - 조인 결과에서 조인 속성을 하나 제거해서, 중복된 값이 나타나지 않도록 한 조인입니다.
        - 예: 경영학 학위와 영문학 학위를 둘 다 취득한 학생 목록을 학생의 '학번'을 기준으로 불러오고자 할 때, 
            - 동등 조인: 경영학과 졸업생 목록 릴레이션과 영문학과 졸업생 목록 릴레이션으로부터 '학번', '이름' 등의 공통된 속성들이 중복되어 나타납니다.
            - 자연 조인: 공통된 속성들은 중복 없이 하나만 표시됩니다.
    - 조인 조건을 기술하지 않으며, 조건 없이 두 테이블을 조인한다면 '자연 조인'을 의미합니다.
    - 동등 조인과 자연 조인의 차이점은 '스키마' 입니다.
        - 동일한 조인 속성들이 결과 릴레이션에 하나만 나타나는지(자연 조인), 아니면 중복되어 나타나는지(동등 조인) 여부

### SEMI JOIN
- 분산 데이터베이스에서 활용합니다.
    - 두 릴레이션이 서로 다른 컴퓨터에 저장이 되어 있는 경우, 조인에 참여하는 튜플들만 찾아서 다른 컴퓨터로 해당 릴레이션을 전송합니다.
    - 네트워크 부담을 최소화하는 조인 방법입니다.

### OUTER JOIN
- 조인에 참여하는 릴레이션의 모든 튜플들이 조인 여부와 관계없이 결과 릴레이션에 나타나는 조인 연산입니다.
- 상대방 릴레이션에 대응되는 튜플이 없으면 NULL값을 채워서 포함시킵니다.
- 종류
    - LEFT OUTER JOIN
        - 릴레이션 R과 릴레이션 S가 있을 때, 릴레이션 R의 모든 튜플들이 결과 릴레이션에 나타나도록 합니다.
    - RIGHT OUTER JOIN
        - 릴레이션 R과 릴레이션 S가 있을 때, 릴레이션 S의 모든 튜플들이 결과 릴레이션에 나타나도록 합니다.
    - FULL OUTER JOIN
        - 릴레이션 R과 릴레이션 S가 있을 때, 릴레이션 R과 S의 모든 튜플들이 결과 릴레이션에 나타나도록 합니다.

### OUTER UNION
- 합병 호환성을 만족하지 않는 두 릴레이션을 합병해야 하는 경우에 사용합니다.
    - 릴레이션의 모든 속성들을 포함하는 확장된 릴레이션을 만듭니다.
    - 확장된 결과 릴레이션에 해당하는 속성값이 없을 때에는 NULL로 채웁니다.

## 2-3. 제약 조건

### Key
- 하나의 릴레이션 내에서 각 튜플을 유일하게 식별해낼 수 있는 속성들의 집합을 '키(key)'라고 합니다.
    - 릴레이션이라는 집합의 원소로써, 튜플은 중복되지 않고 고유합니다.
        ```
        2024 Q1 Personnel Transfer List

        PK   ATTRIBUTE          ATTRIBUTE   ATTRIBUTE                      PK (= R1's FK)
        ↓        ↓                   ↓           ↓                          ↓
        id     name                state      dept           ...           emp     branch          date
        --------------------------------------------------------           ----------------------------------
        01     Adam Jenkins        NY         accounting     ...           01      Singapore       2024-01-21    ← TUPLE
        02     Nadia Williams      MD         finance        ...           02      London          2024-01-21    ← TUPLE
        03     Cameron Anderson    CA         marketing      ...           03      Stockholm       2024-02-07    ← TUPLE
        04     Lisa McCarthy       NY         finance        ...           04      Munich          2024-02-13    ← TUPLE
        ...    ...                 ...        ...                          ...     ...             ...

        [R1: EMPLOYEE ROSTER]                                              [R2: 2024 Q1 TRANSFER PLAN]

        ```
        - 고유한 튜플이 가지고 있는 모든 속성값들을 사용하면 튜플을 식별해낼 수 있습니다.
            - 이 예시에서 id가 01이면서 name이 Adam Jenkins면서 state가 NY면서 dept가 accounting인 튜플은 단 하나밖에 없습니다.
        - 하지만 모든 속성값들이 아니라 각 튜플이 유일하게 보유하고 있는 속성 하나만 있으면 우리는 튜플을 특정해낼 수 있습니다. 
            - name도 state도 dept도 중복된 값을 가질 수 있다고 할 때, 중복되지 않은 일련번호인 id를 사용하면 우리는 03번 id를 검색해 Cameron Anderson의 튜플을 곧바로 찾아낼 수 있습니다.
    - 관계형 데이터베이스 모델에서는 내용, 즉 값에 의한 참조를 사용하기 때문에 key가 중요합니다.
- 특징
    - 릴레이션 내에서 해당 키 값을 가지는 속성 집합(열)은 항상 하나만 존재함
    - 시간이 지나도 key의 성질은 불변함
- 종류
    - Candidate key
        - 다음 조건을 만족하는 모든 속성들은 후보키가 될 수 있음
            - 유일성 (uniqueness)
                - 튜플의 유일성을 유지시키는 최소 속성의 집합
                - 서로 다른 두 튜플의 속성 집합의 값이 같지 않고 유일함
            - 최소성 (minimality)
                - 서로 다른 두 튜플을 식별하기 위한 최소한의 속성들로만 구성됨
        - 하나의 릴레이션 안에 후보키는 여러 개가 있을 수 있음
    - Primary key (PK)
        - 여러 개의 후보키들 중에서 사용하기로 결정한 단 하나의 키
    - Super key
        - 유일성을 만족하되 최소성을 만족하지 않는 키들
    - Alternative key
        - 기본키를 제외한 나머지 후보키들
    - Foreign key (FK)
        - 참조(referencing) 릴레이션 R1의 튜플과 피참조(referenced) 릴레이션 R2의 튜플간의 연관 관계를 표시하기 위해서 사용
            - 위의 예시에서 R1 릴레이션의 기본키인 id를 사용해 R2 릴레이션을 참조하고자 한다면, R2 릴레이션의 기본키 emp는 R1 릴레이션 입장에서는 '외래키'가 됩니다.
        - 두 개의 서로 다른 릴레이션이 아니라 하나의 릴레이션 안에서도 기본키와 외래키가 함께 있을 수 있습니다.
            - 외래키는 '참조' 여부에 따라 결정되기 때문입니다.

### 무결성 제약조건
- 무결성 종류
    - 개체 무결성
        - 서로 다른 두 튜플의 모든 값이 같을 수는 없음 = 릴레이션에는 기본키가 필요함
            - 각 엔티티는 중복되지 않고 고유해야 하며 식별 가능해야 함
            - 릴레이션에서 기본키는 바로 이 고유함을 보장하는 역할을 함
                - 만약 기본키가 null이라면 튜플을 유일하게 식별할 수 없으므로, 엔티티의 정의를 위반함
        - 모든 튜플은 반드시 중복되지 않는 고유한 기본키 값을 가져야 한다는, NOT NULL 제약조건을 걸어서 개체 무결성을 보장할 수 있음
    - 참조 무결성
        - 참조 릴레이션 R의 외래키 값은 피참조 릴레이션 S의 기본키 값이거나 null이어야 함
            - 릴레이션은 참조할 수 없는 외래키를 가질 수 없음
                - 참조할 수 없는 외래키를 가진다는 것은, 존재하지 않는 튜플을 참조한다는 의미이기 때문
                - 위의 예시에서 R1의 기본키 id가 R2의 date를 외래키로써 가질수는 없음 
            - 다만 외래키 값이 null일 수는 있음
    - 도메인 무결성
        - 속성 값은 해당 속성 도메인에 속한 값들 중 하나여야 함
            - 예: 대학생의 학년 도메인은 1, 2, 3, 4의 값만 가질 수 있음
- 이러한 무결성 제약조건들은 데이터베이스 상태가 항상 만족하고 있어야 하는 기본 규칙입니다.
    - DBMS는 이러한 무결성 제약조건들을 항상 확인하고 위반 사항을 감시합니다.
- 무결성 위반 처리
    - 삽입 연산
        - 제약조건 위반 시 작업을 거부하거나 위반 사실을 사용자에게 통보
    - 삭제 연산
        - 튜플 삭제시 다른 테이블에서 이를 참조하고 있지 않은 상황에서만 삭제 = 참조 무결성 보존
        - 참조 무결성 위반시 옵션
            - 삭제 거부
            - 삭제될 튜플을 참조하는 튜플들도 함께 연쇄 삭제
            - 삭제될 튜플을 참조하는 튜플에서 외래키 값을 null로 바꾸거나 다른 유효한 튜플을 참조하도록 변경
    - 갱신 연산
        - 기본키나 외래키가 아닌 속성값의 변경은 문제가 없음
        - 갱신 작업은 '삭제 후 삽입' 작업이므로 두 연산에 관한 문제가 모두 발생할 수 있음

# 3. 데이터 모델링

## 3-1. 데이터 모델링의 개념

### 데이터 모델링이란?
- 모델링
    - 복잡한 현실 세계를 단순화시켜 표현하는 것
    - 사물/현상에 관한 양상이나 관점을 연관된 사람이나 그룹을 위해 명확화 하는 것
    - 현실 세계의 추상화된 반영
- 데이터 모델링은 사용자의 요구사항으로부터 데이터의 실체를 나타내는 일입니다.
    - 특징
        - 추상화
            - 다양한 현상을 일정한 양식인 표기법을 통해 표현합니다.
        - 단순화
            - 복잡한 현실 세계를 약속된 규약으로 표현해 쉽게 이해할 수 있도록 단순화합니다.
        - 명확화
            - 대상에 대한 애매모호함을 제거하고 정확하게 기술해 누구나 이해하기 쉽게 만듭니다.
    - 관점
        - 데이터 관점
            - "업무가 어떤 데이터와 관련이 있는지? 데이터간의 관계는? What data, which data?"
            - 데이터베이스의 구조를 온전히 이해하고 쿼리문을 어떻게 효율적으로 구성할지에 필요한 관점입니다.
        - 프로세스 관점
            - "무슨 업무를? 어떻게? How to perform what processes?"
            - 업무에 대한 종합적인 이해를 바탕으로, 데이터에 존재하는 business rule에 따라 참/거짓을 판별할 수 있는 사실을, 데이터로부터 독립적으로 바라보는 관점입니다.
        - 데이터 + 프로세스 관점
            - "업무처리에 영향을 받는 데이터를 어떻게? How data interacts with processes?"
            - 데이터 모델링과 프로세스 모델링은 상호보완적 관계
            - 프로세스를 잘 반영하면서도 동시에 프로세스에 종속되지 않고 유연한 설계가 필요합니다.
        - 정보공학 관점
            - 데이터와 프로세스를 분리해서 모델링
        - 객체지향 관점
            - 데이터와 프로세스를 '비즈니스 로직'을 기반으로 동시에 모델링
    - 필요성과 목적
        - 시스템 구조와 프로세스를 명세화/가시화/문서화
        - 필요한 영역에 집중하기 위해 다른 영역의 세부사항은 숨기는 추상화
        - 정보 요구사항과 한계를 파악하는 가장 직관적인 방법
            - 이를 바탕으로 애플리케이션을 개발하고 데이터 정합성을 유지
        - 데이터 품질 향상과 전략적 활용에 필요함
    - 데이터 모델링에서의 유의점
        - 중복 (duplication)
            - 하나의 원천으로 모일 수 있는 데이터가 잘못 모델링될 경우 불필요하게 중복/낭비/고립될 수 있음
        - 비유연성 (inflexibility)
            - 데이터가 프로세스에 종속되거나 고착화될 우려가 있음
        - 비일관성 (inconsistency)
            - 데이터의 중복이 없더라도 비일관성은 발생할 수 있음
        - 데이터간의 상호 연관 관계를 명확하게 정의해서 이러한 문제들을 사전에 에방할 수 있습니다.

### 좋은 데이터 모델링의 조건
- 완전성: 필요로 하는 모든 데이터가 모델상에 정의되어 있어야 함
- 중복 배제: 동일한 사실은 반드시 한 번만 기록되어야 함
- 데이터 재사용: 데이터의 통합성과 독립성에 기반해 재사용이 용이함
- 업무 규칙: 수많은 business rules를 데이터 모델에 담아내고, 모든 사용자가 그것을 이해하고 공유할 수 있음
- 안정성 및 확장성: 비즈니스의 변화에 대응할 수 있어야 함
- 간결성: 관리하고자 하는 데이터를 균형잡히고 단순하게 분류하는 것
- 의사소통: 좋은 데이터 모델은 그 자체로 의사소통을 원활하게 함
- 통합성: 동일한 데이터는 조직의 전체에서 한 번만 정의되고, 이를 여러 영역에서 참조/활용하는 방식이어야 함

## 3-2. 모델링 방법론

### 3단계 모델링
1. 개념 데이터 모델링 = 계획/분석 단계
    - 전사적이고 추상적이고 업무적인 포괄적 모델링
        1. 업무를 주제별로 분석한 후 핵심 엔티티 추출
        2. 엔티티간의 관계를 정의
        3. 전체 데이터 모델의 골격 생성
        4. 엔티티/업무간의 관계를 표현하기 위한 entity-relationship diagram (ERD)를 작성
2. 논리 데이터 모델링 = 분석 단계
    - 시스템으로 구축하고자 하는 업무에 대해서 key, attribute, relationship 등을 정확하게 표현하며, 재사용성이 높음
        1. ERD를 바탕으로 상세 속성을 정의
        2. 식별자 확정
        3. 정규화와 같은 상세화 과정 수행
3. 물리 데이터 모델링 = 설계 단계
    - 실제로 데이터베이스에 이식할 수 있도록 성능과 저장 장치 등 물리적 성격을 고려함
        1. DBMS의 특성과 구현 환경 등을 감안해 스키마를 도출
        2. 테이블 컬럼의 데이터 타입과 크기를 정의
        3. 효율적으로 데이터베이스를 사용할 수 있도록 사용량 분석 및 예측
        4. 인덱스 정의 및 역정규화 등의 세부 작업 수행

### 데이터 독립성과 3단계 모델링
- Service-oriented architecture(SOA)에서 '서비스'란 독립적 비즈니스로 처리 가능한 단위를 의미합니다.
    - 과거에는 '데이터가 있는 파일'과 '데이터에 접근하기 위한 인덱스'를 별도로 구현하여 접근했습니다.
    - 요즘은 '사용자의 접근 방법(트랜잭션 유형)'에 따라 파일/인덱스의 정렬 순서와 구성을 별도로 구성합니다.
        - 즉, 서비스의 트랜잭션에 따라 데이터의 구성 방법이 영향을 받게 됩니다.
- 데이터 독립성 확보의 효과
    - 각 view의 독립성을 유지
        - 계층별 view에 영항을 주지 않고 변경 가능
    - 단계별 스키마에 따라 DDL과 DML을 다르게 제공
- ANSI 표준 모델
    - 3단계 구조
        - 외부 스키마
        - 개념 스키마
        - 내부 스키마
    - 독립성
        - 논리적 독립성
            - 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않아야 함
            - 논리적 구조가 변경되어도 애플리케이션에는 영향이 없어야 함
        - 물리적 독립성
            - 내부 스키마가 변경되어도 개념 및 외부 스키마는 영향을 받지 않아야 함
            - 저장 장치의 구조가 변경되어도 개념 스키마와 애플리케이션은 영향을 받지 않아야 함
    - 사상 (mapping)
        - 논리적 사상
            - 사용자에게 인터페이스하기 위한 외부 스키마는 개념 스키마와 연결되어 있어야 함
        - 물리적 사상
            - 개념 스키마 구조는 물리적으로 저장되어 있는 테이블 공간과 연결되어 있어야 함
    - DBA가 필요에 따라 사상을 위한 DDL을 변경하거나, 변경 사항이 있을 때 DBMS가 자동으로 처리해줌으로써 데이터 독립성을 확보할 수 있습니다.

## 3-3. 개념 데이터 모델
- 주로 전사적 데이터 모델링에서 사용되며, 조직 전체에서 사용/관리되는 데이터의 골격을 만들어 '전사적으로 동일한 관점에서 데이터를 바라보고 참조할 수 있도록' 합니다.
    - 전사의 모든 엔티티를 포함하되 '핵심 엔티티'를 중심으로 핵심 엔티티를 명확하게 정의하고 엔티티간의 관계를 정의합니다.
- 접근법
    1. 모델을 상세화 하기 전에 주요 엔티티를 정의합니다.
    2. 엔티티 식별자와 속성을 도출합니다.
    3. 엔티티간의 관계를 정리합니다.
- 세부 모델
    - 개념 모델
        - 업무 처리에 필요한 주요 엔티티들을 모두 도출하고, 식별자 및 관계 등이 모두 그려진 구체적인 모델
        - '개념적'이라고 해서 '추상적'인 것은 아닙니다. 
            - 여기서 말하는 개념은 전체적인 concept를 제대로 잡는다는 의미에서의 개념입니다.
            - 위에서 언급되었듯 전체적인 밑그림을 그리기 위해 필요한 모든 요소들이 포함되어 있어야 합니다.
    - 논리 모델
        - 개념 모델을 상세화한 것
        - 주요 엔티티 뿐만 아니라 개별 엔티티들의 속성도 모두 도출된 구체적인 모델
        - 정보 요구사항을 인간이 이해하기 적합한 수준으로 통합/분리해 온전히 구현한 모델
    - 물리 모델
        - DBMS가 데이터를 담는 논리적인 구조
        - 데이터를 현실에서 효율적으로 관리하기 위한 구조
        - 제약 조건의 상세한 명세서

### 주제 영역 (subject area)
- 기업이 사용하는 데이터의 최상위 집합이며, 주제 영역을 분해하면 하위 영역이나 엔티티가 나오므로 이를 계층적으로 표현 가능
    - 데이터는 기본적으로 상호 연결된 관계 구조이므로, top-down이나 bottom-up과 같은 수직적 분석이 쉽지 않습니다.
        - 계획 수립 단계에서 주제 영역을 정의하게 되면 데이터를 하향식으로 분석하기에 유용합니다.
        - 검증 단계에서는 상향식 분석을 부분적으로 사용합니다.
- 특징
    - 업무 영역을 구분해 효율적 데이터 모델링을 가능하게 함
    - 대규모 시스템의 데이터 모델링에서 시스템 복잡도를 줄이고 모듈화를 통해 직관성 향상
    - 시스템의 확장성과 개발 품질 향상에 도움을 줌
    - 구축을 넘어 지속적인 운영관리와 현행화를 통해 효용 도출
- 장점
    - 데이터의 계층적 구조 파악에 용이
    - 주제 영역 계층과 업무 기능 계층간 대응관계 확인
    - 전사적 데이터 구성에 대한 청사진 제공
    - 데이터 구성과 통합의 방향을 선언적으로 제시
    - 효율적 데이터 관리 기준 제공
- 도출 방법
    1. 주요 데이터 집합의 유형 정의
        - 업무 변화에 민감하지 않도록, 기존 시스템별로 제공되는 데이터의 특성을 고려
            - 데이터 발생 주체별로 분류
                - 예: 관계자, 상품, 서비스, 자산, 채널
            - 주체간의 상호작용으로 발생하는 대상별로 분류
                - 예: 계약, 리스크, 상품, 조건
            - 공통 및 관리 성격의 상위 개념으로 분류
                - 예: 경영관리, 정책, 지원 
    2. 업무 활동에 필요한 데이터 분류
        - 기본/상세/관계 등 데이터의 기능적 구성 관점에서 1차 분류를 더욱 세분화
            - 예: 관계자 기본, 관계자 상세, 관계자 관계
    3. 2차 영역의 세부 주제 영역 분류
        - 사용자에게 제공되는 실제 데이터로서의 관점에 근거해 정의
            - 예: 관계자 기본 -> 고객, 법인, 조직, 직원
- 주제 영역의 분류 원칙
    - 데이터 관점에서의 분류
        - 데이터를 중심으로 바라보고 주제 영역을 분류해야 합니다.
            - 데이터와 비즈니스 로직이 혼재되지 않는 것이 중요합니다.
            - 데이터 독립성을 보장해야 합니다.
    - 데이터의 중복 최소화
        - 불필요하게 낭비되는 비용과 데이터를 방지하기 위해 체계적 분류가 필요합니다.
    - 데이터의 확장성 보장
        - 미래에 추가될 수 있는 정보에 대한 최대한의 확장성을 고려해야 합니다.
    - 데이터의 관련성 및 편의성
        - 다른 자원/정보/영역과의 인접성을 고려해야 합니다.
    - 요구사항 변경에 따른 데이터 구조 변화에 대응할 수 있도록 유연성 확보
        - 동일 유형의 데이터를 그 본질이 희석되지 않는 한도 내에서 '최대한의 집합'으로 통합시킵니다.
            - 그러면 신규 및 변경 요건이 있더라도 기존의 분류 구조에서 적절하게 수용 가능합니다.
    - 주제 영역간의 균형
        - 특정 영역들만 너무 상세하거나 방식이 달라서는 안됩니다.
        - 다른 영역의 분류 체계와의 형평성과 균형을 고려해야 합니다.
    - 데이터의 원자성 보장
    - 시간의 흐름에 수직적으로 분할된 주제 영역 분류
        - 예: 학원에서 사용할 데이터를 모델링할 때
            - 업무 진행의 시간적 흐름이 아니라 각 업무 유형별로 분류를 하게 되면 서비스별로 유사한 엔티티들이 생기게 됩니다.
                - 주제 영역을 '강의 과목'별로 분류하게 되면 다음과 같이 정보가 중복되어 담기게 됩니다.
                    - A 과목: 수강생, 강의실, 강사
                    - B 과목: 수강생, 강의실, 강사
                    - C 과목: 수강생, 강의실, 강사
            - 따라서 시간의 흐름에 수직적으로 분할해 분류하는 것이 적절합니다. 
                - 주제 영역을 '수강신청'이라던가 '강좌' 등으로 분류하게 되면 다음과 같이 데이터가 적절하게 분리됩니다.
                    - 수강신청: 수강생, 강의 과목
                    - 강의: 강사, 강의실
        - 단, 업무간 관계와 결과물들을 먼저 검토 및 검증한 이후에 수직적으로 분할해야 합니다.
            - 자동차 보험, 화재 보험, 생명 보험과 같이 업무 흐름/구조/역할이 각각 크게 다르다면 시간적 흐름이 아닌 업무의 유형별로 분류를 해야 합니다.

### 핵심 엔티티
- 엔티티 종류
    - 유/무형 기준 
        - 유형 엔티티
            - 물리적 형태가 있고 지속적으로 활용되는 개체
            - 예: 강사, 물품, 사원
        - 개념 엔티티
            - 물리적인 형태가 없으나 관리해야 할 개념
            - 예: 조직, 장소
        - 사건 엔티티
            - 업무 수행 과정에서 발생되는 개체로써 비교적 발생량이 많음
            - 예: 주문, 청구, 미납 등 
    - 발생 시점 기준
        - 기본(key) 엔티티
            - 업무에 원래 존재하는 정보로써 독립적으로 생성됨
            - 다른 엔티티들의 최상위 엔티티로써, 상위 엔티티를 가지지 않은 독립적인 엔티티
            - ERD 상에서 주어가 되는 엔티티
                - 예: 사원, 고객, 강좌, 학생, 교수, 상품, 계정
        - 주요(main) 엔티티
            - 기본 엔티티에 의해 발생하며 업무에서 중심적인 역할 수행
            - 다른 엔티티와의 관계를 통해 행위 엔티티를 생성
                - 예: 기본 엔티티 '상품' -> 주요 엔티티 '상품 주문'
            - 발생량이 비교적 많음
                - 파생된 주요 엔티티는 업무적으로 다른 엔티티들을 파생시키기도 함
                    - 예: 주요 엔티티 '계약' -> '가입 계약, 납입 계약'
        - 행위(action) 엔티티
            - 두 개 이상의 상위 엔티티를 가짐
            - 내용이 자주 바뀌거나 데이터 양이 증가함
            - 분석 초기보다는 이후 상세 설계 과정에서 도출될 수 있음

### 핵심 엔티티 후보군 수집
- 기존 시스템 문서로부터 수집
    - 기존 시스템을 그대로 따르는 것이 아니라 참조만 하고, 현재 업무에서 그 엔티티 타입이 유효한지만을 검증하면 됨
    - 주로 업무처리가 명사화 되어있는 장표를 이용해서 엔티티 타입 도출
        - 이 외에도 현업 인터뷰, 데이터 흐름도, 유사 시스템, 현장 조사 등을 활용
- 과정
    1. 후보 엔티티의 명확한 개념 정립
        - "이 단어가 의미하는 진정한 집합이 무엇인가?"
    2. 현재 및 향후 관리 여부 확인
        - 현재 관리할 대상 뿐만 아니라 앞으로 관리하게 될 것들에 대한 전략적 판단 필요
    3. 집합 개념 여부 확인
        - 엔티티는 집합이어야 하지만, 모든 집합이 엔티티화 되는 것은 아님
- 후보 엔티티 식별 과정
    1. 기존 시스템 문서에서 '명사'형을 추출
    2. 포괄적인 업무 프로세스에 해당하는 명사를 비롯해 불분명하고 광범위한 개념 제거
        - 예: 회사, 취소, 확인
    3. 엔티티 타입의 특성이나 속성 제거
        - 예: 크기, 길이, 이름 등은 엔티티의 '세부 속성'이어야지 '엔티티'로 선정하기는 어려움
    4. 중복되는 명사 제거
        - 명사의 일반적인 사전적 의미와 특정 업계/산업/부서/업무에서 사용되는 의미가 다른 경우에 유의해야 함
    5. 누락된 엔티티 타입이 존재하는지 검토
    6. 도출된 엔티티들을 기본 엔티티와 주요 엔티티로 분류 수행
    7. 나머지 엔티티들을 행위 엔티티로 분류 수행
    8. 데이터 주제 영역별로 분류 수행
        - 예: 
            - 사람 -> 직원, 고객, 가입자, 회원 ...
            - 사건 -> 계약, 수주, 주문, 발주 ...
            - 재무 -> 입금, 청구, 차입금, 예적금...
    9. 핵심 엔티티로써의 조건을 만족하는지 확인하여 최종 선정 및 정의

### 식별자 (key)
- 어떠한 엔티티 집합에서 각각의 개별 엔티티들을 구분할 수 있는 고유한 결정자
    - 모든 엔티티들은 반드시 하나 이상의 식별자를 가지고 있어야 함
        - 예: 대한민국 국민이라면 누구나 가지고 있는 주민등록번호
    - 데이터 모델링이 오류 없이 수행되었는지를 판단하는 근거
    - 설계된 모델이 데이터베이스로써 실제로 구현이 될 때 primary key, foreign key 등의 역할을 수행하게 됨
- 의미
    - 핵심 엔티티의 주 식별자 결정에 따라 전체 데이터 모델의 복잡성이 결정됨
    - 시스템 구축 작업에서 매우 중요한 작업임
- 조건
    - 엔티티 집합의 모든 엔티티는 식별자에 의해서 유일하게 구분되어야 함
    - 특정 엔티티 타입에 식별자가 지정되면 해당 식별자는 변하지 않아야 함
    - 주 식별자가 지정이 되었다면 그 속성에는 반드시 어떠한 값이 존재해야 함
- 종류
    - 대표성 여부 기준
        - 주 식별자
            - 해당 업무에서 자주 이용되는 속성을 주 식별자로 지정함
                - 예: '사원' 엔티티 관리에 '사원번호' 속성을 주 식별자로 사용
            - 원칙 
                - 속성값의 길이가 가변적인 경우는 주 식별자로 부적합함
                    - 예: 각 부서를 구분하기 위해 '부서명'을 사용하는 것은 부적합함
                    - 이 경우 다른 마땅한 속성이 없다면 새로운 식별자를 생성해서 사용함
                        - 예: 각 부서를 구분하기 위해 '부서 번호'라는 식별자를 만들어 사용하고, '부서명'은 보조 식별자로 활용하는 방법
                - 속성값이 자주 변하는 속성은 주 식별자로 부적합함
                    - 예: 직원이 독자적으로 자주 바꿀 수 있는 '이메일 주소'를 주 식별자로 사용하는 것은 좋지 않음
                    - 주 식별자와 연동되는 모든 엔티티들로 그 영향이 파급되므로 시스템 전반에 악영향을 끼침
                - 주 식별자의 속성 수는 최소화하는 것이 좋음
                    - 주 식별자가 여러 속성들로 이루어진 복합 식별자인 경우, 해당 속성의 숫자가 7개를 넘지 않는 것이 좋음
                        - 예: '접수' 엔티티의 주 식별자 속성 = '접수일자', '담당부서', '지사', '접수방법', '신청인 구분' '신청인 이름', '신청횟수'
                        - 이 이상으로 숫자가 늘어나면 JOIN 연산이 복잡해질 수 있어서 성능 저하 유발
                    - 7개 이상의 속성이 필요한 경우 별도의 주 식별자를 생성하여 사용
                        - 예: '접수' 엔티티의 주 식별자로 '접수번호'를 새로 만들어서 사용
                - 주 식별자의 속성에는 반드시 실제로 값이 들어 있어야 함
                    - 예: '사원' 엔티티에 '사원번호'가 주 식별자인 경우, 모든 사원은 실제로 사원번호를 가지고 있어야 함
                    - 예: 외국 국적의 직원들은 '주민등록번호'를 가지고 있지 않고 대신 '외국인등록번호'를 가지고 있으므로, 다국적 조직에서의 사원 엔티티의 경우 '주민등록번호'를 주 식별자로 사용할 수 없음.
        - 대체/보조 식별자
            - 원래의 식별자를 대신할 수 있는 또다른 속성들이나 관계
                - 예: '사원' 엔티티에 공식적으로 부여된 '사원번호' 대신 '주민등록번호'를 식별자로 사용하는 경우
    - 생성된 기원 기준
        - 내부 식별자
        - 외부 식별자
    - 단일 속성 식별 여부
        - 단일 식별자
        - 복합 식별자
    - 대체 여부
        - 원조 식별자
        - 대리 식별자
    - 본질 식별자
        - 상속 관계를 규명해 올라갔을 때 최종적으로 최상위 기본 엔티티를 발견할 수 있는 식별자
            - 예: 본질 식별자 '고객번호, 상품코드' -> 행위 엔티티 '결제' -> 주요 엔티티 '신용카드' -> 기본 엔티티 '고객, 상품'
    - 인조 식별자
        - 기존의 본질 식별자를 실질적으로 사용하거나 인정할 수 없는 경우가 발생했을 때 이를 일부/전부 대체해 새롭게 구성한 식별자
            - 예: '주민등록번호' 식별자를 사용하기에 너무 길어서 이보다 짧은 '사원번호'를 공식 식별자로 대체하는 경우
    - 후보 식별자
        - 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성들의 집합
    - 실질 식별자
        - 인스턴스를 식별하기 위해 공식적으로 부여된 식별자
        - 본질 식별자와 인조 식별자 모두가 실질 식별자가 될 수 있음
