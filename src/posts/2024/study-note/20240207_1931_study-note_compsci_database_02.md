---
title: "[필기] 컴퓨터공학과 <데이터베이스> 과목 - 후반부"
date: 2024-02-07T19:31
thumb: "database.jpg"
tags: 
    - ❮필기❯
    - 컴퓨터공학
    - 데이터베이스
    - DBMS
    - RDBMS
    - SQL
---

# 4. 관계 (relationship)

## 4-1. 관계의 개념
- 데이터 모델에서의 정의
    - 엔티티 사이의 논리적인 연관성
    - 존재의 형태나 행위로써 서로에게 연관성이 부여된 상태
    - 엔티티 안에 있는 인스턴스가 개별적으로 연관 관계를 가지고 있음
        - 이것들의 집합을 '관계'라고 표현함
        - 각 인스턴스가 각각 다른 종류의 관계를 가지는 경우 두 엔티티 사이에 두 개 이상의 관계가 형성될 수 있음
    - 개체 = 논리적으로 표현된 '인스턴스의 집합'
    - 관계 = 논리적으로 표현된 '관계 페어링(pairing)과 어커런스(occurrence)'
- 관계의 분류
    - 존재에 의한 관계
        - 특정 이벤트를 필요로 하지 않고 자연적인 존재상태에 의해 발생하는 관계
            - 주로 '기본 식별자/엔티티'가 여기에 해당됨
        - 예: '총무과'에 '김진성 사원'이 소속되어 있음
    - 행위에 의한 관계
        - 특정 사건/이벤트/행위에 의해 발생하는 관계
            - 주로 '주요/행위 식별자/엔티티'가 여기에 해당됨
        - 예: 고객이 카드 결제를 시도해서 '승인번호'가 생성됨
            - '카드 결제'라는 행위로 인해 발생
- 관계 표현
    - 이항(binary) 관계
        - 예: '강의'가 '교수'와 '과목'과 연결되어 있는 경우
    - 삼항(ternary) 관계
        - 예: '소속'이 '교수'와 '학과'와 '학생'과 연결되어 있는 경우
    - N항(N-ary) 관계
        - 실제로 나타나는 경우는 거의 없음
- 멤버십 (membership)
    - 각 관계에는 두 개의 상호 연결, 즉 '멤버십'이 나타나고, 두 가지의 관점으로써 표현됨
        - 예: '총무과'는 '김진형 사원'을 포함 = '김진형 사원'은 '총무과'에 소속
        - 관계의 시작점 = 엔티티에서 관계가 시작되는 쪽
        - 관계의 끝점 = 엔티티에서 관계를 받는 쪽
- 관계명
    - 관점에 따라 능동적이거나 수동적으로 명명됨
    - 원칙
        - 현재형으로 표현할 것
            - 예: '수강신청 예정'이 아닌 '수강신청'
        - 애매한 동사를 피할 것
            - 예: '회계 관련 업무'가 아닌 '회계 업무'
- 관계의 선택성
    - "관계에 참여하는 엔티티 집합의 인스턴스가 항상 관계에 참여해야 하는가?"의 여부
        - 필수(mandatory) or 선택(optional)
        - 여기서 '선택' 참여 처리되는 속성은 foreign key로 참조될 경우 null값을 허용할 수 있게 됨
    - 만약 선택참여로 지정해야 할 관계를 필수참여로 지정해버리면?
        - 데이터가 발생하면 이를 반드시 한 개의 트랜잭션으로써 제어해야 하는 제약사항이 생기는 문제가 발생함
        - 관계의 선택 사양 설정을 잘못하면 참조 무결성 제약조건에 영향을 미칠 수 있음
        - 비즈니스 로직 개발에 큰 영향을 미치므로 설계 과정에서 신중하게 결정해야 함

### 관계의 차수
- 두 엔티티간 관계에서의 '참여자의 수'를 의미함
- one-to-many (1:M)
    - 가장 흔하게 나타나는 매우 일반적인 형태
    - 부모-자식 관계처럼 계층적이라고 이해하면 쉬움
    - 참조하는 대상이 상위 항목이어야 집합에 변화가 생기지 않으므로, many가 아니라 one을 참조하는 관계
        - 필수-필수 관계
            - 현실에서 가끔 발생하는 형태
            - 예: '구매'라는 업무에 있어서 하나의 '주문'이 한 개 이상의 '제품'들을 반드시 포함해야만 하는 경우
                - 주문이 발생하면 제품도 반드시 존재해야 함 = 구입할 제품이 없는 주문은 의미가 없음
                - 구매할 제품이 있다면 주문도 발생해야 함 = 주문이 없는 제품은 구매의 의미가 없음
        - 선택-필수 관계
            - 가장 흔하게 발생하는 형태
            - 예: '인사관리' 업무에 있어서 하나의 '부서'와 한 명 이상의 '사원'들의 관계
                - 모든 부서가 '사원'을 포함하지는 않으나, = 선택
                    - 신생 부서의 경우 사원이 없을 수 있음
                - 모든 '사원'은 어떠한 '부서'에든 속해야 함 = 필수
        - 필수-선택 관계
            - 현실에서 가끔 발생하는 형태
            - 예: 여러 구매자들이 모여 그 규모에 비례하는 할인율로 특정 제품을 구입하는 '소셜 공동구매'라는 업무에 있어서, 하나의 '상품'과 한 명 이상의 '고객'들의 관계 
                - 소셜 공동구매를 통해 판매가 이루어져야 할 '상품'은 반드시 존재해야 하지만, = 필수 
                - 모든 고객들이 해당 상품을 구매해야 하는 것은 아님 = 선택
                    - 제품 구매 의사에 따라 고객은 소셜 공동구매에 참여를 할 수도 있고 안할 수도 있음
                    - 소셜 공동구매에 참여할 고객의 목록이 최종 결정되고 나서야 상품 판매가 의미를 가짐
        - 선택-선택 관계
            - 흔하게 발생하는 형태
            - 관계의 선택성이 증가할수록 모델의 모호성이 증가될 수 있으므로 이를 해소해야 함
            - 예: '여행상품 판매'에 있어서 '고객'과 '예약'의 관계
                - 고객이 없더라도 예약을 미리 잡을 수 있음
                - 예약이 없더라도 고객은 존재할 수 있음
- one-to-one (1:1)
    - 엔티티 타입이 독립적으로 분리되면서 상호간에 하나의 관계만 성립함
        - 필수-선택 관계
            - 한 엔티티에 대응되는 상대 엔티티는 반드시 존재하나, 그 반대는 존재하지 않을수도 있음
        - 필수-필수 관계
            - 두 엔티티가 같은 경우
        - 선택-선택 관계
            - 거의 발생하지 않음
    - 현실적으로 흔하게 나타나지는 않음
    - 개체의 수직 분할에서 많이 나타나며, 업무 흐름에 따라 데이터가 설계된 형태에서 주로 발생
- many-to-many (M:M)
    - 관계를 가진 양쪽 당사자 모두에서 1:M 관계가 존재하는 형태
    - 데이터 모델링이 완료되었다면 M:M 관계는 더이상 존재하지 않음
        - M:M 관계가 발견되었다면 데이터 모델링이 완전하지 않은 상태이므로 M:M 관계를 해소해야 함
        - M:M 관계를 해소하면 새로운 릴레이션 엔티티가 생성되게 됨

## 4-2. 관계 도출

### 관계 정의 과정
1. 관계를 정의할 수 있는 두 핵심 엔티티간의 관계를 도출
    - 두 엔티티간에 업무적 연관성을 가지고 쌍방의 관점을 가지고 있는 핵심 엔티티를 선정
        - 기존 시스템 문서에서 동사 구분
        - 도출된 핵심 엔티티와 관계를 이용해 관계 정의 작성 후 세분화
2. 핵심 엔티티간의 관계성을 정의
    - 관계를 통해 정보의 활용가치를 상승시키도록 정합성을 유지
    - 기수성/차수/degree/cardinality를 검토
        - one or many
    - 선택성을 검토
        - 주로 one(선택/referenced)-to-many(필수/referencing) 관계가 가장 흔함
        - one쪽 엔티티에 many쪽 엔티티들이 필수적으로 참여하도록 설계하는 것이 바람직함
    - 관계명 정의
        - 두 개의 관계 멤버십에 상대방 입장에서의 관계명을 기술하도록 각각 부여
        - 업무적 연관성을 나타내는 이름을 현업에서 사용하는 간결한 현재 시제 동사형으로 부여
        - 업무적 의미가 없거나 애매모호한 용어 배제
3. 식별 관계 설정
    - 식별 관계 = 강한 엔티티와 약한 엔티티의 관계 = 존재/존속 관계
        - 식별 = 부모 엔티티의 식별자가 자식 엔티티의 주 식별자의 일부가 되는 경우
        - 비식별 = 부모 엔티티의 주 식별자가 자식 엔티티의 non-key 영역으로 이주하고 자식을 식별하는 데 관여하지 않음
4. 관계의 성격을 구분해 관계를 확정하기
    1. 관계 도출해내기
        - 엔티티 타입 도출에 사용되었던 6가지 방법과 동일 
            - 엔티티가 '명사형'이라면 관계는 '동사형'으로써 구분될 수 있음
                - 예: 학원
                    - 강사는 여러개의 강좌를 강의할 수 있다.
                    - 학원에서는 여러 명의 강사를 관리한다.
                    - 학원해서 개설한 강좌는 강사 1명이 강의를 진행한다.
                    - 동사: 강의한다, 관리한다, 개설한다
            - 이를 관계 정의서 또는 ERD로 표현한 후 정제 과정을 거침
        - 관계라는 것은 기존 업무 문서에 정확하게 기술되어 있는 경우는 거의 없으므로 내용을 보고 관계를 유추해내야 함
    2. 도출된 엔티티들과 관계를 기반으로 관계 정의서를 작성
        - 예: '사원' 엔티티 타입의 관계 정의서
            - 관계: 각 사원은 한 부서에 속한다. 각 부서에는 여러 사원들이 존재할 수 있다.
                - 참여: 사원(필수) - 부서(선택)
                - 관련 엔티티 타입: 부서
            - 관계: 각 사원은 여러 주문을 접수할 수 있다. 각 주문은 한 명의 사원에 의해서만 접수된다.
                - 참여: 사원(선택) - 주문(필수)
                - 관련 엔티티 타입: 주문
    3. 고객에게 질문과 인터뷰를 통해 도출된 관계를 세분화/구체화하기
        - "각 (기준 엔티티)는 (하나의 or 여러) (관련 개체) (만/항상) (소속할/소속될) 수 있는가?"
            - "각 (엔티티1)은 하나의 (엔티티2)에 속합니까?" = 1:1?
            - "각 (엔티티1)은 여러 (엔티티2)에도 소속될 수 있습니까? = 1:M?
            - "각 (엔티티1)은 (엔티티2)에 속하지 않을 수도 있습니까?" = 선택참여/필수참여? 
    4. 데이터 모델링 도구 등을 이용해 모델을 직접 그려보기
        - 의사소통 향상
        - 엔티티 타입 배치 용이
        - 관계 설정/수정이 쉬움
    5. 고객과 질문하고 협의해 모델을 검토
        - ERD를 그리기 전에는 고객과 인터뷰를 진행
        - ERD를 그리고 나면 관계가 정확히 설정되었는지, 누락된 것은 없는지 고객과 검토
        - 고객의 의견을 모두 반영해야 하는 것은 아님
            - 현업 현직자들은 현재의 업무 흐름에 익숙해져 있으므로 변화에 보수적일 수 있음

### 관계 검토
- 엔티티 타입간의 업무적 연관성을 정의한 결과물을 검증해야 할 필요가 있음
- 엔티티 타입간에 M:M 관계가 남아있는가?
    - M:M 관계는 남아있지 않아야 함
        - 프로젝트를 진행하던 도중 도출되지 않은 업무 규칙이 발견되거나, 업무 규칙이 새로 추가되는 상황에서 발생함
        - 관계 타입을 발생시키는 업무 규칙이 발견되었다면 일단 무조건 ERD상에 표현해야 함
        - 그리고 나서 관계 타입이 반드시 별도로 존재해야 하는지를 검토
    - 해소 방법
        - 관계 타입의 분리
            - 예: 요금 납부 업무
                - 하나의 요금이 여러번 납부될 수 있음 = 1:M
                - 여러 요금이 한 번에 납부될 수 있음 = M:1
                - 이렇게 M:M 관계가 발생한 경우 1:M 형식으로 분리해서 해소를 해야 함
                    - 여기서는 엔티티 발생 순서대로 '요금'과 '납부'를 이어 붙여 명명한 새로운 '요금납부'라는 관계 타입을 만들어 분리함
                        - '요금'과 '요금납부' = 1:M
                        - '요금납부'와 '납부' = M:1
        - 주 식별자 통합
            - 관계 타입의 분리를 통해 M:M을 해소하게 되면 ERD가 복잡해질 수 있음
            - PK를 사용해 하나의 엔티티 타입으로 통합하는 방식으로도 해소가 가능함
                - 예: 요금 납부 업무
                    - 요금의 주 식별자 = 요금번호
                    - 납부의 주 식별자 = 납부번호
                        - 납부의 주 식별자를 '납부번호 + 요금 납부 순차 번호' 형식으로 바꾸면 됨
                            - 한 번의 납부로도 여러 요금고지서의 납부가 가능한 형태가 됨
            - 장점
                - 엔티티 타입의 통합을 통해 데이터 모델 복잡도 감소
                - 물리적 테이블에서 데이터를 가져올 때 여러 테이블에 대한 JOIN을 하지 않음
                - 트랜잭션 수가 적지만 반드시 업무에 필요한 경우에 적용함
            - 유의사항
                - 부모 엔티티와 자식 엔티티의 생사가 같아야만(존재 종속) 가능함
                - 통합되는 엔티티 타입의 속성이 많고, 데이터 수정이 빈번하며, 쓰기 작업 위주의 엔티티 타입에는 사용하기 어려움
                    - 데이터 수정이 빈번한 경우에는 여러 튜플에 대한 작업이 발생하므로 좋지 않음
                - 속성이 많아질 경우 데이터의 불필요한 반복과 중복이 발생
        - 부모 엔티티 타입에 대한 속성 추가
            - 예: 요금 납부 업무에서 만약 분할 납부가 최대 2번까지만 가능하다는 규칙이 있는 경우
                - 요금(요금번호) -> 요금(요금번호, 납부번호1 FK, 납부번호2 FK)
            - 유의사항
                - 해당 업무 규칙의 최대값이 지정되어 있고, 그것이 변경될 가능성이 낮아야 함
                    - 최대값이 3~4개 이상이거나 지속적으로 변동될 가능성이 크다면 이에 따라 애플리케이션도 변경되어야 하므로 확실한 경우에만 적용해야 함
- 엔티티 타입간의 관계는 업무 흐름과 프로토콜에 일치하는가?
    - 선택성 관련 이슈
        - 한쪽을 필수 관계로 지정하는 이유 = 참조하는 쪽에서 물리 테이블을 생성하면 FK로써 참조하기 때문
            - FK 참조 무결성을 보장하기 위함
        - 양쪽 모두를 선택 관계로 지정하는 경우는 모델의 모호성이 증가되므로 바람직하지는 않음
            - 다만 실무의 특수성으로 인해 불가피한 경우가 있음
    - 예: 사원에게 급여를 지급할 건이 발생되면 계산된 급여가 일단 급여 목록에 기록되고, 급여가 확정되면 그 때 전표가 자동 발생하는 업무 흐름
        - 전표(전표번호)와 급여(사원번호, 전표번호 FK)는 1(필수):1(필수) 관계일까? 
            - NO = 급여 지급건이 발생하더라도 그것이 확정되지 않는다면 전표가 생성되는 것이 아니므로 전표는 선택 참여 관계임 
- 업무 흐름에 비추어 봤을때, 도출되지 않거나 못한 관계가 남아있는가?
    - 엔티티 타입만 도출하고 관계 정의를 나중에 하려는 경우
        - 모델링을 수행하는 사람이 정확하게 인식하고 있는 경우라면 큰 문제는 없음
    - 단위 시스템간의 업무 연계가 정의되지 않은 경우
        - 매우 큰 문제가 됨
        - 팀 단위로 이루어지는 프로젝트 개발에서는 단위 시스탬 내부의 연계는 대부분 도출되나 타 시스템과의 연계에는 취약함
            - 시스템 통합 관점에서의 전사적 모델링 통합 작업이 필요함
- 관계에 대한 표현이 적절한 수준에서 이루어졌는가?
    - 엔티티 타입간의 PK들을 보면 마치 모든 엔티티 타입들과 관계를 가지고 있는 것처럼 그물망 형식으로 나타남
    - 코드라던가 통계와 같이, 업무 흐름에 관여하는 모습을 직접 나타내지 않더라도 상식적으로 알 수 있는 엔티티 타입의 관계는 생략함
        - 나머지 주요 업무 흐름에 관련된 관계를 정의해서 표현해야 함
    - PK를 상속받은 엔티티 타입과 조상 엔티티 타입간의 관계 연결
        - 예: 사원(사원번호) -> 급여이력(사원번호 FK) -> 수당이력(사원번호 FK)
            - 사원과 수당이력 사이의 관계만 표현하여 간소화

# 5. Entity-Relationship Model

## 5-1. 엔티티, 속성, 그리고 관계

### 엔티티
- 엔티티란 '지속적인 관심의 대상'이자 '동질성을 지닌 개체 또는 행위의 집합'을 의미함
    - 동질성 및 집합의 정의에 따라 엔티티/속성/관계의 구성과 정의도 달라짐
    - 이러한 집합에 대한 명확한 정의는 데이터 모델링에서 가장 핵심적인 사안임
        - "어떤 대상이 엔티티에 속하는지 속하지 않는지를 명확하게 구분할 수 있는가?"
- 엔티티 정의의 조건
    - 우리가 관리하고자 하는 것인가?
    - 가로와 세로를 가진 면적/집합의 개념인가?
        - 주로 명사로 표현되며, 집합으로써의 개념을 가짐
    - 대상들간에 동질성이 있는가?
    - 다른 엔티티들과 확연히 구분되는 독립성을 가지고 있는가?
    - 순수하게 엔티티로써 존재하거나, 또는 엔티티가 수행한 행위의 집합인가?
- 엔티티의 성질
    - 반드시 구축하고자 하는 시스템이나 업무에서 필요하고 또 관리하고자 하는 정보여야 함
    - 유일한 식별자에 의해 식별 가능해야 함
    - 영속적으로 존재하는 엔티티의 집합이어야 함
    - 업무 프로세스가 해당 엔티티를 반드시 이용해야 함
    - 엔티티는 반드시 속성을 포함해야 함
    - 엔티티는 반드시 다른 엔티티와 최소 한 개 이상의 관계를 맺어야 함
- 구성
    - 엔티티 타입 = 2개 이상의 엔티티가 존재하는 엔티티의 분류 집합
    - 엔티티 = 각 엔티티는 고유한 성격/특성을 표현하는 속성을 두 개 이상 지님
        - 인스턴스 = 엔티티 집합에서의 각 개체들을 의미함
            - 예: 직원 인스턴스 = 직원번호, 성명, 주민번호, 부서명, 입사일 ...
    - 속성 = 업무에 필요한 엔티티를 관리하고자 하는, 더는 분리되지 않는 최소 데이터 단위
        - 식별자 = 각 인스턴스를 지칭하거나 식별해주는 속성으로써, 하나 또는 그 이상의 속성으로 구성되어 있음
            - 예: 직원 인스턴스
                - 성명, 부서명, 입사일 등은 여러 직원들이 동일한 값을 가질 수 있으므로 식별성이 매우 낮음
                - 각 인스턴스를 고유하게 식별 가능한 '직원번호'와 '주민번호'를 식별자로써 사용할 수 있음
    - 속성값 = 엔티티가 표현하는 성격/특성의 실제 값으로써 하나의 속성은 오직 하나의 속성값만을 지님

### 속성
- 종류
    - 기본 속성
        - 업무 분석을 통해 바로 정의한 속성
            - 단, 업무로부터 분석한 속성이라고 하더라도 이미 업무상 코드로써 정의된 것들은 제외됨
        - 엔티티 타입에서 가장 일반적이고 많은 비중을 차지함
        - 일련번호와 같은 코드성 데이터라던가, 다른 속성으로부터 영향을 받아 생성된 속성을 제외한 모든 속성
    - 설계 속성
        - 원래 업무에는 존재하지 않지만 설계를 하면서 도출되는 속성
            - 업무를 규칙화하려고 속성을 새로 만들거나 변형해 정의하는 속성
        - 코드 속성은 원래 존재하던 다른 속성을 업무의 필요에 따라 변형해 만든 '설계 속성'으로 간주됨
            - 예를 들면 일련번호와 같은 속성은 유일성을 만족하는 식별자를 부여하기 위해서 새롭게 정의된 '설계 속성'임
    - 파생 속성
        - 다른 속성으로부터 계산되거나 변형되어 생성되는 속성
        - 다른 속성의 영향을 많이 받으므로 데이터 정합성을 유지하기 위해 유의해야 할 점들이 많음
            - 파생 속성은 가급적 적게 정의하는 것이 좋음
### 관계
- 관계란 엔티티간의 연관성을 의미함
    - 엔티티와 속성의 정의에 따라 영향을 받고 다양하게 변할 수 있음
    - 엔티티간의 수많은 논리적 관계 중에서 의미있고 관리할 관계만 선정해낸다는것은 쉽지 않음
- 대응수 (mapping cardinality)
    - ERD에서 엔티티와 연결될 때 대응(mapping)되는 수
    - 전체 참여 = 엔티티 집합에 속한 모든 엔티티 인스턴스들이 해당 관계에 참여함
        - 예: 모든 사원은 어떠한 부서에든 속해있어야 함
    - 부분 참여 = 엔티티 집합에 속한 모든 엔티티 인스턴스들이 해당 관계에 참여하는 것은 아님
        - 예: 모든 사원이 물류 업무에 속해있어야 하는 것은 아님

## 5-2. Entity-Relationship Diagram (ERD)

### ERD란?
- 각 업무별로 도출된 엔티티간의 관계를 이해하기 쉽도록, 도식화된 다이어그램으로써 표시하는 방법
    - 단순히 그림 역할을 하는 것이 아닌, 업무에서의 데이터 흐름과 프로세스의 연관성을 파악하는 중요한 산출물
    - 정보공학적 프로젝트 모델링에서는 해당 업무에 가장 적절한 ERD를 그려내는 것이 중요함
    - UML 표준 표기법을 사용하는 오브젝트 모델링에서는 해당 업무에 가장 적절한 클래스 다이어그램을 그려내는 것이 중요함
        - 오브젝트 모델링이라고 하더라도 관계형 데이터베이스를 대부분 사용하므로 ERD가 중요함
            - 이론적으로는 엔티티/관계/속성 등이 데이터 사전이나 산출물에 의해서 분석된 상태에서 ERD를 그림
            - 실무적으로는 분석된 엔티티/관계/속성이 바로 ERD에 표현되며, 이해관계자간 의사소통 과정에서 항상 이용됨
    - 데이터 모델링 초기 단계에서부터 모델을 지나치게 상세히 표현하려고 하면 추후 ERD를 이해하거나 다루기 힘들 수 있음
- 장점
    - 데이터 모델을 누구나 공통된 시각으로 파악할 수 있음
    - 원활한 의사소통이 가능함

### 초기 ERD 표기법 
- 초기 ERD의 특징
    - M:M 관계가 표현됨
    - N-ary 관계가 표현됨
        - 두 개 이상의 엔티티 타입이 하나의 관계에 관련될 수 있음
    - 다중 관계 표현
        - 두 엔티티 타입 사이에 둘 이상의 관계가 존재할 수 있음
    - 관계 타입도 속성을 가질 수 있음
- Chen 표기법
    - 1976년 Peter Chen에 의해 고안됨
    - 초기 표기법 중 하나로써 대학 교재 등에서 교육용으로 사용되며 실무에서는 사용되지 않음
- IDEF1X 표기법
    - 1970년대 미국 공군에 의해 도입됨
    - 마름모와 원을 사용하는 표기법
    - 실무에서는 드물게 사용됨
- 기타 표기법
    - ISO 표기법
        - 기수성을 조금 더 정교하게 표현
        - 거의 활용되지 않음
    - UML 표기법
        - 데이터 모델링에 사용되며 스테레오타입을 이용해 엔티티를 표현함

### Information Engineering (IE) Notation
- IE 표기법은 정보시스템 구축에 있어 데이터 분석과 데이터베이스 설계에 매우 유용한 기법
    - 1:M 관계에서 many쪽에 까마귀발 기호를 사용하므로 'Crow's Foot Model'이라고도 불림
- 표기 방법
    - 예시
        ```
         Entity A                                                             Entity B
          - child                                                              - parent
          - referencing                                                        - referenced
          - subject                                                            - object

          EMPLOYEE                                                             DEPARTMENT
        ┌────────────────┐                                                   ┌────────────────┐
        │ EMP_NO         │                                                   │ DEPT_NO        │
        │ -------------- │                                                   │ -------------- │
        │ NAME           │                                                   │ DEPT_TITLE     │
        │ ADDRESS        │ ∋┼Θ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ │ BRANCH         │
        │ DEPARTMENT     │                                                   │                │
        │ PHONE_NO       │                                                   └────────────────┘
        │ DEPT_NO (FK)   │ → Each of many employees         Each department ←
        │                │ → must have                   could possibly has ←
        └────────────────┘ → only one                    zero, one, or more ←
                           → department.                         employees. ←
        ```
    - 엔티티 타입
        - 직사각형을 그리고 직사각형 바깥 좌측 상단에 엔티티 타입 이름을 적음
        - 서브타입이 있는 경우,
            - 배타적 서브타입
                - 슈퍼타입은 최대 1개의 서브타입과 관련될 수 있음
                    - 예: 직원은 '정규직' 또는 '계약직'중 하나에만 속해야 함
                - 관계를 나타내는 실선 혹은 직선 가운데에다가 '속이 비어있는 위쪽 반원 (closed upper-half circle) 내부에 X를 그린 기호'를 사용해서 서브타입들을 분기
            - 포괄적 서브타입
                - 슈퍼타입은 1개 이상의 서브타입과 관련될 수 있음
                    - 예: 서류 제출은 '인터넷 제출'을 했더라도 추가 서류를 '방문 제출'로 다시 할 수 있음
                - 관계를 나타내는 실선 혹은 직선 가운데에다가 '속이 비어있는 위쪽 반원 (closed upper-half circle) 기호'를 사용해서 서브타입들을 분기
    - 속성
        - 직사각형 내부 좌측 상단에는 식별자를 적음
        - 식별자 아래에 수평선을 그어 나머지 속성들과 구분함
    - 관계
        - 선의 종류로써 식별 관계를 나타냄
            - 실선 = 식별 관계 = 관계를 통해 이주한 부모 엔티티의 식별자가 자식 엔티티의 주 식별자의 일부가 됨
                - 예: DEPT_NO가 EMPLOYEE 엔티티의 주 식별자로써 사용됨
            - 점선 = 비식별 관계 = 부모 엔티티의 주 식별자가 자식의 non-key 영역으로 이주하고, 자식을 식별하는 데 관계하지 않음
                - 예: DEPT_NO가 EMPLOYEE 엔티티의 외래키로써만 존재하고 주 식별자로 사용되지는 않음
        - 선 끝에 기호를 통해 관계 형태를 나타냄
            ```
            1:1 = 하나의 A는 하나의 B로 구성되어 있다
            [ENTITY A] ┼─────────────┼ [ENTITY B]     

            1:M = 하나의 A는 하나 이상의 B로 구성되어 있다
            [ENTITY A] ┼────────────┼∈ [ENTITY B]
            
            1:0 or 1:1 = 하나의 A는 0개 혹은 1개의 B로 구성되어 있다 
            [ENTITY A] ┼────────────Θ┼ [ENTITY B]

            1:0 or 1:1 or 1:M = 하나의 A는 0개, 1개, 혹은 여러개의 B로 구성되어 있다
            [ENTITY A] ┼───────────Θ┼∈ [ENTITY B]      M:M
            ```
        - 다중 관계
            - 병렬식
                - 두 엔티티 사이에 존재하는 관계들을 별도의 관계로 간주함
                    - 두 엔티티 사각형 사이에 여러 개의 선을 긋게 됨
            - 직렬식
                - 두 엔티티 사이에 존재하는 몇 개의 관계를 모아 상위 개념으로써 하나로 통합 관리함
                    - 이렇게 되면 M:M 관계가 발생하게 됨
                        ```
                        예: (고객) ∋───────────∈ (보험계약)
                        ```
                    - 이를 해소하기 위해 병렬로 정의되었던 여러 관계들을 모두 묶어 새로운 명칭의 관계로써 통합
                        ```
                        예: (보험계약 관련자) ─────<배타적 서브타입 기호>───── (계약자)(피보험자)(수익자)...
                        ```
                        - 이 경우 각각의 관계들이 서로 섞이지 않도록 하기 위해 서브타입 사용

### Barker's Notation
- 1980년대에 영국 컨설팅 기업 CACI에서 근무하던 Richard Barker에 의해 개발된 표기법
    - Oracle에서 Richard Barker의 Case*Method를 채택해서 사용
    - IE 표기법과 유사하나 일부 다름
- 표기 방법
    - 예시: 
        ```
         Entity A                                                         Entity B
          - child                                                          - parent
          - referencing                                                    - referenced
          - subject                                                        - object
        ┌────────────────┐                                               ┌────────────────┐
        │ EMPLOYEE       │                                               │ DEPARTMENT     │
        │                │                                               │                │
        │ # EMP_NO       │ ASSIGN                                        │ # DEPT_NO      │
        │ * NAME         │ ∋────────────────────── ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │ * DEPT_TITLE   │
        │ * DEPARTMENT   │                                        BELONG │ o BRANCH       │
        │ o PHONE_NO     │                                               └────────────────┘
        │ o ADDRESS      │ → Each of employees         Each department ←
        │ * DEPT_NO (FK) │ → must have              could possibly has ←
        └────────────────┘ → only one                      one or more ←
                           → department.                    employees. ←
        ```
    - 엔티티 타입
        - 둥근 모서리를 가진 사각형을 그리고, 사각형 내부 좌측 상단에 엔티티 타입 이름을 적음
        - 서브타입이 있는 경우에는 엔티티 사각형 내부에다가 또다른 사각형들을 그려서 표시
            - 서브타입은 서로 중복을 허락하지 않는 상호 배타적 관계
    - 속성 
        - 엔티티명 아래에다가 식별자를 비롯한 속성들의 이름을 목록으로 적어 내려감
        - 식별자에 해당되는 속성 이름 앞에다가는 식별자의 종류를 나타내는 기호를 붙여줌
            - `#` = 식별자에 해당되는 속성임을 표시
            - 논리적 모델링의 경우 반드시 (FK)를 표시해주어야 함
        - 식별자가 아닌 속성 이름 앞에다가는 속성값의 조건을 나타내는 기호를 붙여줌
            - `*` = mandatory = 해당 속성은 반드시 어떠한 값을 가져야 함
            - `o` = optional = 해당 속성에 값이 존재할 수도 있고 없을 수도 있음 (null값 허용)
    - 관계
        1. 해당 엔티티의 가까운 위치에 관계 구문을 기반으로 함
            - 관계 구문 구성
                1. (각 / 임의의 / 하나의) (엔티티1) 은
                2. (하나의 / 하나 이상의) (엔티티2)에 
                    - 1:1인지 1:M인지, 즉 관계 형태를 의미함
                3. (관계명)이 
                4. (반드시 되어야 한다 / 될 수도 있다)
                    - 필수 참여인지 선택 참여인지, 즉 관계 사양을 의미함
                - 한쪽 엔티티를 기준으로 상대 엔티티와의 관계를 규명하고, 반대로 다시 한번 규명함
                    - 예: 각 사원은 하나의 부서에 소속이 반드시 되어야 한다 / 각 부서는 하나 이상의 사원이 소속이 될 수도 있다
        2. 두 엔티티 타입을 나타내는 사각형 사이에다가 관계 형태와 관계 사양을 의미하는 선을 그어줌
            - 선의 종류로써 관계 사양을 나타냄
                - 실선 = 필수 참여
                - 점선 = 선택 참여
            - 선 끝에 기호를 통해 관계 형태를 나타냄
                ```
                [ENTITY A] ──────────────── [ENTITY B]      1:1 관계를 의미
                
                [ENTITY A] ───────────────∈ [ENTITY B]      1:M 관계를 의미

                [ENTITY A] ∋──────────────∈ [ENTITY B]      M:M 관계를 의미



                - 참고사항 - 

                ────┼∈ [ENTITY]
                이렇게 세로로 직선이 그어져 있는 것을 UID bar라고 하며, 
                식별자의 식별 관계와 종속성 등을 나타냄
                
                Case*Method에서는 UID bar를 사용하지 않고 생략함
                ```
        - 다중 관계
            - 병렬식
                - 두 엔티티 사이에 존재하는 관계들을 별도의 관계로 간주함
                    - 두 엔티티 사각형 사이에 여러 개의 선을 긋게 됨
            - 직렬식
                - 두 엔티티 사이에 존재하는 몇 개의 관계를 모아 상위 개념으로써 하나로 통합 관리함
                    - 이렇게 되면 M:M 관계가 발생하게 됨
                        ```
                        예: (제품) ∋───────────∈ (공급자)
                        ```
                    - 이를 해소하기 위해 병렬로 정의되었던 여러 관계들을 모두 묶어 새로운 명칭의 관계로써 통합
                        ```
                        예: (제품) ─ ─ ─ ─────∈ (제품공급목록) ∋───── ─ ─ ─ (공급자)
                        ```
                        - 이 경우 각각의 관계들이 서로 섞이지 않도록 하기 위해 서브타입 사용
            - 순환 관계
                - 하나의 엔티티가 자기 자신과 관계를 맺는 경우
                - 예: 여러 조직들이 트리 구조로 구성되어 있는 경우, 조직 속에 조직이 속하면서도 또한 조직이 조직을 구성되게 됨
            - 배타적(exclusive)/아크(arc) 관계
                - 어떤 엔티티가 두 개 이상의 다른 엔티티들의 합집합과 관계를 맺는 경우
                - 예: (출고) --- (공정)(창고)(외주 가공처)

# 6. 정규화 (normalization)

## 6-1. 정규화의 원칙

### 이상 상태