---
title: "[필기] 컴퓨터공학과 <데이터베이스> 과목 - 후반부"
date: 2024-02-07T19:31
thumb: "database.jpg"
tags: 
    - ❮필기❯
    - 컴퓨터공학
    - 데이터베이스
    - DBMS
    - RDBMS
    - SQL
---

# 5. Entity-Relationship Model

## 5-1. 엔티티, 속성, 그리고 관계

### 엔티티
- 엔티티란 '지속적인 관심의 대상'이자 '동질성을 지닌 개체 또는 행위의 집합'을 의미함
    - 동질성 및 집합의 정의에 따라 엔티티/속성/관계의 구성과 정의도 달라짐
    - 이러한 집합에 대한 명확한 정의는 데이터 모델링에서 가장 핵심적인 사안임
        - "어떤 대상이 엔티티에 속하는지 속하지 않는지를 명확하게 구분할 수 있는가?"
- 엔티티 정의의 조건
    - 우리가 관리하고자 하는 것인가?
    - 가로와 세로를 가진 면적/집합의 개념인가?
        - 주로 명사로 표현되며, 집합으로써의 개념을 가짐
    - 대상들간에 동질성이 있는가?
    - 다른 엔티티들과 확연히 구분되는 독립성을 가지고 있는가?
    - 순수하게 엔티티로써 존재하거나, 또는 엔티티가 수행한 행위의 집합인가?
- 엔티티의 성질
    - 반드시 구축하고자 하는 시스템이나 업무에서 필요하고 또 관리하고자 하는 정보여야 함
    - 유일한 식별자에 의해 식별 가능해야 함
    - 영속적으로 존재하는 엔티티의 집합이어야 함
    - 업무 프로세스가 해당 엔티티를 반드시 이용해야 함
    - 엔티티는 반드시 속성을 포함해야 함
    - 엔티티는 반드시 다른 엔티티와 최소 한 개 이상의 관계를 맺어야 함
- 엔티티의 구성
    - 엔티티 타입 = 2개 이상의 엔티티가 존재하는 엔티티의 분류 집합
    - 엔티티 = 각 엔티티는 고유한 성격/특성을 표현하는 속성을 두 개 이상 지님
        - 인스턴스 = 엔티티 집합에서의 각 개체들을 의미함
            - 예: 직원 인스턴스 = 직원번호, 성명, 주민번호, 부서명, 입사일 ...
    - 속성 = 업무에 필요한 엔티티를 관리하고자 하는, 더는 분리되지 않는 최소 데이터 단위
        - 식별자 = 각 인스턴스를 지칭하거나 식별해주는 속성으로써, 하나 또는 그 이상의 속성으로 구성되어 있음
            - 예: 직원 인스턴스
                - 성명, 부서명, 입사일 등은 여러 직원들이 동일한 값을 가질 수 있으므로 식별성이 매우 낮음
                - 각 인스턴스를 고유하게 식별 가능한 '직원번호'와 '주민번호'를 식별자로써 사용할 수 있음
    - 속성값 = 엔티티가 표현하는 성격/특성의 실제 값으로써 하나의 속성은 오직 하나의 속성값만을 지님

### 속성
- 속성의 종류
    - 기본 속성
        - 업무 분석을 통해 바로 정의한 속성
            - 단, 업무로부터 분석한 속성이라고 하더라도 이미 업무상 코드로써 정의된 것들은 제외됨
        - 엔티티 타입에서 가장 일반적이고 많은 비중을 차지함
        - 일련번호와 같은 코드성 데이터라던가, 다른 속성으로부터 영향을 받아 생성된 속성을 제외한 모든 속성
    - 설계 속성
        - 원래 업무에는 존재하지 않지만 설계를 하면서 도출되는 속성
            - 업무를 규칙화하려고 속성을 새로 만들거나 변형해 정의하는 속성
        - 코드 속성은 원래 존재하던 다른 속성을 업무의 필요에 따라 변형해 만든 '설계 속성'으로 간주됨
            - 예를 들면 일련번호와 같은 속성은 유일성을 만족하는 식별자를 부여하기 위해서 새롭게 정의된 '설계 속성'임
    - 파생 속성
        - 다른 속성으로부터 계산되거나 변형되어 생성되는 속성
        - 다른 속성의 영향을 많이 받으므로 데이터 정합성을 유지하기 위해 유의해야 할 점들이 많음
            - 파생 속성은 가급적 적게 정의하는 것이 좋음

### 관계
- 관계란 엔티티간의 연관성을 의미함
    - 엔티티와 속성의 정의에 따라 영향을 받고 다양하게 변할 수 있음
    - 엔티티간의 수많은 논리적 관계 중에서 의미있고 관리할 관계만 선정해낸다는것은 쉽지 않음
- 대응수 (mapping cardinality)
    - ERD에서 엔티티와 연결될 때 대응(mapping)되는 수
    - 전체 참여 = 엔티티 집합에 속한 모든 엔티티 인스턴스들이 해당 관계에 참여함
        - 예: 모든 사원은 어떠한 부서에든 속해있어야 함
    - 부분 참여 = 엔티티 집합에 속한 모든 엔티티 인스턴스들이 해당 관계에 참여하는 것은 아님
        - 예: 모든 사원이 물류 업무에 속해있어야 하는 것은 아님

## 5-2. Entity-Relationship Diagram (ERD)

### ERD란?
- 각 업무별로 도출된 엔티티간의 관계를 이해하기 쉽도록, 도식화된 다이어그램으로써 표시하는 방법
    - 단순히 그림 역할을 하는 것이 아닌, 업무에서의 데이터 흐름과 프로세스의 연관성을 파악하는 중요한 산출물
    - 정보공학적 프로젝트 모델링에서는 해당 업무에 가장 적절한 ERD를 그려내는 것이 중요함
    - UML 표준 표기법을 사용하는 오브젝트 모델링에서는 해당 업무에 가장 적절한 클래스 다이어그램을 그려내는 것이 중요함
        - 오브젝트 모델링이라고 하더라도 관계형 데이터베이스를 대부분 사용하므로 ERD가 중요함
            - 이론적으로는 엔티티/관계/속성 등이 데이터 사전이나 산출물에 의해서 분석된 상태에서 ERD를 그림
            - 실무적으로는 분석된 엔티티/관계/속성이 바로 ERD에 표현되며, 이해관계자간 의사소통 과정에서 항상 이용됨
    - 데이터 모델링 초기 단계에서부터 모델을 지나치게 상세히 표현하려고 하면 추후 ERD를 이해하거나 다루기 힘들 수 있음
- 장점
    - 데이터 모델을 누구나 공통된 시각으로 파악할 수 있음
    - 원활한 의사소통이 가능함

### 초기 ERD 표기법 
- 초기 ERD의 특징
    - M:M 관계가 표현됨
    - N-ary 관계가 표현됨
        - 두 개 이상의 엔티티 타입이 하나의 관계에 관련될 수 있음
    - 다중 관계 표현
        - 두 엔티티 타입 사이에 둘 이상의 관계가 존재할 수 있음
    - 관계 타입도 속성을 가질 수 있음
- Chen 표기법
    - 1976년 Peter Chen에 의해 고안됨
    - 초기 표기법 중 하나로써 대학 교재 등에서 교육용으로 사용되며 실무에서는 사용되지 않음
- IDEF1X 표기법
    - 1970년대 미국 공군에 의해 도입됨
    - 마름모와 원을 사용하는 표기법
    - 실무에서는 드물게 사용됨
- 기타 표기법
    - ISO 표기법
        - 기수성을 조금 더 정교하게 표현
        - 거의 활용되지 않음
    - UML 표기법
        - 데이터 모델링에 사용되며 스테레오타입을 이용해 엔티티를 표현함

### Information Engineering (IE) Notation
- IE 표기법은 정보시스템 구축에 있어 데이터 분석과 데이터베이스 설계에 매우 유용한 기법
    - 1:M 관계에서 many쪽에 까마귀발 기호를 사용하므로 'Crow's Foot Model'이라고도 불림
- 표기 방법
    - 예시
        ```
         Entity A                                                             Entity B
          - child                                                              - parent
          - referencing                                                        - referenced
          - subject                                                            - object

          EMPLOYEE                                                             DEPARTMENT
        ┌────────────────┐                                                   ┌────────────────┐
        │ EMP_NO         │                                                   │ DEPT_NO        │
        │ -------------- │                                                   │ -------------- │
        │ NAME           │                                                   │ DEPT_TITLE     │
        │ ADDRESS        │ ∋┼Θ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ │ BRANCH         │
        │ DEPARTMENT     │                                                   │                │
        │ PHONE_NO       │                                                   └────────────────┘
        │ DEPT_NO (FK)   │ → Each of many employees         Each department ←
        │                │ → must have                   could possibly has ←
        └────────────────┘ → only one                    zero, one, or more ←
                           → department.                         employees. ←
        ```
    - 엔티티 타입
        - 직사각형을 그리고 직사각형 바깥 좌측 상단에 엔티티 타입 이름을 적음
        - 서브타입이 있는 경우,
            - 배타적 서브타입
                - 슈퍼타입은 최대 1개의 서브타입과 관련될 수 있음
                    - 예: 직원은 '정규직' 또는 '계약직'중 하나에만 속해야 함
                - 관계를 나타내는 실선 혹은 직선 가운데에다가 '속이 비어있는 위쪽 반원 (closed upper-half circle) 내부에 X를 그린 기호'를 사용해서 서브타입들을 분기
            - 포괄적 서브타입
                - 슈퍼타입은 1개 이상의 서브타입과 관련될 수 있음
                    - 예: 서류 제출은 '인터넷 제출'을 했더라도 추가 서류를 '방문 제출'로 다시 할 수 있음
                - 관계를 나타내는 실선 혹은 직선 가운데에다가 '속이 비어있는 위쪽 반원 (closed upper-half circle) 기호'를 사용해서 서브타입들을 분기
    - 속성
        - 직사각형 내부 좌측 상단에는 식별자를 적음
        - 식별자 아래에 수평선을 그어 나머지 속성들과 구분함
    - 관계
        - 선의 종류로써 식별 관계를 나타냄
            - 실선 = 식별 관계 = 관계를 통해 이주한 부모 엔티티의 식별자가 자식 엔티티의 주 식별자의 일부가 됨
                - 예: DEPT_NO가 EMPLOYEE 엔티티의 주 식별자로써 사용됨
            - 점선 = 비식별 관계 = 부모 엔티티의 주 식별자가 자식의 non-key 영역으로 이주하고, 자식을 식별하는 데 관계하지 않음
                - 예: DEPT_NO가 EMPLOYEE 엔티티의 외래키로써만 존재하고 주 식별자로 사용되지는 않음
        - 선 끝에 기호를 통해 관계 형태를 나타냄
            ```
            1:1 = 하나의 A는 하나의 B로 구성되어 있다
            [ENTITY A] ┼─────────────┼ [ENTITY B]     

            1:M = 하나의 A는 하나 이상의 B로 구성되어 있다
            [ENTITY A] ┼────────────┼∈ [ENTITY B]
            
            1:0 or 1:1 = 하나의 A는 0개 혹은 1개의 B로 구성되어 있다 
            [ENTITY A] ┼────────────Θ┼ [ENTITY B]

            1:0 or 1:1 or 1:M = 하나의 A는 0개, 1개, 혹은 여러개의 B로 구성되어 있다
            [ENTITY A] ┼───────────Θ┼∈ [ENTITY B]
            ```
        - 다중 관계
            - 병렬식
                - 두 엔티티 사이에 존재하는 관계들을 별도의 관계로 간주함
                    - 두 엔티티 사각형 사이에 여러 개의 선을 긋게 됨
            - 직렬식
                - 두 엔티티 사이에 존재하는 몇 개의 관계를 모아 상위 개념으로써 하나로 통합 관리함
                    - 이렇게 되면 M:M 관계가 발생하게 됨
                        ```
                        예: (고객) ∋───────────∈ (보험계약)
                        ```
                    - 이를 해소하기 위해 병렬로 정의되었던 여러 관계들을 모두 묶어 새로운 명칭의 관계로써 통합
                        ```
                        예: (보험계약 관련자) ─────<배타적 서브타입 기호>───── (계약자)(피보험자)(수익자)...
                        ```
                        - 이 경우 각각의 관계들이 서로 섞이지 않도록 하기 위해 서브타입 사용

### Barker's Notation
- 1980년대에 영국 컨설팅 기업 CACI에서 근무하던 Richard Barker에 의해 개발된 표기법
    - Oracle에서 Richard Barker의 Case*Method를 채택해서 사용
    - IE 표기법과 유사하나 일부 다름
- 표기 방법
    - 예시: 
        ```
         Entity A                                                         Entity B
          - child                                                          - parent
          - referencing                                                    - referenced
          - subject                                                        - object
        ┌────────────────┐                                               ┌────────────────┐
        │ EMPLOYEE       │                                               │ DEPARTMENT     │
        │                │                                               │                │
        │ # EMP_NO       │ ASSIGN                                        │ # DEPT_NO      │
        │ * NAME         │ ∋────────────────────── ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ │ * DEPT_TITLE   │
        │ * DEPARTMENT   │                                        BELONG │ o BRANCH       │
        │ o PHONE_NO     │                                               └────────────────┘
        │ o ADDRESS      │ → Each of employees         Each department ←
        │ * DEPT_NO (FK) │ → must have              could possibly has ←
        └────────────────┘ → only one                      one or more ←
                           → department.                    employees. ←
        ```
    - 엔티티 타입
        - 둥근 모서리를 가진 사각형을 그리고, 사각형 내부 좌측 상단에 엔티티 타입 이름을 적음
        - 서브타입이 있는 경우에는 엔티티 사각형 내부에다가 또다른 사각형들을 그려서 표시
            - 서브타입은 서로 중복을 허락하지 않는 상호 배타적 관계
    - 속성 
        - 엔티티명 아래에다가 식별자를 비롯한 속성들의 이름을 목록으로 적어 내려감
        - 식별자에 해당되는 속성 이름 앞에다가는 식별자의 종류를 나타내는 기호를 붙여줌
            - `#` = 식별자에 해당되는 속성임을 표시
            - 논리적 모델링의 경우 반드시 (FK)를 표시해주어야 함
        - 식별자가 아닌 속성 이름 앞에다가는 속성값의 조건을 나타내는 기호를 붙여줌
            - `*` = mandatory = 해당 속성은 반드시 어떠한 값을 가져야 함
            - `o` = optional = 해당 속성에 값이 존재할 수도 있고 없을 수도 있음 (null값 허용)
    - 관계
        1. 해당 엔티티의 가까운 위치에 관계 구문을 기반으로 함
            - 관계 구문 구성
                1. (각 / 임의의 / 하나의) (엔티티1) 은
                2. (하나의 / 하나 이상의) (엔티티2)에 
                    - 1:1인지 1:M인지, 즉 관계 형태를 의미함
                3. (관계명)이 
                4. (반드시 되어야 한다 / 될 수도 있다)
                    - 필수 참여인지 선택 참여인지, 즉 관계 사양을 의미함
                - 한쪽 엔티티를 기준으로 상대 엔티티와의 관계를 규명하고, 반대로 다시 한번 규명함
                    - 예: 각 사원은 하나의 부서에 소속이 반드시 되어야 한다 / 각 부서는 하나 이상의 사원이 소속이 될 수도 있다
        2. 두 엔티티 타입을 나타내는 사각형 사이에다가 관계 형태와 관계 사양을 의미하는 선을 그어줌
            - 선의 종류로써 관계 사양을 나타냄
                - 실선 = 필수 참여
                - 점선 = 선택 참여
            - 선 끝에 기호를 통해 관계 형태를 나타냄
                ```
                [ENTITY A] ──────────────── [ENTITY B]      1:1 관계를 의미
                
                [ENTITY A] ───────────────∈ [ENTITY B]      1:M 관계를 의미

                [ENTITY A] ∋──────────────∈ [ENTITY B]      M:M 관계를 의미



                - 참고사항 - 

                ────┼∈ [ENTITY]
                이렇게 세로로 직선이 그어져 있는 것을 UID bar라고 하며, 
                식별자의 식별 관계와 종속성 등을 나타냄
                
                Case*Method에서는 UID bar를 사용하지 않고 생략함
                ```
        - 다중 관계
            - 병렬식
                - 두 엔티티 사이에 존재하는 관계들을 별도의 관계로 간주함
                    - 두 엔티티 사각형 사이에 여러 개의 선을 긋게 됨
            - 직렬식
                - 두 엔티티 사이에 존재하는 몇 개의 관계를 모아 상위 개념으로써 하나로 통합 관리함
                    - 이렇게 되면 M:M 관계가 발생하게 됨
                        ```
                        예: (제품) ∋───────────∈ (공급자)
                        ```
                    - 이를 해소하기 위해 병렬로 정의되었던 여러 관계들을 모두 묶어 새로운 명칭의 관계로써 통합
                        ```
                        예: (제품) ─ ─ ─ ─────∈ (제품공급목록) ∋───── ─ ─ ─ (공급자)
                        ```
                        - 이 경우 각각의 관계들이 서로 섞이지 않도록 하기 위해 서브타입 사용
            - 순환 관계
                - 하나의 엔티티가 자기 자신과 관계를 맺는 경우
                - 예: 여러 조직들이 트리 구조로 구성되어 있는 경우, 조직 속에 조직이 속하면서도 또한 조직이 조직을 구성되게 됨
            - 배타적(exclusive)/아크(arc) 관계
                - 어떤 엔티티가 두 개 이상의 다른 엔티티들의 합집합과 관계를 맺는 경우
                - 예: (출고) --- (공정)(창고)(외주 가공처)

---

# 6. 정규화 (normalization)

## 6-1. 이상 상태 (anomaly)

### 바람직한 데이터베이스란
- 하나의 릴레이션에 속한 각 튜플은 실세계에 존재하는 하나의 엔티티만을 표현해야 함
- 릴레이션의 각 튜플은 하나의 엔티티 또는 관계 인스턴스를 표현해야만 함
- 서로 다른 엔티티들의 속성은 하나의 테이블에 섞여서 나타나면 안됨
- 다른 엔티티를 참조하기 위해서는 외래키를 사용해야만 함
- '엔티티'와 '관계'는 최대한 서로 분리시켜야 함

### 이상 상태
- 실제 DB 운영 시 직면하는 문제
    - 대량의 운영 데이터를 어떻게 조직하고 효율적으로 관리할 것인가?
    - 관계형 모델을 어떻게 이용해 실세계를 잘 표현할 것인가?
    - DB 내에 어떤 릴레이션들이 필요하며, 각 릴레이션은 어떤 속성들로 구성할 것인가?
- 속성들 사이의 관계성을 제대로 고려하지 않으면 실제 데이터 처리 과정에서 이상 상태가 발생
    - 예: 수강(학번, 과목명, 성적, 학년) 릴레이션
        ```
        STUDENT_NO      SUBJECT          GRADE      YEAR
        ------------------------------------------------
        013             ECON_0027        85         1
        013             ECON_8248        90         1
        014             PHYS_1210        77         2
        014             PHYS_1941        86         2
        015             BCHM_3503        92         4
        ```
    - 중복된 데이터의 저장이 발생됨
        - = 릴레이션의 어떠한 튜플이 여러개의 엔티티를 표현하고 있음
            - 저장 공간이 낭비됨 
            - 처리 작업에서 이상 상태 발생
- 이상상태의 종류
    - 삽입 이상
        - 특정 정보를 추가하기 위해서는 원하지 않는 다른 정보도 함께 추가할 수밖에 없도록 잘못 설계된 경우에 발생
            - 예: 새로운 016번 학생의 학년을 입력하기 위해서는 어쩔 수 없이 수강하지도 않는 과목명과 있지도 않은 성적을 입력해야 함
    - 삭제 이상
        - 특정 정보를 삭제하기 위해서는 다른 정보도 함께 연쇄적으로 삭제(triggered deletion)되게끔 잘못 설계되어 정보 손실이 발생하는 경우
            - 예: 015번 학생이 BCHM_3503 과목의 최종 성적 및 수료를 중도 포기해 해당 튜플을 삭제할 경우, 해당 학생의 학년 정보도 같이 사라져버림
    - 변경/갱신 이상
        - 특정 정보를 변경하거나 갱신하기 위해서는 다른 정보도 모두 바꾸어줘야만 되게끔 잘못 설계된 경우에 발생
            - 예: 013번 학생의 학년이 1학년으로 잘못 입력되어 있어 이를 3학년으로 바꾸어야 하는 경우, 두 개의 튜플을 모두 바꾸어주어야 함
        - 중복 데이터의 일부 갱신에 따른 불일치(inconsistency) 문제가 발생할 수 있음
- 이상상태의 원인
    - 릴레이션의 어떠한 튜플이 여러 개의 엔티티에 대한 정보를 담고 있음
    - 릴레이션 내에 여러 속성들간의 연관성이 중복되어 나타남
        - 예: 수강(학번, 과목명, 성적, 학년) 릴레이션
            - 014번 학생의 성적 엔티티와 학년 엔티티가 혼재되어 나타남
- 이상상태의 해결
    - 속성들 간의 여러 연관 관계를 분해해 별개의 릴레이션으로 표현해주어야 함
        - 하나의 연관 관계는 하나의 릴레이션에서만 나타나도록 설계해주는 과정을 정규화(normalization)이라고 함
            - 일련의 제약조건을 만족하는 릴레이션을 '정규형(normal form)'이라고 함
            - 정규화란 '스키마 변환을 통해 정규형을 만들어주는 것'을 의미

## 6-1. 정규화와 정규형

### 정규화
- 정규화의 목적
    - 데이터의 삽입/삭제/변경시에 발생하는 이상 상태를 릴레이션을 분해함으로써 해결하기 위함
        - 데이터를 검색할 때는 이상 상태가 발견되지 않음
    - 다만 릴레이션들이 분해되므로, 검색을 통해 원하는 정보를 얻기 위해서는 오버헤드가 큰 JOIN 연산이 필요하게 됨
        - 따라서 데이터 처리 과정에서 이상 상태가 발견되지 않는다면 굳이 정규화를 할 필요가 없음!
- 정규화의 종류
    - 함수 종속에 기반한 정규화 과정
        - 제1정규형 = 1NF
        - 제2정규형 = 2NF
        - 제3정규형 = 3NF
        - BCNF
    - 다치 종속과 조인 종속에 기반한 고급 정규화 과정
        - 제4정규형 = 4NF
        - 제5정규형 = 5NF
- 정규화의 원칙
    - 정보 표현의 무손실
        - 스키마를 변환할 때 정보의 손실이 있어서는 안됨
        - 변환 전 스키마가 포함하고 있던 모든 정보는 변환된 스키마도 포함하고 있어야 함
    - 데이터 중복의 최소화
    - 분리의 원칙
        - 하나의 독립된 관계성은 별도의 분리된 릴레이션으로 표현함
        - 각 릴레이션을 독립적으로 처리할 수 있는 기초가 됨
    - 무손실 분해/조인
        - 분해된 테이블들을 모두 합쳐 자연 조인했을 때 추가적인 튜플이 생성되지 않아야 함
        - 원본 릴레이션에서 얻을 수 있는 정보는 분해된 릴레이션들로부터도 얻을 수 있어야 함

### 제1정규형
- 모든 속성의 도메인이 원자값으로 이루어져 있는 릴레이션을 의미
    - 모든 관계형 릴레이션은 제1정규형을 만족함
        - 튜플의 유일성
        - 튜플의 무순서성
        - 속성의 원자성
        - 속성의 무순서성
- 제1정규형은 이상 상태를 발생시킬 수 있음
    - 이상상태 원인
        - 기본키로 식별되는 엔티티와는 무관한 정보들이 존재하기 때문
            - 기본키에 '부분 함수 종속'된 속성들이 존재함
        - 한 튜플 내에 여러 엔티티들이 혼재되어 나타나기 때문
        - 튜플 내에 여러개의 속성들간에 연관성이 있기 때문

### 제2정규형
- 제2정규형이란, '1NF를 만족하면서, 키에 속하지 않은 속성들이 모두 기본키에 '완전 함수 종속'된 경우'를 의미
    - 함수 종속(functional dependency)
        - X→Y = 결정자(determinant)인 속성 X의 값에 대해서 종속자(dependent)인 속성 Y의 값이 하나만 연관될 때, 속성 X는 속성 Y에 '함수 종속'된다고 표현함
            - 속성들간의 연관성을 의미함
        - 함수 종속의 분류
            - 완전 함수 종속 = X의 부분집합 X'에 대해서 X'→Y를 만족하는 X'가 존재하지 않을 때
            - 부분 함수 종속 = X의 부분집합 X'에 대해서 X'→Y를 만족하는 X'가 존재할 때
        - 함수 종속의 특징
            - 릴레이션에서 속성 X가 키인 경우, 모든 속성 Y에 대해서 X→Y 성립
                - 예: 기본키인 '학번' 속성의 값이 정해지면, 해당 학번에 대한 학생은 오직 하나만 존재함
            - X→Y가 성립할 때, 릴레이션에서 속성 X가 반드시 키여야 하는 것은 아님
                - 예: 만약 1학생 1전담강사 정책이 있다고 하면, '전담 강사' 속성이 키가 아니더라도 해당 전담 강사에 대한 학생은 오직 하나만 존재함
            - 속성 X의 어떠한 값에 대응되는 Y의 값을 가지는 튜플이 두 개 이상일 수 있음
                - 단, 여러 튜플들은 같은 값을 가지며 결과적으로 속성값은 하나만 존재함
- 1NF에 무손실 분해/조인을 적용해 2NF로 정규화
    - 제1정규형인 릴레이션 R(A, B, C)에서 함수 종속 B→C가 존재할 경우, R1(A, B)와 R2(B, C)로 프로젝션 분해하면 무손실 분해가 됨
        - 예: 학적 릴레이션 = 학번(PK), 과목명(CK), 지도교수, 학과명, 성적
            - 수강 릴레이션 = 학번(PK) / 과목명(CK) → 성적
            - 학과 릴레이션 = 학번 → 지도교수 → 학과명
- 제2정규형은 여전히 이상 상태를 발생시킬 수 있음
    - 이상상태 종류
        - 삽입 이상
            - 예: 학과 릴레이션에서 새로운 '학번'을 배정하지 않고는 학과를 만들 수 없음
        - 삭제 이상
            - 예: 학과 릴레이션에서 학생이 단 한명뿐인 학과의 경우, 해당 학생이 중퇴를 해서 학번이 사라지면 그 학생이 속한 학과도 함께 없어짐
        - 갱신 이상
            - 예: 학과 릴레이션에서 특정 학생의 학과가 변경될 경우, 해당 학과에 속한 다른 학생 역시 학과명이 변경되어야 함
    - 이상상태 원인
        - 기본키 이외의 다른 속성에 의해서 그 값이 결정되는 속성이 있기 때문
            - 예: 학과 릴레이션의 경우 학과명이 '학번'이 아닌 '지도교수'에 의해 결정되고 있음
            - 릴레이션에서 각 튜플은 하나의 엔티티 또는 관계 인스턴스를 표현해야만 함

### 제3정규형
- 제3정규형이란, '2NF를 만족하면서, 키가 아닌 속성들은 기본키에 이행적 함수 종속이 되지 않은 경우'를 의미
    - 이행적 종속 = if A→B & A→C, then A→C
    - R(A, B, C)를 분해한 제2정규형이라고 하더라도 A→B와 B→C 사이에 A→C인 함수 종속이 여전히 존재함
        - 예: 학과 릴레이션에서 '학번(PK)→성적'과 '지도교수→학과명'으로 나눴어도 '학번→학과명'이 존재
- 2NF에 무손실 분해를 적용해 이행적 함수 종속을 제거하고 3NF로 정규화
    - 예: 학과 릴레이션 = 학번 → 지도교수 → 학과명
        - 학과 릴레이션 = 학과명 → 지도교수
        - 학생 소속 릴레이션 = 학번 → 학과명
- (속성이 2개인) 이진 릴레이션은 기본적으로 제3정규형에 속함
    - 이행적 함수 종속이 발생하기 위해서는 A, B, C라는 최소한 3개의 속성이 필요하기 때문
    - 속성이 2개만 존재하면 이행적 함수 종속이 존재할 수 없음
- 제3정규형은 여전히 이상 상태를 발생시킬 수 있음
    - 이진 릴레이션이 아니더라도 제3정규형이 될 수 있기 때문
        - 복수의 후보키를 가지고 있음
        - 후보키들이 여러개의 속성들로 구성되어 있음
        - 후보키들의 속성이 서로 중첩되어 있음

### BCNF (Boyce-Codd normal form)
- BCNF이란, '3NF를 만족하면서 릴레이션에 속한 결정자가 후보키인 경우'를 의미
    - 모든 속성은 후보키에 의해 결정됨
    - 하나의 튜플은 하나의 엔티티를 표현함
- 관계형 데이터베이스 설계 목표는 바로 각 릴레이션이 BCNF를 만족하게 하는 것
    - BCNF = 강력한 3NF
    - 참고로 이진 릴레이션은 BCNF에도 속함

### 제4정규형
- 다치 종속 (multivalued dependency)
    - 속성 X의 값이 하나 결정될 때, 속성 Y의 여러 값들이 결정되는 경우 "X는 Y를 다중 결정한다"라고 함
    - 예: '과목'이 결정될 때, 해당 과목에 사용될 여러 '교재'들이 결정되는 경우
- 릴레이션 R의 모든 비단순 다치 종속 X→Y를 만족하는 속성 X,Y가 존재할 때, X가 R의 슈퍼키인 경우, 릴레이션 R은 제4정규형에 해당됨
- 4NF 특징
    - BCNF와 제3정규형과는 달리 제4정규형은 '다치 종속성'을 다룸
    - 제4정규형을 만족하는 모든 릴레이션은 BCNF 역시 만족함

### 제5정규형
- 조인 종속 (join dependency)
    - 릴레이션 R이 그 프로젝션 릴레이션인 R1, R2, R3, ..., Rn의 조인과 동일한 경우 "R은 조인 종속성을 만족한다"라고 함
- 릴레이션 R에 존재하는 모든 조인 종속에 대해, 모든 조인 종속 릴레이션이 R의 후보키라면, 릴레이션 R은 제5정규형에 해당됨
    - 조인 종속성을 발견하는 것은 매우 어려우므로 실무에서 5NF를 사용하는 경우는 거의 없음

---

# 7. Transaction & View

## 7-1. 트랜잭션

### 트랜잭션이란?
- 논리적인 일의 단위
    - 하나의 SQL문 = 하나의 트랜잭션 
    - 여러개의 SQL문들이 묶여 하나의 트랜잭션이 될 수 있음
- 트랜잭션이 필요한 이유
    - 동시성(concurrency) 제어
        - 다수의 사용자나 여러 애플리케이션들이 데이터베이스에 동시에 접근하고 연산이 수행되더라도, 서로 간섭하지 못하도록 제어해서 데이터베이스의 일관성을 유지함
        - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향이, 이들을 순차적으로 수행했을때와 동일하도록 보장해주는 역할
        - 트랜잭션 단위로 동시성을 제어할 수 있음
    - 회복
        - 데이터베이스를 갱신하는 도중 시스템 고장이 발생하더라도 데이터베이스의 일관성을 유지함
        - 트랜잭션 단위로 회복을 수행할 수 있음
- 트랜잭션 제어문(Transaction Control Language; TCL)을 사용함
    - COMMIT
        - 트랜잭션의 마지막 명령어가 수행됨
        - 트랜잭션에 의한 변경을 확정함
            - 철회 불가능
        - 명령문을 실행하기 전에, 하나의 트랜잭션을 변경한 결과를 다른 트랜잭션에서 접근할 수 없도록 방지해 일관성 유지
    - ROLLBACK
        - 트랜잭션의 변경을 취소하고 트랜잭션을 종료함
            - `ROLLBACK TRAN savepoint_name`
    - SAVEPOINT
        - 현재 트랜잭션으로부터 ROLLBACK시킬 위치를 지정
            - `SAVE TRAN savepoint_name`
        - 대규모 트랜잭션에서 오류가 발생하면 전체 트랜잭션을 취소시키는것이 큰 부담이 될 수 있음
            - 실패한 일정 부분만 취소시키기
- 트랜잭션 모드
    - 자동 커밋 트랜잭션
        - 하나의 명령문이 하나의 트랜잭션이 됨
        - MS-SQL 기본 모드
    - 명시적 트랜잭션
        - 명시적으로 사용자가 트랜잭션을 정의함
        - 예: `BEGIN TRAN ~ COMMIT(or ROLLBACK) TRAN`
    - 묵시적 트랜잭션
        - 자동 커밋 트랜잭션과 반대되는 개념
        - 사용자가 COMMIT/ROLLBACK TRAN을 입력하기 전까지, 복수개의 명령문을 기본적으로 하나의 트랜잭션으로 간주
            - BEGIN TRAN 명령이 필요 없음
        - 설정 방법
            - `SET IMPLICIT TRANSACTIONS {ON or OFF}`
            - 트랜잭션의 종료마다 사용자가 반드시 COMMIT/ROLLBACK 명령문을 실행시켜야 함

### ACID 원칙
- 트랜잭션이 만족해야 하는 4가지 특성
    - Atomicity = 원자성 
        - 한 트랜잭션 내의 모든 연산들은 '완전히 수행됨' 또는 '전혀 수행되지 않음' 중 하나의 상태만을 가짐
            - All or Nothing
        - 연산 처리 도중 시스템이 다운되더라도, DBMS의 회복 모듈은 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소하는 방법을 통해 트랜잭션의 원자성을 보장함
        - 완료된 트랜잭션이 갱신했던 사항은 트랜잭션의 영향을 다시 수행하는 방법을 통해 트랜잭션의 원자성을 보장함
    - Consistency = 일관성
        - 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면, 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
        - 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 이러한 일관성을 갖지 않을 수도 있음
        - DBMS에서 관리하는 '무결성 제약조건'과 관련이 있음
    - Isolation = 격리성
        - 한 트랜잭션이 데이터를 갱신하는 동안, 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
        - 다수의 트랜잭션들이 동시에 수행되더라도, 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
            - = 동시성 제어
        - DBMS의 동시성 제어 모듈은 다양한 고립 수준에 기반해 트랜잭션의 고립성을 보장함
    - Durability = 영속성
        - 일단 한 트랜잭션이 완료되면, 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
        - 완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 지속됨
        - DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장

### 트랜잭션의 상태
```
                                    The state where                            The state where
                                    the last command                           the transaction
                                    has been executed                          has been applied
                                  (PARTIAL COMPLETION)

 EXECUTE → [ EXECUTE COMMAND ] →         COMMIT         → [ OUTPUT TO DISK ] → [ COMPLETION ]
         ↘          ↓           
           [      ERROR      ] → [       FAILURE      ] →      ROLLBACK      → [ WITHDRAWAL ]
          (logical or hardware)     
                                    The state where                            The state where
                                    the transaction                            the transaction
                                    has been failed                            has been undo-ed

                                                                             (transaction pending)
                                                                             (transaction restart)
```
    - 부분 완료
        - COMMIT 명령문을 받은 상태
    - 완료
        - 모든 트랜잭션 결과를 DB에 반영한 상태
    - 실패
        - 트랜잭션의 실패
        - 실패 상태에 놓인 트랜잭션에 취할 수 있는 조치
            - 트랜잭션의 재시작
                - 하드웨어나 시스템 오류로 인해 철회된 트랜잭션은 다시 새로운 트랜잭션으로 취급되어 재시작됨
            - 트랜잭션의 폐기
                - 트랜잭션의 내부적 오류로 인해, 또는 취급하려는 데이터가 없기 때문에 철회된 트랜잭션은 폐기됨
    - 철회
        - ROLLBACK 명령문에 의해서, 트랜잭션의 모든 결과가 취소되고 트랜잭션 이전의 원래 상태로 돌려놓아진 상태

## 7-2. 뷰

### 뷰의 개념
- 하나 이상의 기본 테이블이나 다른 뷰를 이용해서 생성되는 '가상의 테이블'
    - 기본 테이블은 디스크에 공간이 할당되어 데이터를 저장함
    - 뷰의 경우에는 데이터 딕셔너리 테이블에 뷰에 대한 정의(SQL문)만 저장되므로 디스크 저장 공간 할당이 이루어지지 않음
    - 뷰를 활용하면 전체 데이터 중에서 일부만 접근할 수 있도록 할 수 있음
        - 뷰에 대한 수정 결과는 뷰를 정의한 기본 테이블에 적용됨
        - 뷰를 정의한 기본 테이블에서 정의된 무결성 제약조건은 그대로 유지됨
- 뷰의 필요성
    - 사용자마다 특정 객체만 조회할 수 있도록 할 필요가 있음
        - 모든 직원에 대한 정보를 모든 사원이 볼 수 있도록 해서는 안됨
    - 복잡한 쿼리문을 단순화할 수 있음
    - 데이터의 중복성을 최소화할 수 있음
        - 예: 회계 부서에 속한 사원들만 따로 관리하고 싶을 때, 이들을 사원 테이블에서 찾아서 별개의 테이블로 만들어 관리하면 데이터 중복성 문제가 발생함
- 뷰의 장점
    - 논리적 독립성 제공
    - 데이터의 접근과 보안을 제어
    - 사용자의 데이터 관리를 단순화할 수 있음
    - 여러 사용자의 다양한 데이터 요구를 지원하고 반영함
- 뷰의 단점
    - 뷰의 정의를 변경할 수 없음
    - 삽입/삭제/갱신 연산에 제한이 있음
- 뷰의 종류
    - 원천 테이블의 개수에 따른 분류
        - 단순뷰 = 하나의 기본 테이블 위에 정의된 뷰
        - 복합뷰 = 두 개 이상의 기본 테이블로부터 파생된 뷰
    - 인라인(inline) 뷰
        - 하나의 쿼리문 내에서만 사용되고, 쿼리 수행 종료 후에는 사라지는 1회성 뷰
            - 뷰의 명시적인 선언(CREATE VIEW)이 없음
            - FROM 절에서 참조하는 테이블의 크기가 클 경우, 필요한 행과 속성만으로 구성된 집합으로 뷰를 별도로 정의해 쿼리문을 효율적으로 구성할 수 있음
            - FROM 절에서 서브쿼리를 사용해서 생성하는 임시 뷰
                - 예: 부서별 평균 급여를 '사원 테이블'과 '부서 테이블' 조인을 통해 부서 번호와 부서명 기반으로 파악하는 경우
                    ```
                    SELECT dept_no, AVG(salary) AS avg_sal
                    FROM employee
                    GROUP BY dept_no

                    SELECT dept_name, AVG(salary)
                    FROM department dept, employee emp
                    WHERE dept.dept_no = emp.dept_no
                    GROUP BY dept_name
                    ```
                    - 인라인 뷰를 사용해 부서별 부서명과 평균 급여 출력
                        ```
                        SELECT dept_name, avg_sal
                        FROM (SELECT dept_no, AVG(salary) AS avg_sal 
                              FROM employee
                              GROUP BY dept_no) AS sal_view, department dept      /* sal_view라는 인라인 뷰를 선언 */
                        WHERE sal_view.dept_no = dept.dept_no
                        ```
        - WITH 절을 사용해서 인라인 뷰를 정의할 수도 있음
            - `WITH temp_table(attributes...) AS (SELECT something FROM something WHERE ...)`
            - 예시
                ```
                WITH sal_view(dept_no, avg_sal)
                AS (SELECT dept_no, AVG(salary)
                    FROM employee
                    GROUP BY dept_no)
                SELECT dept_name, avg_sal
                FROM sal_view, department
                WHERE department.dept_no = sal_view.dept_no
                ```

### 뷰 조작 쿼리문
- 뷰의 생성
    - `CREATE VIEW view_name AS sql_clauses`
    - 예시: `CREATE VIEW emp30 AS SELECT * FROM employee WHERE dept_no=30`
- 뷰의 삭제
    - `DROP VIEW view_name`
- 정의된 뷰를 저장 프로시져를 실행시켜서 확인
    - `EXEC SP_HELPTEXT view_name`

### 뷰의 연산
- 갱신 연산
    - 무결성 제약조건, 표현식, 집단연산, GROUP BY절의 유무에 따라 DML문의 사용이 제한적임
        - 뷰의 결과가 통계 요약을 가지고 있는 경우
            - 통계값이므로 기본 테이블 중 어느 튜플에 반영할지를 파악하기 어려움
        - 뷰가 두 개 이상의 테이블로부터 (조인 연산) 파생된 경우
            - 여러 개의 테이블로부터 생셩된 것이므로, 어느 테이블에 속한 튜플을 갱신해야할지 파악하기 어려움

---

# 8. Indexing

## 8-1. 색인의 개념

### 데이터 조직 방법
- 순차 방식
    - 튜플을 일정한 순서대로 저장하는 방법
        - 엔트리 순차 파일
            - 레코드가 생성되는 순서대로 저장
            - 장점: 쉬운 레코드 저장
            - 단점: 필요한 레코드를 찾기 위해 전체를 다 검색해야 함
        - 키 순차 파일
            - 레코드의 키값 순서대로 저장
            - 장점: 키값을 이용한 효율적 검색
            - 단점: 새로운 레코드 삽입시 매우 느림
- 색인 방식
    - 부가적인 자료 구조를 이용해 데이터의 빠른 접근을 지원하는 방법
- 해싱 방식
    - hashing function을 이용해 데이터를 그룹화하는 방법

### 색인(index) 이란?
- 검색 성능을 향상시키기 위한 부가적 자료 구조
    - SQL 명령문의 검색 속도를 향상시키기 위해 컬럼에 생성하는 객체
    - 테이블에 저장된 데이터에다가 포인터를 사용해 랜덤 액세스
- 인덱스가 효율적인 경우
    - WHERE 절이나 JOIN 조건절에서 자주 사용되는 컬럼
    - 전체 데이터 중에서 10~15% 이내의 데이터를 검색하는 경우
    - 두 개 이상의 컬럼이 WHERE 절이나 조인 조건에서 자주 사용되는 경우
    - 테이블에 저장된 데이터의 변경이 드문 경우
- 인덱스 조작 쿼리문
    - 인덱스 생성: `CREATE INDEX index_name ON table_name(attributes...)`
    - 인덱스 삭제: `CREATE INDEX index_name ON table_name`

### 쿼리에 인덱스를 강제로 사용하는 방법
- 사용할 인덱스의 이름을 WITH 절을 사용해 `WITH(INDEX=index_name)'로 지정해주면 됨
    - 예: `SELECT * FROM employee WITH(INDEX=idx_emp_name) WHERE name='John Doe'`

### 색인의 종류
- 속성의 유일성 기준
    - 고유 인덱스
        - 유일값을 가지는 속성에 대해 생성함
            - 기본키는 중복을 허용하지 않으므로, 기본키에 대해서는 테이블이 자동으로 고유 인덱스(primary index)를 생성함
        - 각 키값은 테이블에서의 하나의 튜플과 연관됨
            - 테이블을 검색할 때는 기본키만 사용하는 것은 아니므로, 새로운 튜플을 삽입할 때마다 해당 키값이 고유한지를 검사해야 함
                - 테이블에 튜플들이 많다면 매우 느림
                - 그래서 많이 사용되는 컬럼에다가 별도의 고유 인덱스를 보조 인덱스(secondary index)로써 생성 및 사용하면 성능이 뛰어남
        - 고유 인덱스 생성문: `CREATE UNIQUE INDEX unique_index_name ON table_name(attributes...)`
    - 비고유 인덱스
        - 중복된 값을 가지는 속성에 생성하는 인덱스
        - 각 키값은 여러 개의 튜플들과 연관됨
        - 비고유 인덱스 생성문 = 인덱스 생성문 = `CREATE INDEX index_name ON table_name(attributes...)`
- 속성의 개수 기준
    - 단일 인덱스
        - 하나의 속성만으로 구성된 인덱스
        - 예: `CREATE INDEX idx_salary ON employee(salary)`
    - 결합 인덱스
        - 두 개 이상의 속성들에 대해서 생성된 인덱스
        - 예: `CREATE INDEX idx_emp_no_salary ON employee(emp_no, salary)`
- 정렬 순서 기준
    - 오름차순(ascending) 인덱스
        - 일반적인 색인들은 속성값에 대해서 오름차순으로 정렬되어 저장됨
    - 내림차순(descending) 인덱스
        - 속성별로 정렬 순서를 내림차순으로 지정해서 결합 인덱스를 생성하는 방법
    - 색인 생성 시에 각 속성별로 오름차순/내림차순 정렬 여부를 지정해주면 됨
        - 예: `CREATE INDEX idx_emp_no_salary_desc ON employee(emp_no ASC, salary DESC)` 
- 물리적 순서와의 일치 여부 기준
    - 집중(clustered) 인덱스
        - '테이블의 튜플이 저장된 물리적 순서'가 '해당 인덱스의 키값 순서'와 동일하게 유지되도록 구성된 인덱스
            - 예: 기본키에 대해서 생성된 인덱스
                - 테이블의 튜플들이 기본키에 오름차순으로 정렬되어 저장되어 있다면, 기본키의 인덱스 또한 기본키에 대응해 오름차순으로 정렬되어 있음
        - 하나의 테이블에는 하나의 집중 인덱스만 생성할 수 있음
    - 비집중(unclustered) 인덱스
        - 집중 인덱스가 아닌 인덱스들

### 색인의 내부 구조
- 이진 탐색 트리란?
    - 자식이 최대 2개
    - 각 노드의 키값이 하나
    - 각 노드의 키값이 왼쪽 자손 노드들의 키값보다는 항상 크고, 오른쪽 자식 노드의 키값보다는 항상 작은 이진 트리
- B-tree란?
    - 이진 탐색 트리의 일반화로써, 각 노드가 두 개 이상의 자식을 가질 수 있음
        - 자식을 최대 m개 가질 수 있는 N-ary 트리
    - 문제점
        - 단말 노드와 비단말 노드의 구조가 다름
            - 저장 공간이 낭비됨
            - 단말 노드와 비단말 노드 사이의 변환에 비용이 많이 필요함
- 인덱스와 B-tree
    - 단말 노드와 비단말 노드의 물리적 구조를 같게 만들어 줘서 B-tree의 성능 문제 해결
        - 순차 세트
            - 단말 노드들로 구성함
            - 테이블에 있는 모든 키값들을 포함시킴
            - 키값 순서대로 연결되어 있음
        - 인덱스 세트
            - 비단말 노드들로 구성함
            - 단말 노드에 있는 키값들에 대한 접근 경로를 제공
            - 인덱스 세트에 있는 키값은 테이블에 존재하지 않을 수도 있음

## 8-2. 해싱

### 트리 기반 색인과의 차이
- 트리 기반의 인덱싱
    - '인덱스에 존재하는 여러 노드들을 탐색'해서 원하는 레코드를 찾는 방식임
- 해싱
    - '계산을 통해 얻은 주소'에다가 데이터를 저장하는 방식임
        - 자료를 검색할 때 키값을 비교하는 것이 아니라, 키값을 이용해서 '직접 데이터에 접근'하기
        - 해시 함수가 사용됨
    - 해싱 기법은 영역 탐색을 지원하지 못함

### 충돌(collision)
- 어떠한 해시 함수가 2개 이상의 입력값(키)에 대해 동일한 해시값을 출력하는 상황
    - 2개 이상의 키가 동일한 해시값을 갖게 됨
- 충돌의 방지
    - open hashing
        - 같은 해시값을 갖는 키들을 바구니(주로 linked-list)에 모아 놓음
        - 나중에 해당 바구니를 검색할 때는 순차 검색을 사용함
    - extendable hashing
        - 키값에서 일정 길이 부분의 비트를 해시값으로 사용
        - 레코드들이 늘어나면 버킷을 분해함

---

# 9. 장애와 회복

## 9-1. 장애

### 장애의 유형
- 전원 오류
    - 하드웨어 장애
- 트랜잭션 장애
    - 트랜잭션의 논리적 오류로 인해 발생
    - 입력 데이터 불량, 시스템 자원 과다 요구 등 트랜잭션의 내부 조건으로 인해 트랜잭션이 정상적으로 실행될 수 없는 상태
- 시스템 장애
    - 하드웨어 오동작으로 인한 메모리의 정보 손실
    - 교착 상태 등으로 인해 더 이상 시스템이 실행되지 않는 상태
- 미디어 장애
    - 저장 장치의 고장이나 파손으로 인해 데이터가 손상/파괴된 상태
- human error
    - 사람에 의해 발생하는 장애

### 운영체제와 입출력
- 보조기억장치와 주기억장치 사이의 데이터 이동
    - 보조기억장치에서 주기억장치로 데이터를 가지고 올 때 블록 또는 페이지 단위로 가지고 옴
        - 버퍼블록 입력
            - 데이터가 포함되어 있는 블록을 보조기억장치에서 주기억장치 버퍼로 가지고 옴 (요청에 따른 on-demand 작업)
        - 버퍼블록 출력
            - 데이터가 포함되어 있는 버퍼 블록을 보조기억장치로 다시 이동시켜서 기록함 (buffer manager에 의한 처리)
                - 제자리 갱신
                    - 버퍼블록을 출력할 때, 버퍼블록이 위치했던 디스크 위치에 그대로 덮어쓰는 방식
                - 간접 갱신
                    - 버퍼블록을 출력할 때, 버퍼블록이 위치했던 디스크 위치와는 다른 위치에 쓰는 방식
    - 읽기 연산
        - 읽을 데이터 X가 버퍼 블록에 없는 경우, X가 포함된 블록 Bx에 대해 버퍼블록 입력을 실행
            - 버퍼 블록으로 옮겨진 데이터를 읽음
    - 쓰기 연산
        - 만약 쓰기를 수행할 데이터 X가 버퍼 블록에 없는 경우, X가 포함된 블록 Bx에 대해서 버퍼블록 입력을 실행
            - 버퍼 블록에 데이터를 기록
    - 버퍼 강제 출력
        - 주기억장치의 버퍼 블록에서 메모리 공간을 필요로 할 때, 버퍼 관리자가 불가피하게 수행하는 버퍼블록 출력
- 데이터가 상실되는 상황
    1. 어떤 트랜잭션이 데이터를 읽기 위해 데이터 X에 접근함
        - 내부적으로 필요에 따라 버퍼블록 입력을 실행
    2. 트랜잭션이 X에 대한 연산을 마친 뒤, 변경된 X의 값을 쓰기 연산을 통해 데이터베이스 자체에 반영하려고 시도함
        - 하지만 쓰기 연산을 위한 버퍼블록 출력은 보통 즉각적으로 실행되지는 않고 지연 및 대기됨
    3. 바로 이 순간에 시스템에 장애가 발생해버린다면?
        - 쓰기 연산 자체는 수행되었지만, 그 연산으로 인한 변경 사항이 버퍼블록 출력을 통해 보조기억장치에 물리적으로는 반영이 되지 않는 사태가 발생
            - 데이터 X의 변경 사항이 상실되어버림
- 변경된 버퍼블록을 보조기억장치에 실제로 기록을 하는 방식
    - 종류 
        - Steal
            - 트랜잭션이 완료되기 전에, 그 트랜잭션에 의해 갱신된 cache를 디스크에 기록하는 방식
        - No-Steal
            - 트랜잭션이 완료되기 전에는 그 트랜잭션에 의해 갱신된 cache를 디스크에 기록할 수 없는 방식
        - Force
            - 트랜잭션이 완료될 때, 그 트랜잭션에 의해 갱신된 cache를 즉시 디스크에 기록하는 방식
        - No-Force
            - 트랜잭션이 완료될 때, 그 트랜잭션에 의해 갱신된 cache를 즉시 디스크에 기록할 수 없는 방식
    - 대부분의 DBMS들은 Steal + No-force 방식을 사용함
        - 트랜잭션이 완료되기 전에 일단 cache를 디스크에 기록하고, 트랜잭션이 완료되더라도 새로운 cache를 디스크에 즉시 기록하지는 않음

## 9-2. 회복

### 회복의 개념
- 장애가 발생되었을 때 데이터베이스를 장애 이전의 일관된 상태로 복원시키는 과정
    - DBMS는 장애 탐지와 데이터베이스 복원을 지원함
        - 손상된 부분만을 포함하는 최소 단위의 회복
        - 최단 시간 내에 회복
        - 트랜잭션 기반의 회복
        - 회복 자료의 보장
        - 시스템 레벨에서의 자동 조치
- 회복의 기본 원리는 '데이터의 중복 보관'
    - 데이터를 여러 곳에 복제해 놓으면, 시스템 장애 발생시 이를 사용해 복원할 수 있음
    - 데이터 중복을 통한 회복
        - dump/backup
            - 데이터의 전체나 일부분을 다른 저장 장치에 (주기적으로) 복제해두기
        - log/journal
            - 데이터베이스가 변경될 때마다, 해당 데이터베이스의 기존 값과 새로 변경된 값을 별도로 분리해 기록해 두기
            - Write-ahead Log
                - 데이터를 디스크에 쓰기 전에, 대응되는 로그 정보를 먼저 써야한다는 로그 기반 회복 규약
                - 모든 REDO 및 UNDO 유형의 로그 기록들이 '버퍼 강제 출력'을 통해 보조기억장치에 물리적으로 기록이 먼저 되어야만 트랜잭션이 완료될 수 있음
- 장애 종류에 따른 회복
    - 재해적이고 물리적인 실패
        - 미디어 장애 및 전원 장애의 경우가 이에 해당됨
        - 장애 사건 직전의 최신 복제본을 시스템에 적재시킨 뒤, 해당 목제본 이후에 일어난 변경만을 로그를 이용해 재실행시켜 복원하는 방식
            - 회복에 백업본과 로그가 필요함
    - 비재해적이고 논리적 실패
        - 트랜잭션 장애 및 시스템 장애의 경우가 이에 해당됨
            - 데이터베이스의 내용 자체는 손상되지 않고, 데이터의 변경 과정 및 변경 내용에 대한 신뢰성이 상실된 상태
        - 장애 사건 당시의 모든 변경을 취소시켜 원래의 데이터베이스 상태로 복원하는 방식
            - 회복에 로그가 필요함

### 로그 기반의 회복 기법
- 지연 갱신
    - 부분 완료될 때까지의 모든 출력 연산을 지연시킴
        - UNDO 연산자는 불필요함
        - 과정
            1. 모든 데이터베이스의 변경을 '로그'에 기록
            2. 안전한 저장소에 PARTIAL COMMIT을 포함하는 로그 레코드를 기록한 후에 데이터베이스를 갱신함
            3. 완료 상태가 됨
    - 로그 레코드는 REDO 연산에 대비함
        - REDO 연산의 멱등성(idempotency)
            - 같은 REDO 연산을 여러번 수행해도 결과는 동일함
            - REDO 작업 중 장애가 발생해 REDO 연산을 다시 실행하게 되어도 결과는 동일함 
    - start 레코드와 commit 레코드가 모두 있는 트랜잭션만 재실행
- 즉시 갱신
    - 데이터의 변경 결과를 데이터베이스에 그대로 반영
        - REDO와 UNDO 연산자가 필요함
    - 미완료 갱신(uncommitted update)
        - 완료 상태가 되지 않은 (부분 완료) 트랜잭션에 의해 데이터베이스에 반영된 갱신을 의미
        - 트랜잭션 장애가 일어나면 트랜잭션이 실행되기 전 상태의 데이터 값으로 복원
            - UNDO 연산도 멱등성을 가지고 있음
    - start 레코드와 commit 레코드 둘 다 있는 트랜잭션에는 REDO를 수행
    - start 레코드만 있고 commit 레코드가 없는 트랜잭션에는 UNDO를 수행

### 검사시점 회복 기법
- 로그기반 회복 기법의 단점
    - 트랜잭션별 REDO와 UNDO의 필요성을 판단하기 위해 로그 전체를 조사해야 함
        - 시간과 자원이 소모되고 불필요한 REDO도 발생함
- 검사시점 회복 기법
    - 로그 기록을 유지하되 일정 시간 간격으로 검사시점을 설정함
    - 과정
        1. 주기억장치에 있는 모든 로그 레코드를 안정 저장소로 출력
        2. 변경된 데이터 버퍼블록을 전부 보조기억장치로 출력
        3. 검사시점을 의미하는 checkpoint 로그 레코드를 안정 저장소로 출력
- 트랜잭션 목록 결정 과정
    1. 검사시점 당시를 기준으로 활동중인 트랜잭션은 undo list에 추가
    2. 로그를 차례대로 검사하면서 start 로그 레코드를 만나면 해당 트랜잭션을 undo list에 추가
    3. 로그를 차례대로 검사하면서 commit 로그 레코드를 만나면 해당 트랜젝션을 undo list에서 redo list로 옮김
- UNDO와 REDO 수행 방향
    - 후진(backward) 회복
        - undo list에 있는 모든 트랜잭션들에 대해 로그에 기록된 역순으로 UNDO 연산 수행
    - 전진(forward) 회복
        - redo list에 있는 트랜잭션에 대해 로그에 기록된 순서로 REDO 연산 수행
- 회복 작업이 완료될 때까지 시스템은 새로운 트랜잭션을 받아들일 수 없음

### Shadow Paging
- 로그를 사용하지 않는 회복 기법
    - 수정된 내용이 다른 위치에 저장되는 '간접 갱신' 방식임
    - 두 개의 페이지 테이블을 유지함
        - 현재 페이지 테이블
        - 그림자 페이지 테이블
    - 트랜잭션을 실행 중에는 '현재 페이지 테이블'만 사용
    - 데이터베이스에 대한 모든 읽기/쓰기 연산은 '그림자 페이지 테이블'을 사용
- 트랜잭션 수행 과정
    1. 트랜잭션 시작 시, 현재 페이지 테이블을 그림자 페이지 테이블로 복사
    2. 쓰기 연산 시, 수정된 데이터베이스 페이지의 새로운 사본을 생성하고, 현재 페이지 테이블 엔트리가 새 사본을 가리키도록 수정
    3. 트랜잭션 완료 시, 그림자 페이지 테이블을 폐기하고, 그 그림자 페이지 테이블이 참조하는 이전 페이지들을 반환
- 시스템 장애 상황별 회복
    - 3단계 과정 전에 발생하는 시스템 장애
        - 현재 페이지 테이블을 폐기하면 됨
    - 3단계 과정 직후에 발생하는 시스템 장애
        - 트랜잭션의 실행 결과에 아무런 영향이 없음
        - REDO 연산이 불필요함
- 장점
    - 로그 레코드를 출력하지 않으므로 출력 오버헤드가 없음
    - UNDO 연산이 아주 간단하며 REDO 연산이 필요 없음
        - 단순 장애로부터의 회복 작업이 신속함
- 단점
    - 갱신된 데이터베이스 페이지들의 디스크 상 위치가 변하므로 클러스터링이 어려움
        - 클러스터링(clustering) = 유사성 등의 개념에 기반해 데이터를 그룹화하고 분류하는 기법의 총칭
    - 디렉토리가 큰 경우에는 오버헤드가 상당함
    - 트랜젝션 완료시 garbage collection을 해야하는 문제가 있음
    - 동시 사용자 지원 등을 위한 병행 트랜잭션이 곤란함

### 다중 데이터베이스에서의 회복
- 다수의 데이터베이스에 접근해야하는 트랜잭션의 경우 각 DBMS들이 서로 다른 회복 기법과 트랜잭션 관리자를 사용할 수 있음
    - 이 경우 원자성을 유지하기 위해 2-phase commit을 사용함
        - '모든 참여 데이터베이스가 트랜잭션을 완료하도록' 하거나 '모든 참여 데이터베이스가 트랜잭션을 완료하지 않도록' 함
            - = All or Nothing
        - 참여중인 특정 데이터베이스에 장애가 발생하더라도 트랜잭션이 완료되거나 철회된 상태로의 회복은 항상 가능함
- 2-phase commit 과정
    1. 전역 회복 관리자가 READY? 메세지를 로컬 회복 관리자들에게 전송함
    2. 각 참여 데이터베이스의 로컬 회복 관리자는 자신이 담당한 트랜잭션 부분을 완료할 수 있으면 COMMIT PREPARED 메세지를 전역 회복 관리자에게 통보함
    3. 모든 로컬 회복 관리자가 COMMIT PREPARED 메세지로써 응답하게 되면, 전역 회복 관리자는 모든 로컬 회복 관리자들에게 COMMIT 명령을 보냄
        - 만약 하나 이상의 로컬 회복 관리자가 NO 신호로 응답하게 되면, 전역 회복 관리자는 모든 로컬 회복 관리자들에게 ROLLBACK 명령을 보냄

---

# 10. 동시성 제어

## 10-1. 동시성의 개념과 제어 방법

### 데이터베이스의 동시 공유
- 장점
    - 공유성 증가
    - 응답시간 단축
    - 시스템 활용도 증대
- 단점
    - 동시에 읽기/쓰기가 수행되면 비일관성을 유발함
        - 읽기 연산의 동시 접근은 문제가 없음
        - 쓰기 연산의 동시 접근 시 서로 다른 트랜잭션에 대해서 동일한 데이터가 접근되어 충돌 발생
            - 동시성 제어 필요 = 충돌하는 연산들간의 실행 순서를 정해주는 것
- 동시성 제어가 없을 때 발생하는 현상
    - 갱신 분실 (lost update)
        - 다른 트랜잭션이 수정한 내용이 데이터베이스에는 미반영됨
    - 비일관성 (inconsistency)
        - 트랜잭션 수행 결과에 일관성이 결여됨
    - 연쇄 복귀 (cascading rollback)
        - 이미 커밋된 트랜잭션을 복귀시킬 필요가 발생함

### 스케줄
- 트랜잭션들의 연산 실행 순서를 의미함
    - 단일 CPU의 시분할(time slicing)
        - interleaving으로 실행함
        - 사용자 입장에서는 각 프로그램들이 병렬로 구동되는 것처럼 보임
- 트랜잭션 스케줄 종류
    - 직렬 스케줄
        - 트랜잭션의 순차적 실행
        - interleaving 되지 않음
        - n!개의 순서 조합이 가능함
        - 가장 정확한 '올바른 스케줄링'
    - 비직렬 스케줄
        - interleaving 된 스케줄
        - 트랜잭션들의 병렬 실행
    - 직렬 가능(serializable) 스케줄
        - n개의 트랜잭션에 대한 스케줄 S가, 똑같은 n개의 트랜잭션에 대한 어떠한 직렬 스케줄 S와 동등한 경우, 스케줄 S를 '직렬 가능 스케줄'이라고 함
    - 동등 스케줄
        - 스케줄 S1과 스케줄 S2가 동일한 트랜잭션들을 포함한 경우를 의미함
        - 모든 데이터 항목들에 대해 마지막 데이터베이스에 기록한 결과가 두 스케줄에서 동일한 경우
        - 주의사항
            - 연산자의 유형이나 피연산자의 값에 따라 우연히 최종 결과가 같을수도 있음
            - 항상 동일한 결과를 생성하는 것을 보장하지는 않음
        - 충돌 동등
            - 두 스케줄에서 어떠한 충돌 연산들의 순서가 동일한 경우
        - 충돌 직렬 가능 스케줄
            - 어떤 직렬 스케줄과 충돌 동등인 스케줄
- 충돌 직렬 가능성 검사
    - 선행 그래프를 그렸을 때, 선행 그래프에 사이클이 없는 경우에는 충돌 직렬 가능성이 있음
    - 한계
        - 트랜잭션을 임의로 수행시켜 직렬 가능성을 검사하는 방식이고, 직렬 가능이 되지 않으면 스케줄이 취소됨
        - 시스템에 트랜잭션들이 계속 들어올 경우, 어떤 스케줄이 언제 시작해서 언제 끝나는지를 결정하기 어려움
            - 문제가 복잡한 경우에 직렬 가능성 검사는 불가능함
    - 대안
        - 직렬 가능성 검사를 하지 않고도 이론적 검증으로 직렬 가능성을 보장하는 방법
            - Locking
            - Timestamp

### 로킹 (Locking)
- 상호 배제 및 독점 제어의 과정을 의미함
    - 잠금이 된 데이터 집합을 생성함
    - 데이터 객체에 배타적으로 할당함
    - 무간섭을 보장함
- 로킹 규약
    1. 트랜잭션이 읽기/쓰기 연산을 할 때, 반드시 먼저 lock 연산을 실행함
    2. 트랜잭션이 실행한 lock에 대해서, 트랜잭션의 모든 실행을 종료하기 전에 반드시 unlock 연산을 실행함
    3. 트랜잭션은 다른 트랜잭션에 의해 이미 lock이 걸려있는 데이터 객체에는 다시 lock 연산을 실행할 수 없음
    4. lock된 데이터 객체에 트랜잭션이 접근할 경우, 해당 lock을 트랜잭션 자신이 걸어놓지 않았을 경우에는 여기에 unlock 연산을 실행할 수 없음
        - lock을 걸어둔 트랜잭션만이 그것을 unlock 할 수 있음
- 로킹 모드
    - 공용 lock
        - 읽기 연산에만 허용됨
        - 여러 트랜잭션들의 동시 사용 가능
    - 전용/독점(exclusive) lock
        - 읽기/쓰기 연산에 허용됨
        - 오직 하나의 트랜잭션만 사용 가능
    - 트랜잭션이 데이터 객체에 대해 읽기 연산 실행 시, 먼저 공용 lock이나 독점 lock 연산을 실행함
    - 트랜잭션이 데이터 객체에 대해 쓰기 연산 실행 시, 먼저 독점 lock 연산을 실행함
    - 데이터 객체는 다른 트랜잭션에 의해 양립될 수 없으며, lock이 걸려 있다면 그것이 모두 풀릴때까지 대기됨
- 로킹 규약의 성질
    - 데이터 객체의 비공유/비중첩
    - All or Nothing
    - 단일 소유자
    - 로킹을 수행한 트랜잭션만이 로킹 해제 가능
- 로킹의 단위
    - 속성, 레코드, 릴레이션, 데이터베이스
    - 단위가 큰 경우 = 동시성 감소
    - 단위가 작은 경우 = 로킹 오버헤드의 증가

### 2-phase Locking Protocol
- 로킹을 사용하더라도 충돌 직렬 가능 스케줄을 항상 만들 수 있는 것은 아님
    - 스케줄 내의 모든 트랜잭션들이 2단계 로킹 규약을 준수할 경우 직렬이 가능해짐
- 단계
    - growing phase
        - 트랜잭션은 lock만 수행 가능함
    - shrinking phase
        - 트랜잭션은 unlock만 수행 가능함
        - unlock을 한번이라도 수행했다면 이후 lock을 걸 수 없음
- 주의점
    - 2단계 로킹 규약은 충돌 직렬 가능성을 보장하지만, 직렬 가능성의 '충분 조건'이지 '필요 조건'은 아님
        - 2단계 로킹 규약을 사용하지 않아도 충돌 직렬 가능 스케줄 생성이 가능함
- Strict 2PLP
    - 제약이 추가된 엄격한 2단계 로킹 규약
        1. 모든 독점 lock은 그 트랜잭션이 완료될 때까지 unlock하지 않고 그대로 유지
        2. 완료되지 않은 어떤 트랜잭션에 의해 기록된 모든 데이터 객체는, 그 트랜잭션이 완료될 때까지 독점 모드로 로킹
            - 다른 트랜잭션은 해당 데이터 객체에 접근할 수 없음
            - 연쇄 복귀 문제가 발생하지 않음
- Rigorous 2PLP
    - S2PLP보다 더욱 엄격한 통제적 2단계 로킹 규약
        - 모든 lock는 트랜잭션이 완료될 때까지 unlock되지 않고 잠긴 상태를 유지
    - 트랜잭션들이 완료되는 순서로 직렬화가 가능함
- 대부분의 DBMS들은 S2PLP나 R2PLP를 사용함

---

# 11. 교착상태

## 11-1. 교착상태의 개념과 제어 방법

### 교착상태란?
- 모든 트랜잭션들이 실행을 전혀 진전시키지 못하고 무한정 대기하는 상태
- 발생 조건
    - 상호 배제 (mutual exclusion)
        - 독점적 로킹으로 인해 발생
    - 대기 (wait for)
        - 로킹을 얻기 위한 대기
    - 선취 금지 (no preemption)
        - 트랜잭션이 완료되지 않고 계속 살아있음
    - 순환 대기 (circular wait)
        - 상대방의 순서가 끝나기만을 서로 기다리기만 함
- 해소 방법
    - 4가지 발생 조건 중 하나라도 해소해주면 해결됨
    - 탐지
        - 교착상태가 일단 발생한 다음, 교착 상태의 조건을 제거해주는 접근법
        - 현재 로킹된 데이터 객체와 로킹 요청이 대기중인 데이터 객체를 기준으로, 교착상태를 탐지하는 시스템 검사를 주기적으로 가동하고 교착상태 회복을 수행
    - 예방
        - 트랜잭션이 실행되기 전에 교착상태의 발생 조건을 불가능하게 만드는 접근법
        - 트랜잭션 스케줄링 기법을 사용해, 트랜잭션 실행 전에 필요한 데이터 객체들을 모두 로킹함
            - 단점
                - 충돌되는 데이터 객체를 필요로 하는 트랜잭션은 병행 실행이 불가능해짐
                    - 그렇다고 해서 모든 트랜잭션들이 특정 순서에 따라 데이터 객체를 로킹하도록 수동으로 지시하고, 그 순서를 프로그래머가 숙지하는 것은 현실적인 대안이 아님
                - 데이터 요구에 대한 사전 지식이 필요함
                - 데이터가 한번에 일괄적으로 로킹되기 때문에 데이터 활용도가 감소됨
                - 기아(starvation) 문제가 발생함
                    - 자주 사용되는 데이터의 경우, 특정 트랜잭션이 해당 데이터를 사용하는 동안 나머지 트랜잭션들이 무한정 대기를 해야 함
            - 현실적으로 활용하기 어려움
    - 회피
        - 자원을 할당하는 시점 기반으로 교착상태가 일어나지 않도록 실시간 알고리즘을 사용해 검사하는 접근법
            - timestamp를 활용함

### Timestamp
- 교착 상태 회피를 위해 사용되는 식별자
    - 트랜잭션의 시작 순서에 기초하는 식별자로써, 트랜잭션이 기다려야 할지 복귀해야 할지를 결정하는데 사용됨
        - 시스템의 clock값 또는 논리적 카운터를 timestamp로써 사용함
    - 교착 상태의 주요 원인인 로킹을 사용하는 대신, 순서(타임스탬프) 기반으로 동시성 제어를 하는 접근법
        - 새로 접근하는 트랜잭션이 가장 최근에 접근한 트랜잭션보다 더 오래된 경우, 새로운 타임스탬프를 부여해서 재시작함
        - 트랜잭션을 interleaving으로 실행한다면 타임스탬프 순서대로 직렬이 가능함
- 방식
    - 트랜잭션 T2가 로킹한 데이터 객체를 트랜잭션 T1이 요청할 때,
    - wait-die 방식
        - 트랜잭션 T1의 타임스탬프가 트랜잭션 T2의 타임스탬프보다 작은 경우,
            - T1이 고참인 경우 T1은 대기
            - T1이 신참인 경우 T1은 복귀(die) 후 다시 시작
        - 고참 트랜잭션이 신참 트랜잭션을 기다림
        - 고참 트랜잭션이 가지고 있는 데이터 객체를 신참이 요구하면, 신참 트랜잭션은 복귀 후 재실행
        - 재실행 시 똑같은 순서로 데이터를 요구하므로 불필요한 복귀가 자주 발생함
    - wound-wait 방식
        - 트랜잭션 T1의 타임스탬프가 트랜잭션 T2의 타임스탬프보다 클 경우,
            - T2가 고참인 경우 T2는 대기
            - T2가 신참인 경우 T2는 T1에 의해 상처를 입고(wound) 복귀해 다시 시작
        - 고참 트랜잭션이 신참 트랜잭션을 기다리지 않음
        - 신참 트랜잭션이 가지고 있는 데이터 객체를 고참이 요구하면, 신참 트랜잭션은 복귀 후 재실행
        - 신참 트랜지션은 대기만 하고 있으면 됨
    - timestamp 순서 방식
        - T1이 T2보다 오래 되었다면 T1의 타임스탬프가 T2의 타임스탬프보다 작은 값이므로, 시스템이 T1, T2의 직렬 실행과 결과가 일치하도록 보장해주는 방식
        - 장점
            - 대기가 없으므로 교착 상태가 없음
        - 단점
            - 연쇄 복귀가 발생
                - T1의 복귀가 T2의 복귀를 유발함
                - T1이 복귀하고 T1이 쓰기 작업을 수행한 데이터를 T2가 벌써 사용했다면, T2 역시 복귀해야 함
            - 순환적 재시작
                - 연속적인 복귀와 재시작으로 인한 기아 상태가 발생할 수 있음