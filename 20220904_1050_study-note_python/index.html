<!DOCTYPE html>
<html>
    
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>[필기] &lt;파이썬 입문&gt; 강의 | devfreedom.github.io</title>
    <meta name="title" content="[필기] &lt;파이썬 입문&gt; 강의 | devfreedom.github.io">
    <meta name="description" content="devfreedom&#39;s personal blog">
    <meta name="keywords" content="❮필기❯,파이썬,프로그래밍,eleventy,template,simple,clean">
    <meta name="author" content="devfreedom">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://devfreedom.github.io/20220904_1050_study-note_python/">
    <link rel="shortcut icon" type="image/png" href="/assets/img/favicon.svg">
    <link rel="apple-touch-icon" href="/assets/img/apple-touch-icon.png">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    <link rel="stylesheet" href="/assets/css/main.css">
    
</head>	

<body class="flex flex-col h-screen bg-white text-gray-800 break-words">
    <header id="header" class="header-shadow bg-black px-6 py-5 z-50 fixed w-full top-0 transition-all transform ease-in-out duration-500">
    <div class="max-w-5xl mx-auto flex items-center flex-wrap justify-between">
        <div class="sm:mr-8">
            <a class="flex items-center" href="/">                              
                <span class="text-lg text-white font-semibold self-center">devfreedom.github.io</span>
            </a>
        </div>
        <nav id="menu" class="order-last md:order-none items-center flex-grow w-full md:w-auto md:flex hidden mt-2 md:mt-0">
            
            <a href="/tags" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">Categories</a>
            
            <a href="https://github.com/devfreedom" target="_blank" rel="noopener" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">GitHub</a>
            
            <a href="/about" class="block mt-4 md:inline-block md:mt-0 font-medium text-gray-500 hover:text-white text-base mr-7">About</a>
            
        </nav>
        <form id="search" action="/search" class="order-last sm:order-none flex-auto w-32 items-center justify-end hidden sm:block mt-6 sm:mt-0">
            <label class="visually-hidden" for="header-searchbox">Search here ...</label>
            <input type="text" id="header-searchbox" name="q" placeholder="Search..." class="w-full sm:max-w-xs bg-gray-200 border border-transparent float-right focus:bg-white focus:border-gray-300 focus:outline-none h-8 p-4 placeholder-gray-700 rounded text-gray-700 text-sm">
        </form>
        <div id="menu-toggle" class="flex items-center md:hidden text-gray-700 hover:text-teal-600 cursor-pointer sm:ml-6">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
    <line x1="3" y1="12" x2="21" y2="12"></line>
    <line x1="3" y1="6" x2="21" y2="6"></line>
    <line x1="3" y1="18" x2="21" y2="18"></line>
</svg>
        </div>
    </div>
</header>
    <main class="mx-7 lg:mx-6 mt-32 flex-grow">
        
        
<article class="max-w-5xl mx-auto">
    <header class="mb-14">
        <h1 class="text-3xl text-center font-bold leading-normal text-gray-900 mt-0 mb-3">[필기] &lt;파이썬 입문&gt; 강의</h1>
        <div class="text-center">Published on 4 September 2022 10:50 AM</div>
        
        <div class="mt-3 text-center">
            
            <a href="/tags/❮필기❯" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#❮필기❯</a>
            
            <a href="/tags/파이썬" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#파이썬</a>
            
            <a href="/tags/프로그래밍" class="inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-medium text-gray-700 m-0.5">#프로그래밍</a>
            
        </div>
        
        
        <div class="mt-10 -mx-7 md:mx-0">
            <img class="w-full max-w-2xl mx-auto" src="/assets/img/python-logo.png" width="960" height="500" alt="This post thumbnail">
        </div>
        
    </header>
    <div id="content" class="prose text-gray-800 max-w-none">
        <p>파이썬이라고는 Coursera에서 Google IT Automation with Python 과정에 포함된 Crash Course on Python 강의 하나 들어본게 다인데, 일을 하다 보니 파이썬을 더 배워야 할 필요가 생겨서 추가적으로 강의를 듣고 공부하게 되었습니다.</p>
<p>급하게 적었기 때문에 내용이 압축되어 있어서 나중에 시간이 되면 한줄 한줄 쉽게 풀어서 복습을 해볼 생각입니다.</p>
<h3>파이썬 특징</h3>
<ul>
<li>파이썬 재단이 경영하는 비영리 프로젝트</li>
<li>High-level 프로그래밍 언어</li>
<li>Platform-agnostic 언어</li>
<li>객체지향형, 절차형, 함수형, 명령형 multi-paradigm 언어</li>
<li>소스코드를 중간언어로 변환 후 바로 실행하는 인터프리터 언어</li>
<li>실행시간에 자료형을 검사하는 dynamically-typed 대화형 언어</li>
<li>파이썬 2.x에서  3.x으로 넘어가면서 호환성 상실, Py2의 라이브러리가 더 풍부함
<ul>
<li>2.7 버전이 마지막 Py2 브랜치</li>
</ul>
</li>
<li>Class/functional abstraction을 제공하는 객체지향 언어이자 함수형 프로그래밍 언어</li>
<li>Coroutine을 지원
<ul>
<li>함수에 진입하는 지점, 그리고 종료되는 지점이 설정 가능한 subroutine 함수</li>
<li>함수에 진입하는 지점을 여러개 가질 수 있는 coroutine 함수 (subroutine도 여기에 포함됨)</li>
<li>Productive 'dynamic language'</li>
</ul>
</li>
</ul>
<h3>파이썬 종류</h3>
<ul>
<li>Cpython
<ul>
<li>C언어로 구현된 오리지널 파이썬</li>
<li>다른 구현체와 구분하여 언급할 때 이 용어를 사용</li>
<li>IronPython: 닷넷용 인터프리터</li>
<li>Stackless Python: C스택을 없앤 인터프리터</li>
<li>Jython: 자바로 구현해 JVM 위에서 돌아가는 인터프리터</li>
<li>PyPy: 파이썬으로 구현한 파이썬 인터프리터</li>
</ul>
</li>
</ul>
<h3>파이썬 장점</h3>
<ul>
<li>코드의 단순성과 표준성
<ul>
<li>다른 객체지향 언어보다 간결한 구문</li>
<li>서술문들은 줄로 끝나고 블록 구조는 들여쓰기로 나타냄</li>
<li>실행 가능한 pseudocode처럼 보이는 단순한 구조</li>
</ul>
</li>
<li>이식성
<ul>
<li>모든 OS와 연동되고 다른 언어와도 연결되는 platform-agnostic한 언어</li>
<li>Open source</li>
</ul>
</li>
<li>객체지향 언어
<ul>
<li>절차지향 및 객체지향 프로그래밍을 둘 다 지원</li>
<li>C++ 및 Java에 비해 손쉬운 방법으로 객체지향 프로그래밍을 지원</li>
<li>절차지향 언어: 주로 사용되는 프로시저/함수를 정의하고 재사용함</li>
<li>객체지향 언어: 데이터와 기능이 결합된 하나의 객체 중심으로 프로그래밍</li>
</ul>
</li>
<li>확장 가능한 라이브러리
<ul>
<li>방대한 표준 라이브러리를 제공함
<ul>
<li>정규 표현식, 자동 문서 생성, 유닛 테스트, 스레딩, 데이터베이스, 웹 브라우저, CGI, FTP, 전자메일, XML(-RPC), HTML, 암호화, GUI 등을 지원</li>
<li>Python Package Index 2를 참조</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>파이썬 단점</h3>
<ul>
<li>Global Interpretor Lock이라는 대표적인 단점
<ul>
<li>CPython에서는 하나의 스레드만 동작하는 것을 허용함</li>
<li>다중 스레드의 성능이 떨어지므로 다중 프로세서를 대신 사용할 것을 권장함</li>
<li>'다중 프로세싱' 패키지를 통해 다중 스레드와 비슷하게 운용</li>
</ul>
</li>
</ul>
<h3>파이썬 프레임워크</h3>
<ul>
<li>웹 개발: Django, Pyramid, Bottle, Tornado, Flask, Web2py</li>
<li>GUI 개발: wxPython, tkInter, PyGtk, PyGObject, PyQt</li>
<li>수학/과학: SciPy, Pandas, iPython</li>
<li>소프트웨어 개발: Buildbot, Trac, Roundup</li>
<li>SysAdmin: Ansible, Salt, Openstack</li>
</ul>
<h3>파이썬 문법의 특징</h3>
<ul>
<li>간결하고 가독성이 좋음 = 협업에 유리</li>
<li>Dynamic typing and resolution of names
<ul>
<li>입력한 값을 바로 출력구문으로 호출해서 사용 가능</li>
<li>data를 변환해서 사용 가능</li>
<li>자료 입출력시 자료형을 크게 생각하지 않아도 사용 가능</li>
<li>프로그램의 크기를 줄여주고 테스트를 쉽게 해줌</li>
</ul>
</li>
<li>유니코드 지원</li>
<li>세미콜론과 역슬래시의 예외적 사용
<ul>
<li>다른 유사 언어와 달리 세미콜론은 명령 끝에 붙이지 않으나, 한 줄로 여러 개의 명령을 선언할 때만 세미콜론으로 구분함</li>
<li>들여쓰기 및 콜론으로 문장을 구분해서 사용함</li>
<li>구문이 길어질 때 다음 줄까지 구문을 이을 경우에 역슬래시 사용</li>
</ul>
</li>
<li>주석 기호로는 #를 사용</li>
<li>string값은 상황에 따라 single quote, double quote, triple single/double quote 기호로 묶어서 표시함</li>
<li>파이썬의 소스코드 .py 파일은 python-specific representation 바이트코드인 .pyc 파일로 변환되고, 인터프리터는 이 바이트코드 파일을 사용함</li>
</ul>
<h3>파이썬의 구조</h3>
<ul>
<li>Function: 입력과 출력을 가지는 연산 수행 단위</li>
<li>Method: Object에서 호출되는 함수의 형태 – 객체에 내장되어 객체를 위해 작동함</li>
<li>Object: 상태나 행위를 가지는 하나의 구조화된 집합
<ul>
<li>상태는 variable, 행위는 method로 지칭함</li>
</ul>
</li>
<li>Module: definitions과 statements를 포함하는 하나의 파일 (.py)</li>
<li>Package: 모듈들을 포함하는 하나의 디렉토리로써 한 개 이상의 모듈을 가지게 된다</li>
</ul>
<h3>Python Virtual Machine (PVM)</h3>
<ul>
<li>파이썬 컴파일러는 스크립트로부터 인터프리터를 위해 경량화된 중간 코드인 '바이트코드'를 생성함
<ul>
<li>이 바이트코드는 .pyc 파일에 저장되고 메모리에 옮겨짐</li>
<li>소스코드가 바뀌지 않는 이상 바이트코드도 바뀌지 않고 기존의 것이 사용됨</li>
</ul>
</li>
<li>바이트코드 파일을 통해 PVM이 실행되고, 이 PVM이 바이트코드의 명령어를 해석하고 실행함
<ul>
<li>CPU에 의해서 직접 low-level execution이 가능한 C 및 C++에 비해서 속도가 느림</li>
</ul>
</li>
</ul>
<h3>파이썬 내장 함수</h3>
<ul>
<li>선언할 필요 없이 global하게 사용할 수 있는 함수들
<ul>
<li>e.g. dir() 함수를 사용해 내장함수와 선언된 변수들을 확인할 수 있음</li>
</ul>
</li>
</ul>
<h3>식별자</h3>
<ul>
<li>고유하게 구별 및 식별이 필요한 것에 사용하는 유니코드 형식의 이름
<ul>
<li>변수, 자료형, 서브루틴 등을 가리키는 토큰</li>
<li>처리해야 할 정보를 가리킬 방법으로 사용</li>
</ul>
</li>
<li>영문자 A-Z, a-z, _로 시작함
<ul>
<li>단일 underscore로 시작하는 식별자는 private라는 의미</li>
<li>두개의 underscore로 시작하는 식별자는 strong private라는 의미</li>
<li>두개의 underscore로 끝나는 식별자는 언어에 의해 정의된 특별한 이름을 의미</li>
</ul>
</li>
<li>문장부호, 특수문자는 사용하지 않음</li>
<li>대소문자를 구분함</li>
</ul>
<h3>키워드</h3>
<ul>
<li>파이썬에서 미리 사용하기 위해 예약해둔 단어를 의미
<ul>
<li>상수, 변수, 다른 식별자로 사용할 수 없음</li>
<li>파이썬 버전이 바뀔때마다 추가 및 제외되므로 확인이 필요함</li>
</ul>
</li>
<li>import keyword | keyworld.kwlist로 그 목록을 확인 가능함</li>
<li>e.g. False, None, True, and, as, assert, break, etc…</li>
</ul>
<h3>변수</h3>
<ul>
<li>값을 저장할 수 있는 메모리상의 가상 공간을 의미</li>
<li>숫자 값, 문자열 값, 클래스 객체를 나타탬</li>
<li>빈 공간인 변수에다가 상수(값)을 지정(mapping)하여 시스템 메모리에 저장함</li>
<li>상수(literal constant)는 변경할 수 있지만 변수 이름은 그대로 유지됨</li>
<li>특정 데이터 형식(=할당 메모리 양)과 레이블을 사용하여 선언함
<ul>
<li><code>fruit_bucket = 'Apple'</code>
<ul>
<li>변수 fruit_bucket에 상수 Apple을 할당함</li>
<li>fruit_bucket은 문자열을 할당받았으므로 '문자열 변수'가 됨</li>
</ul>
</li>
</ul>
</li>
<li>여러가지 변수를 한번에 할당하는 방법에는 여러가지가 있음
<ul>
<li>e.g. <code>A = B = C = 100</code>
<ul>
<li>이 경우 변수 A, B, C에 모두 상수 100이 할당됨</li>
</ul>
</li>
<li>e.g. <code>A, B, C = 12, 3.141, &quot;Apple&quot;</code>
<ul>
<li>이 경우 A에는 12가, B에는 3.141이, C에는 Apple이 할당됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>자료형</h3>
<ul>
<li>데이터의 자료가 가질 수 있는 값이자 구조로, 그 자료에 적용할 수 있는 연산을 결정하기도 함</li>
<li>파이썬의 모든 값은 데이터를 가지고 있고 이는 모두 객체임</li>
<li>데이터의 유형은 실제로 class이며, 변수는 이 클래스의 instance가 됨</li>
<li>type() 함수를 통해 이 자료형을 확인할 수 있음</li>
<li>Numbers: 수치를 관리하는 자료형
<ul>
<li>접두어를 사용하면 진수를 사용할 수도 있음
<ul>
<li>Binary(0b/0B), Octal(0o,0O), Hexadecimal(0x/0X)
<ul>
<li>e.g. 16진법 0xFB = 10진법 251</li>
<li>e.g. 2진법 0b1101011 = 10진법 107</li>
</ul>
</li>
</ul>
</li>
<li>Integer(Boolean 포함): 정수, 양수, 음수</li>
<li>Float: 실수와 지수형</li>
<li>Complex: 복소수 (실수+허수를 입력하게 되면 complex형으로 처리)</li>
</ul>
</li>
<li>None</li>
<li>Sequences
<ul>
<li>Strings: 문자열의 집합
<ul>
<li>Single quote를 사용해 문자열 상수를 지정
<ul>
<li>e.g. <code>'Hello World!'</code></li>
</ul>
</li>
<li>문자열 내부에 single quote가 포함된 경우 double quote를 사용
<ul>
<li>e.g. <code>message = &quot;It is called 'apple', according to him.&quot;</code></li>
</ul>
</li>
<li>문자열 내부에 double quote가 포함된 경우 single quote를 사용
<ul>
<li>e.g. <code>message = 'he said &quot;Hello World&quot; to her.</code></li>
</ul>
</li>
<li>Triple double quote의 경우 multiline string을 하나로 묶을 때 사용
<ul>
<li>e.g.
<ul>
<li>&quot;&quot;&quot;he showed</li>
<li>the screenshot</li>
<li>to her&quot;&quot;&quot;</li>
</ul>
</li>
</ul>
</li>
<li><code>'Hello' = &quot;Hello&quot; = '''Hello''' = &quot;&quot;&quot;Hello&quot;&quot;&quot;</code>
<ul>
<li>다만 이 경우 출력값은 single quote를 사용한 'Hello'로 출력됨</li>
</ul>
</li>
<li>Escape sequence/code
<ul>
<li>제어문자 = 문자열 내부에서 영향을 받지 않고 독립적인 역할을 하는 문자열
<ul>
<li>\n : newline (줄바꿈)</li>
<li>\v : vertical tab</li>
<li>\t : tab</li>
<li>\r : carriage return</li>
<li>\f : formfeed</li>
<li>\a : bell</li>
<li>\b : backslash</li>
<li>\ooo : Null</li>
<li>quote 기호 앞에 escape code인 역슬래시()를 사용하게 되면 해당 quote 기호를 문자열로써 포함시킬 수 있음
<ul>
<li>e.g. <code>message = 'They said \&quot;It is called \'apple\', right?\&quot;, and he said yes.\&quot;</code></li>
</ul>
</li>
<li>8진수 확장 문자에 해당하는 ASCII 문자를 출력하는 제어문자
<ul>
<li>\x로 시작되는 16진수 숫자를 통해 ASCII 문자를 출력할 수 있음</li>
<li>\로 시작되는 8진수 숫자를 통해 ASCII 문자를 출력할 수 있음</li>
<li>16진수가 아니게 되는 시점에서 종료됨
<ul>
<li>e.g. 알파벳 A는 10진수 기준 65임</li>
<li>8진수인 '\101' = 10진수 65와 동일 = A가 출력됨</li>
<li>16진수인 '\x41' = 10진수 65 와 동일=  A가 출력됨</li>
</ul>
</li>
<li>이를 활용해 8진수 확장 문자를 사용해 다른 escape code도 구현 가능
<ul>
<li>e.g. newline인 '\n' 대신에, n의 8진수값인 012나 16진수값인 0A에 기반해 '\012' 라던가 '\x0A'를 사용해도 \n과 동일하게 작동</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Tuple</li>
<li>List</li>
</ul>
</li>
<li>Sets</li>
<li>Mappings: Dictionary</li>
</ul>
<h3>연산자</h3>
<ul>
<li>대상을 두고 operand를 계산할 때 사용되는 문자(operator)</li>
<li>연산자들은 처리하는 우선순위가 정해져 있으므로 다중 연산시 우선순위를 확인할 필요가 있음</li>
<li>산술연산자
<ul>
<li>+, -, *, /, = 등</li>
<li>% : Remainder</li>
<li>** : Square</li>
<li>// : Floor division</li>
</ul>
</li>
<li>관계연산/비교연산자
<ul>
<li>두 개의 값을 비교해 그 결과인 논리상수/boolean 상수를 반환함
<ul>
<li>&lt;, &gt;, &lt;=, &gt;=, != 등</li>
</ul>
</li>
</ul>
</li>
<li>논리연산자
<ul>
<li>AND, OR, NOT 등</li>
</ul>
</li>
<li>비트연산자
<ul>
<li>Bitwise operation을 위해서 사용함</li>
<li>&amp;, |, ~, ^, &gt;&gt;, &lt;&lt; 등</li>
</ul>
</li>
<li>대입연산자
<ul>
<li>오른쪽에 있는 계산값을 왼쪽에 있는 변수에 대입하기 위해 사용함</li>
<li>=, +=, -=, *=, /= 등</li>
</ul>
</li>
<li>기타 연산자
<ul>
<li>dictionary, string, list, tuple 등의 sequence에서 값을 찾을 수 있는지 여부를 확인
<ul>
<li>is, is not, in, not in 등</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Sequence 자료형</h3>
<ul>
<li>문자열, 수치 등을 관리하는 기본 자료형</li>
<li>항목을 나열하고 배열하는 형식을 취함</li>
<li>자료를 관리하기 위해 지점과 위치를 참조하는 indexing
<ul>
<li>문자열은 각 한 문자씩 인덱스를 가지고 나열됨
<ul>
<li>맨 처음 문자열이 0, 그 다음 문자열이 1, 그 다음 문자열이 2 …
<ul>
<li>e.g. &quot;Hello World&quot;라는 문자열의 0번 index는 맨 첫 글자인 'H'가 됨</li>
<li>index 값이 음수인 경우 앞이 아닌 뒤에서부터 카운트 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>특정 구간의 자료를 반환하는 slicing 기능
<ul>
<li>[시작 index : 끝index] 형태로 범위를 지정해 문자열을 잘라낼 수 있음
<ul>
<li>e.g. &quot;Hello World&quot; 문자열을 [1:3]로 slicing하게 되면 'ell' 을 출력</li>
</ul>
</li>
<li>시작이나 끝 인덱스를 생략하게 되면 앞이나 뒤 끝부터 범위가 선택됨
<ul>
<li>e.g. &quot;Hello World&quot; 문자열을 [1:]로 slicing 하게 되면 'ello World'가 출력</li>
<li>e.g. &quot;Hello World&quot; 문자열을 [:6]로 slicing 하게 되면 'Hello W'가 출력</li>
<li>e.g. &quot;Hello World&quot; 문자열을 [0:-2]로 slicing 하게 되면 'Hello Wo'가 출력</li>
</ul>
</li>
</ul>
</li>
<li>숫자를 지정해 그 단계만큼 건너뛰면서 문자를 지정하는 step 기능 (Python 2.3 and above)
<ul>
<li>e.g. &quot;Hello World&quot; 문자열을 [::2]로 stepping 하게 되면 'HloWrd'가 출력</li>
</ul>
</li>
<li>문자열을 연결하거나 반복할 수 있는 + 및 * 연산자
<ul>
<li>e.g. 'Hello World'*2 는 'Hello WorldHello World'를 출력</li>
<li>e.g. &quot;Hello World&quot;+' !' 는 'Hello World !' 를 출력</li>
</ul>
</li>
<li>문자열을 조작하고 제어하는 문자열 함수들의 예시
<ul>
<li>문자열의 길이를 반환하는 len() 함수</li>
<li>문자열을 소문자로 만드는 str.lower() 함수</li>
<li>전체 문자열에 포함된 특정 문자열의 갯수를 카운트하는 str.count() 함수</li>
</ul>
</li>
</ul>
<h3>Tuple 자료형</h3>
<ul>
<li>숫자와 문자를 함께 관리하는 자료형</li>
<li>지정된 값을 변경할 수 없음</li>
<li>(item0, item1, item2, …) 형태로 지정됨
<ul>
<li>e.g. <code>fruit_bucket = ('Apple', 'Orange', 'Grape')</code></li>
</ul>
</li>
<li>nested tuple
<ul>
<li>튜플이 포함된 튜플</li>
<li>e.g. <code>fruit_bucket2 = ((Apple, Strawberry, Orange), Grape, Lemon)</code></li>
<li>대단위로 indexing 되고 그 다음 작은 단위로 indexing 됨
<ul>
<li>e.g. fruit_bucket2[0][1]에서 1차 index인 [0]은 대단위 맨 첫번째 항목인 (Apple, Strawberry, Orange)가 되고, 그 다음 2차 index인 [1]은 그 안에서 두번째 항목인 Strawberry이므로, 출력값은 'Strawberry'가 됨</li>
</ul>
</li>
</ul>
</li>
<li>string과 동일한 방식으로 slicing이 가능</li>
<li>string과 동일한 방식으로 병합과 반복이 가능
<ul>
<li>e.g. <code>fruit_bucket*2 = ('Apple', 'Orange', 'Grape', 'Apple', 'Orange', 'Grape')</code></li>
</ul>
</li>
</ul>
<h3>List 자료형</h3>
<ul>
<li>sequence 중 가장 많이 사용되는 자료형</li>
<li>[item0, item1, item2, …] 형태로 지정됨</li>
<li>지정된 값을 바꿀 수 있는 tuple이라고 생각하면 됨</li>
<li>리스트 안에 tuple을 포함시킬수도 있음</li>
</ul>
<h3>Dictionary 자료형</h3>
<ul>
<li>key:value 형태로 선언해 비정형 데이터를 매핑할 때 사용하는 자료형</li>
<li>{key0 : value0, key1 : value1, key2 : value2, ...} 형태로 지정됨</li>
<li>키와 값을 pair로 반드시 함께 선언</li>
<li>value는 변경이 가능하지만 key는 고유값으로써 변경 불가</li>
<li>key를 호출하면 value를 반환함</li>
<li>다양한 타입을 섞어서 사용하는 것이 가능</li>
<li>대소문자를 구분함</li>
<li>정렬되지 않으므로 순서가 의미가 없음</li>
<li>e.g.</li>
</ul>
<pre><code>fruit_bucket3={'Yellow' : 'Lemon', 'Green' : 'Lime', 'Red' : 'Apple'}
    # fruit_bucket3['Yellow'] 는 'Lemon'을 반환함
    # fruit_bucket3['Yellow'] = Banana 를 실행하면 기존의 Lemon이 Banana로 치환됨
</code></pre>
<h3>Set 자료형</h3>
<ul>
<li>set() 함수를 통해 생성되며, 중복되지 않은 요소들의 모임을 가진 집합</li>
<li>집합연산을 위해 사용됨</li>
<li>e.g.</li>
</ul>
<pre><code>a = set('abcde')
b = set('cdefg')
print(a)            // 교집합이 아닌 a의 고유한 값인 set(['a', 'b'])를 출력 
print(a&amp;b)          // a와 b의 교집합인 set(['c', 'd', 'e'])를 출력
print(a^b)          // a와 b의 합집합에서 교집합을 뺀 set(['a', 'b', 'f', 'g'])를 출력
</code></pre>
<h3>표준 입출력</h3>
<ul>
<li>shell을 활용해 출력하기
<ul>
<li>print()
<ul>
<li><code>print(value1, sep=' ', end='\n', file=sys.stdout, flush=true/false)</code>
<ul>
<li>value: 출력될 값</li>
<li>sep: 연속적인 값을 구분해서 출력해주는 seperator 문자열</li>
<li>end: 줄바꿈 지정</li>
<li>file: 출력할 스트림 선택</li>
<li>flush: 버퍼를 유지할 것인지 삭제할 것인지 선택</li>
</ul>
</li>
<li><code>print(&quot;[flags][width][.precision]type&quot; % (value))</code>으로 출력서식 정해서 출력하기
<ul>
<li>flags: % 문자열을 사용해 포매팅 시작을 알림</li>
<li>width: 출력될 value의 전체 자릿수 지정</li>
<li>precision: 소수점 자리수 지정</li>
<li>type: 출력값의 데이터형을 키워드로 지정</li>
</ul>
</li>
</ul>
</li>
<li>str.format()
<ul>
<li>문자열 또는 출력을 포매팅</li>
<li><code>str.format(*args, **kwargs)</code>
<ul>
<li>e.g. <code>print('Fruit bucket has {} and {}'.format('Strawberry', 'Apple'))</code></li>
</ul>
</li>
<li><code>str.center/ljust/rjust(width, fillchar)</code></li>
<li><code>str.zfill(width)</code></li>
</ul>
</li>
</ul>
</li>
<li>shell을 활용해 입력하기
<ul>
<li>input()
<ul>
<li>입력값을 사용자로부터 받음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>정규식</h3>
<ul>
<li>특정 규칙을 가진 문자열의 집합을 표현하는데 사용하는 형식 언어</li>
<li>축약된 문법으로 기술된 문자열 패턴</li>
<li>re모듈을 사용해 정규 표현식을 처리하고 함수/확장문법과 함께 사용
<ul>
<li>re모듈을 import 한 후 dir(re)를 통해 symbol들을 확인</li>
<li>re.search()
<ul>
<li>첫 인자로 찾고자 하는 패턴을, 둘째 인자로 검색대상 문자열을 받아들임</li>
<li>대상 문자열 전체 검색</li>
</ul>
</li>
<li>re.match()
<ul>
<li>첫 인자로 찾고자 하는 패턴을, 둘째 인자로 검색대상 문자열을 받아들임</li>
<li>대상 문자열의 시작부터 검색</li>
<li>키워드와 일치하는 문자열이 대상 문자열의 중간 이후에 존재하는 경우(문자열에 공백이 있는 경우 등)에는 re.match() 함수는 검색할 수 없음</li>
</ul>
</li>
<li>re.compile(), re.findall(), re.sub() 등등</li>
</ul>
</li>
</ul>
<h3>조건문</h3>
<ul>
<li>condition의 리턴값이 true일 경우 statement 실행, false일 경우 건너뛰고 다음 statement로 이동</li>
<li>if, if else, elif(else if) 등</li>
</ul>
<h3>반복문</h3>
<ul>
<li>while
<ul>
<li>condition을 만족하는 경우 statement를 수행</li>
<li>반복횟수를 제어하는 변수가 반드시 필요, 반복문 제어변수가 없을 경우 무한루프 발생</li>
</ul>
</li>
<li>for
<ul>
<li>반복 수행할 횟수가 결정된 경우에 주로 사용</li>
<li>for 변수 in 순서형자료 → statement 수행</li>
<li>딕셔너리나 리스트 등에 기반해 반복해야 하는 횟수가 결정된 형태를 제어할 때 주로 사용</li>
</ul>
</li>
<li>range()
<ul>
<li>정수 범위에 대해서 반복을 하거나 특정 범위의 숫자를 나열하도록 해줌</li>
<li>start값, stop값, step size의 순서로 sequence 나열
<ul>
<li>e.g. range(0, 15, 3) 는 0, 3, 6, 9, 12를 출력</li>
<li>시작값은 범위에 포함됨, 종료값은 포함되지 않음</li>
<li>마지막 값에서 step size를 더했을 때 stop값을 초과하게 되는 경우 range()는 종료됨</li>
</ul>
</li>
</ul>
</li>
<li>enumerate()
<ul>
<li>for문을 효율적으로 사용하기 위한 함수</li>
<li>인덱스값과 그 값을 동시에 저장할 수 있음</li>
<li>enumerate([iteration이 가능한 타입의 객체], [시작값 (디폴트는 0)]
<ul>
<li>e.g. <code>enumerate(fruit_bucket3, 0)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>흐름 제어문</h3>
<ul>
<li>break: 가장 인접한 반복 loop문을 빠져나올 때 사용함</li>
<li>continue: 가장 인접한 loop문의 맨 앞에 있는 조건부로 제어를 옮겨 이를 계속 실행할것인지를 결정</li>
</ul>
<h3>함수</h3>
<ul>
<li>여러 개의 실행문을 하나로 묶은 모듈</li>
<li>특정 작업을 수행하도록 설계된 하나의 독립된 프로그램 조각</li>
<li>모듈화가 기본 개념 = 별도의 파일에 정의된 함수와 데이터
<ul>
<li>모듈을 호출 및 실행하는 방식으로 사용</li>
</ul>
</li>
<li>라이브러리 함수 = 표준함수/내장함수
<ul>
<li>시스템에서 미리 작성해놓은 함수를 의미함</li>
<li>삼각함수, 지수함수, 날짜함수, 파일함수, DB함수 등</li>
</ul>
</li>
</ul>
<h3>사용자 정의함수</h3>
<ul>
<li>사용자가 직접 만든 함수</li>
<li>파이썬 언어의 함수 원형에 기반해 모듈화하여 제작하고 정의함</li>
</ul>
<pre><code>def function_name(parameter1, parameter2, ...):
    &quot;function_docstring&quot;    // 주석문 형태로 설명 작성
    function_suite          // 함수의 기능을 정의
    return [expression]     // 함수의 반환값을 선택적으로 지정
</code></pre>
<h3>함수의 호출 및 리턴</h3>
<ul>
<li><code>function_name()</code></li>
<li>return값이 생략되어있으면 함수는 none값을 반환</li>
<li>return값이 지정되어 있으면 함수에서 지정한 datatype에 맞는 값을 반환</li>
</ul>
<h3>매개변수와 전달인자</h3>
<ul>
<li>Parameter: 호출된 함수가 입력을 받을 수 있는 변수의 이름 = 매개변수
<ul>
<li>함수의 수행으로 생성된 local variable이라고 하더라도 global 구문을 사용해서 외부에서 접근할 수 있음</li>
<li>인수, 기본값, 가변, 키워드 등 여러가지 형태로 대입하여 사용함</li>
<li>return 키워드 뒤에 parameter를 나열해서 지정하면 연산의 결과를 한번에 리턴할 수 있음</li>
</ul>
</li>
<li>Argument: parameter에 대응해 함수가 호출될 때 넘기는 변수 = 전달인자
<ul>
<li>매개변수의 갯수를 지정하지 않고 유동적으로 적용하기 위해서는 가변인자를 사용하면 됨</li>
<li>*args를 함수의 매개변수로 지정하면, 함수 내에서 전달인자를 몇 개를 입력하든 tuple 형태로 인식함</li>
<li>dictionary형태로는 **kwargs를 사용</li>
<li>가변인자는 일반인자 뒤에 위치해야 함
<ul>
<li>e.g. <code>fruit_bucket(fruit_name, *args)</code></li>
</ul>
</li>
<li>가변인자는 단 하나만 사용 가능</li>
</ul>
</li>
</ul>
<h3>Lambda 함수</h3>
<ul>
<li>함수의 이름이 없는 함수 = 익명함수</li>
<li>한 줄로 표시되는 함수</li>
<li>다른 함수의 인자로 함수를 넘겨줄 때 사용함</li>
<li>filter(), map(), reduce() 등의 함수와 함께 유용하게 사용</li>
<li>e.g. <code>add = lambda x,y : x+y</code></li>
<li>e.g. <code>(lambda x,y,z : x*y-z)(1,2,3)</code>
<ul>
<li>이렇게 하면 연산의 결과를 바로 리턴받을 수 있음</li>
</ul>
</li>
</ul>
<h3>고차함수</h3>
<ul>
<li>다른 함수를 받는 함수</li>
<li>함수를 전달인자로써 넘기며, 다른 함수의 결과값으로 반환 가능</li>
<li>데이터 대용량 분산처리에 활용</li>
<li>map(), reduce(), filter() 등
<ul>
<li><code>filter(function, list)</code>
<ul>
<li>함수와 리스트를 parameter로 받고, 리스트의 값이 하나씩 parameter function으로 전달됨</li>
<li>출력값을 묶어서 리스트로 리턴함</li>
<li>e.g. <code>print(list(filter(lambda x: x%2==0, range(10))))</code>
<ul>
<li>조건과 일치하는 true 반환 값만 리턴함</li>
</ul>
</li>
</ul>
</li>
<li><code>map(function, seq)</code>
<ul>
<li>함수와 시퀀스를 parameter로 받고, 시퀀스의 값이 하나씩parameter function으로 전달됨</li>
<li>출력값을 묶어서 리스트로 리턴함</li>
<li>e.g. <code>print(list(map(lambda a:a*2, [1,2,3,4])))</code>
<ul>
<li>입력한 숫자를 배수로 리턴함</li>
</ul>
</li>
</ul>
</li>
<li><code>reduce(function, seq)</code>
<ul>
<li>함수와 시퀀스를 parameter로 받고, 시퀀스의 처음 두 항목을 연산함</li>
<li>결과값이 나오면 그 다음 항목과 계속 연산해 최종적인 하나의 값을 반환함</li>
<li>e.g. <code>reduce(lambda x,y: x+y, range(1,11))</code>
<ul>
<li>reduce는 module object이므로 from functools import reduce 구문을 통해 모듈을 선언을 해주어야 함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>재귀함수</h3>
<ul>
<li>함수가 직간접적으로 자신을 다시 호출하는 것</li>
<li>이러한 recursive call을 활용하면 코드가 간결해지고 이해가 쉬움</li>
<li>대신 연산 처리에 메모리와 성능을 많이 요구함</li>
<li>quick sort, fractal curve, tower of hanoi 등의 알고리즘을 구현할 때 사용</li>
<li>종료조건이 반드시 명시되어야 함</li>
</ul>
<h3>Scoping rule</h3>
<ul>
<li>함수나 클래스 등이 선언되면 변수를 사용하게 되는데, 선언된 변수를 저장하거나 namespace에 저장하고 호출할 때 namespace 영역의 우선순위에 따라 호출된다는 규칙</li>
<li>Local &gt; Global &gt; Built-in 순서대로 호출이 되므로 LGB rule이라고도 함</li>
<li>local: 함수 내부에 선언될 경우</li>
<li>global: 함수 외부에 선언될 경우</li>
<li>built-in: 파이썬 자체적으로 제공하는 내장 함수에 선언될 경우</li>
</ul>
<pre><code>str = &quot;this is global&quot;      // Global 영역
def func():                 // Local 영역
    str = &quot;this is local&quot;   // str은 func() 내부에서만 우선적으로 작동
print(str)                  // 이 출력값은 'this is global'이 됨
</code></pre>
<ul>
<li>변수 호출 순서와 namespace 영역은 역순이 됨</li>
</ul>
<h3>객체지향 프로그래밍</h3>
<ul>
<li>메소드 객체 중심의 프로그래밍 방식</li>
<li>interactive, interpreted</li>
<li>자바라던가 닷넷과는 달리 클래스를 포함해서 사용하는 모든 것을 객체로 다룸</li>
<li>함수, 클래스, 문자열, 데이터 타입도 객체로 다루며, 타입을 가짐</li>
<li>함수 인자값을 받을 수 있음</li>
<li>메소드와 속성을 가짐</li>
</ul>
<h3>클래스</h3>
<ul>
<li>사물이나 개념의 속성과 기능을 모델링해서 abstraction하는 과정</li>
<li>class = variables + methods = 함수들과 변수들을 묶어놓은 패키지의 개념'</li>
<li>member variable/field란 특정 객체와 연결되고 모든 메소드에서 접근 가능한 변수를 의미</li>
<li>public member
<ul>
<li>해당 클래스 밖에서도 접근 가능한 멤버</li>
<li>기본적으로 모든 클래스 멤버들은 public임</li>
<li>함수들은 C++에서의 virtual 함수처럼 동적 바인딩임</li>
<li>모든 함수의 첫 인자가 self 키워드로 선언
<ul>
<li>자바에서의 this와 같이 오브젝트 멤버 접근용 shorthand가 없음</li>
</ul>
</li>
</ul>
</li>
<li>private member
<ul>
<li>관습적으로 double-underscore로 시작하는 이름은 non-public으로 취급됨</li>
<li>subclass에서 동일한 이름으로 선언된 변수처럼 private멤버가 필요한 경우, name mangling을 통해 private variable을 지원함</li>
<li>triple-doublescore로 시작하는 이름은 _className__name 형식으로 변환됨</li>
</ul>
</li>
</ul>
<h3>객체</h3>
<ul>
<li>고유한 속성을 가지고 클래스에서 정의한 행위를 수행함</li>
<li>객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유하여 메모리를 경제적으로 사용</li>
<li>클래스에 속하는 객체를 instance라고 함
<ul>
<li>instance는 정의된 클래스를 사용해서 실제로 메모리에 생성되어 로딩된 상태를 의미</li>
<li>클래스 타입으로 선언되고 그 객체가 메모리에 할당되어 사용되는 것을 instance라고 함</li>
<li>class가 abstraction되어 실제로 구현된 결과물
<ul>
<li>정의되고, 이름이 붙어서, 물리적으로 위치되는 것</li>
</ul>
</li>
</ul>
</li>
<li>그림판 프로그램을 예로 들면, 동그라미 세모 네모 등의 도형 그리기 도구가 미리 정의되어 있는 것이 클래스고, 그 도형 그리기 도구를 사용해 실제로 도형을 그린 그 결과물이 객체임</li>
<li>object = attributes + behaviors</li>
<li>method
<ul>
<li>클래스 내부에서 정의된 함수를 의미함</li>
<li>데이터 attribute가 아닌 인스턴스의 속성이 소스코드 내에서 언급되면, 인터프리터는 우선 그 인스턴스의 클래스를 찾음</li>
<li>그 속성이 클래스의 유효한 함수 객체라면, 인스턴스 객체와 함수 객체를 추상 객체로 packing함</li>
</ul>
</li>
</ul>
<h3>클래스 선언</h3>
<ul>
<li>자료형 선언 → 객체 생성 → 멤버 호출</li>
<li>e.g. Address 클래스 선언하기</li>
</ul>
<pre><code>class PersonInfo:
    name=&quot;Anderson&quot;
    city=&quot;Seoul&quot;
    dept=&quot;HR&quot;
    print(PersonInfo.city)		// 'Seoul' 을 출력하게 됨
</code></pre>
<ul>
<li>클래스 내에서 정의되는 함수는 무조건 self를 첫 번째 parameter로 사용해야 함
<ul>
<li>객체 자신을 참조한다는 의미</li>
<li>self 인수는 자동적으로 객체의 참조로 채워지므로 self 인수를 넘길 필요는 없음</li>
<li>self를 통해서 클래스 내의 멤버나 메소드를 자유롭게 호출할 수 있음</li>
</ul>
</li>
<li>방법</li>
</ul>
<pre><code>class class_name [(inherit_class_name)]:
    &lt; class 변수 선언 &gt;
    def class_function (self, parameter1, parameter2, …):
        &lt; 수행할 명령 &gt;
</code></pre>
<ul>
<li>e.g. 값을 받아서 저장하고 추가하는 클래스 설계하기
<ul>
<li>값을 받아 저장하는 멤버를 가진 메소드 = empty()</li>
<li>값을 받아 추가하는 메소드 = add()</li>
<li>클래스명: Test</li>
<li>클래스 변수: 없음</li>
<li>메소드: empty(self, addself, x)</li>
</ul>
</li>
<li>e.g. 값을 받아서 저장하고 추가하는 클래스 선언하기</li>
</ul>
<pre><code>class test:
    def empty(self):
        self.data=[]
    def add(self, x):
        self.data.append(x)
</code></pre>
<ul>
<li>e.g. 인명부 클래스 만들어보기</li>
</ul>
<pre><code>class Registry:
    def PersonInfo(self, name, city, dept):
        self.name=name
        self.city=city
        self.dept=dept
</code></pre>
<ul>
<li>e.g. 인명부에 정보 기록하기</li>
</ul>
<pre><code>person01 = Registry()
person01.PersonInfo(&quot;Jackson&quot;, &quot;NYC&quot;, &quot;Accounting&quot;)
person02 = Registry()
person02.PersonInfo(&quot;Dominique&quot;, &quot;Berlin&quot;, &quot;IT&quot;)
</code></pre>
<h3>클래스 권한</h3>
<ul>
<li>파이썬에서 class/instance의 모든 멤버 변수와 메소드 접근권한은 public임</li>
<li>과도한 접근권을 제한하고 정보 은닉을 위해서 name mangling 방식을 사용할 수 있음
<ul>
<li>변수/함수명 앞에 언더스코어 두개를 붙이면 됨
<ul>
<li><strong>class</strong>
<ul>
<li>클래스 객체를 참조하기 위한 인스턴스 객체의 내장속성</li>
<li>클래스 영역의 모든 인스턴스 객체의 데이터 참조 및 수정시 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>파이썬은 instance → class → global 영역 순서로 namespace를 찾게 됨
<ul>
<li>그래도 이름을 찾지 못하면 AttributeError가 발생함</li>
</ul>
</li>
</ul>
<h3>클래스의 내장함수</h3>
<ul>
<li>모든 클래스 안에서 사용할 수 있는 특별한 메소드</li>
<li><strong>init</strong> : 인스턴스가 만들어질 때 호출되는 생성자
<ul>
<li>명시적 호출 불가능</li>
<li>변수의 초기화 작업시 사용</li>
<li>클래스 내에 생성자를 명시하면 생성자 매개변수의 개수에 따라서 파라미터가 지정됨</li>
</ul>
</li>
<li><strong>del</strong> : 인스턴스가 사라질 때 호출되는 소멸자
<ul>
<li>파일을 닫거나 DB 연결을 종료할 때 사용</li>
<li>전달인자 없이 선언</li>
</ul>
</li>
</ul>
<h3>연산자 오버로딩</h3>
<ul>
<li>operator 키워드와 연산자를 겹쳐서 함수명으로 사용하는 것</li>
<li>인스턴스 객체끼리 서로 연산을 할 수 있도록 기존 연산자의 기능을 바꾸어 중복으로 정의</li>
<li>삼항 연산은 할 수 없음</li>
</ul>
<h3>상속</h3>
<ul>
<li>하나의 객체를 설계할 수 있는 concrete/super/parent/base class를 또다른 클래스가 기능/특성을 추가 및 변경하여 새로운 클래스로 정의하는 것</li>
<li>base class가 상속을 통해 보다 더 큰 규모 또는 다른 특성의 derived class가 됨</li>
<li>클래스의 멤버 변수와 메소드는 다른 클래스에게 그대로 전달됨</li>
<li>derived class가 base class의 메소드를 호출할 때는 선조클래스명 및 멤버변수로 호출 가능</li>
<li>derived class는 base class의 멤버변수와 메소드를 상속받지만, 생성자는 상속받을 수 없음</li>
<li>코드의 재사용성, 간결성, 확장성이 그 목적</li>
<li><code>class DerivedClass (BaseClass1, BaseClass2, …):</code> 형식으로 상속이 가능함
<ul>
<li>선조 클래스가 하나 이상인 다중상속을 지원함
<ul>
<li>다중상속시 두 개 이상의 부모가 같은 메소드를 가지고 있을 경우가 있음</li>
<li>이 경우 먼저 정의된 쪽의 메소드를 호출함</li>
</ul>
</li>
</ul>
</li>
<li>super()는 선조클래스를 의미하며 이 경우 self 키워드는 현재 오브젝트, 후손클래스를 의미함
<ul>
<li>명시적으로 후손 클래스에서 선조의 변수나 메소드를 가리킬 때 사용함</li>
<li>후손 클래스에서 후손이 가진 값을 선조 클래스의 생성자를 호출해서 대입할 때 사용함</li>
</ul>
</li>
<li>overriding
<ul>
<li>메소드의 재정의</li>
<li>상속받은 후손 클래스에서 상속해준 선조 클래스에 이미 정의되어있는 메소드의 기능을 변경해서 새로 정의하는 것</li>
<li>오버라이드 하고자 하는 메소드가 선조 클래스에 존재해야 함</li>
<li>선조에서 선언한 메소드가 후손에서 사용할 때 메소드 명이 반드시 같아야 함</li>
<li>하나의 클래스에 같은 메소드를 선언하는 선조가 정의한 메소드의 파라미터 갯수가 같아야 함
<ul>
<li>파이썬에서는 메소드의 리턴형이 같지 않아도 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Polymorphism</h3>
<ul>
<li>다형성, 즉 한 요소에 여러 개념을 넣어놓는 것으로, 주로 overriding이나 overloading을 지칭</li>
<li>여러 개의 클래스가 같은 이름의 메소드에서 서로 다른 각자의 방법으로 작동할 수 있도록 설계</li>
<li>하나의 선조 객체의 변수로 여러 유형의 후손 객체를 참조할 수 있음</li>
<li>변수가 참조하는 객체 유형에 맞는 메소드를 자동으로 호출할 수 있음</li>
<li>추상화를 이용해 다양한 구현을 제공함</li>
<li>필요조건
<ul>
<li>상속관계의 클래스이면서 후손 클래스 객체에서 작동</li>
<li>후손 클래스 객체의 메소드 호출은 선조클래스 유형의 변수를 통해야 함</li>
<li>호출된 메소드는 선조클래스 멤버여야 함</li>
<li>선조클래스와 후손클래스에서 메소드의 원형이 같아야 함</li>
</ul>
</li>
<li>subclassing
<ul>
<li>선조클래스의 속성과 구조를 그대로 가지는 상속 유형</li>
<li>새로운 데이터 멤버변수와 멤버메소드를 추가하여 코드를 재사용</li>
</ul>
</li>
<li>subtyping
<ul>
<li>상속과 선조클래스가 수행할 명령을 선언하는 상속 유형</li>
<li>후손클래스가 상속을 받아 선조클래스의 객체를 후손클래스의 타입으로 대체하여 실행할 수 있도록 함
<ul>
<li>abstract class를 지원하면서 동적 타이핑의 한 종류인 duck typing을 지원함
<ul>
<li>duck클래스를 객체 선언하면 duck이 생성되어 호출됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Abstract class</h3>
<ul>
<li>한 개 이상의 추상 메소드를 가진 클래스</li>
<li>추상 메소드의 내용이 구현되지 않아 인스턴스로 생성 불가능</li>
<li>상속을 통해서 추상 메소드를 구현할 수 있음</li>
<li>ABCMeta 클래스(메타클래스를 이용하기 위해)와 @abstractmethod() (추상메소드의 속성과 정의를 선언하기 위해)를 사용
- <code>from abc import abstractmethod, ABCMeta</code></li>
<li>추상클래스를 선언하고 재정의를 하면서 후손의 객체주소를 각각 생성해서 메소드를 실행</li>
<li>decorator
<ul>
<li>@abstractmethod → 메소드를 추상메소드로 지정</li>
<li>@property → 메소드를 변수로 호출할 수 있도록 지정</li>
<li>@staticmethod → 정적 메소드로 선언</li>
<li>@classmethod → 클래스 인스턴스 메소드로 선언</li>
<li>사용자가 직접 정의해서 타입 검사나 함수 디버깅 등에 사용함</li>
<li>Aspect-oriented programming 을 도입한 요소</li>
</ul>
</li>
</ul>
<h3>모듈</h3>
<ul>
<li>코드를 담고있는 파일</li>
<li>대부분은 파이썬 코드지만 컴파일된 C 및 C++ obj 파일들도 있으며 파이썬 모듈과 동일한 방식으로 사용됨</li>
<li>폴더로 묶여 있다면 패키지를 구현해서 사용함</li>
<li>별도의 네임스페이스를 가지므로 독립적인 작업이 가능
<ul>
<li>객체들을 grouping 하는 것과 마찬가지의 방식으로 이름 충돌 문제를 피할 수 있음</li>
</ul>
</li>
<li>대부분의 표준 파이썬 함수들은 언어의 core상에 빌드되는 대신, 필요시에 load되는 방식으로 파이썬 자체의 관리를 수월하게 함</li>
<li>모듈 이름이 곧 파일이라는 명명 규칙에 따라 만듦</li>
<li>import sys; print(sys.path)를 통해 기본 모듈 검색 경로를 확인할 수 있음</li>
<li>module_name.function_name() 형식으로 모듈 내 함수 및 클래스를 사용할 수 있음</li>
<li>module_name.variable = 'Hello World' 와 같은 방식으로 모듈 namespace에 변수를 정의해서 독립적으로 사용</li>
<li>모듈 내용이 폴더로 묶여있다면 패키지로 지정하여 선언</li>
<li>모듈을 가져오는 방법
<ul>
<li><code>import module_name</code></li>
<li><code>from module_name import component_name</code>
<ul>
<li>모듈 내에서 import로 지정한 컴포넌트들을 현재의 global/local namesapce로 로딩함</li>
<li>global/local namespace이므로 module_name.function_name() 대신 곧바로 function_name()으로 사용할 수 있음</li>
<li>_로 시작하는 name들은 외부에서 접근하지 못하는 내부 name인데 이 방법으로 가져올 수 있음</li>
</ul>
</li>
</ul>
</li>
<li>파이썬 내장 라이브러리 모듈을 적극 활용할 필요가 있음
<ul>
<li>help(module_name)을 통해 모듈의 documentation 확인 가능</li>
</ul>
</li>
</ul>
<h3>수학 함수 모듈</h3>
<ul>
<li>math: 산술 연산용</li>
<li>random: 난수 발생용</li>
<li>decimal: 진법 변환 에러와 관련해 정확한 결과 값을 얻도록 사용
<ul>
<li>부동소수점은 실수와 실제 수학적 연산을 정확히 표현하지 못함
<ul>
<li>float와 다르게 decimal 모듈로 실수를 정확하게 표현할 수 있음</li>
<li>+infinity, -infinity, NaN도 표현 가능</li>
<li>소수점 자리의 정밀도 조정 가능</li>
<li>큰 정밀도를 필요로 하는 연산에도 사용</li>
</ul>
</li>
</ul>
</li>
<li><code>decimal.Decimal(value, context)</code>
<ul>
<li>생성자를 통해 정수, 문자열, 튜플 등으로 값을 전달하여 생성</li>
</ul>
</li>
</ul>
<h3>datetime 모듈</h3>
<ul>
<li>시간을 관리하는 모듈</li>
<li>시간과 날짜를 관리하는 클래스를 포함함
<ul>
<li>date클래스: 숫자로 년/월/일을 입력받아서 date 객체를 생성</li>
<li>datetime 클래스: 년/월/일(필수) + 시간으로 datetime 객체를 생성</li>
<li>timedelta 클래스: 두 날짜 혹은 시간 사이의 기간을 표현함
<ul>
<li>생성되는 timedelta 객체값은 생성자에 전달된 값과 다름
<ul>
<li>동일한 기간을 표현하는 방식이 다양하기 때문 (1weeks/7days)</li>
<li>입력된 값으로 정규화 과정을 거쳐 유일한 표현 방식으로 변경하기 때문</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>calendar 모듈: 시간과 날짜 외에 달력을 나타내는 모듈</li>
</ul>
<h3>에러와 예외처리</h3>
<ul>
<li>오류 발생시 실행은 정지되고 오류가 발생한 정확한 위치, 종류, 설명을 포함한 에러 메세지가 표시됨</li>
<li>syntax error = parsing error
<ul>
<li>문법적인 문제로 구문 오류가 발생하면 줄 번호와 위치를 통해 알려줌</li>
</ul>
</li>
<li>semantic error = exception
<ul>
<li>프로그램 수행 중에 발생할 수 있는 에러</li>
<li>사전에 프로그래머가 예상해서 처리할 수 있는 가벼운 에러</li>
<li>e.g. 존재하지 않는 파일을 열려고 하는경우, 네트워크 연결 오류, 연산의 결과가 크기를 초과하는 경우, 사용하려는 모듈이 존재하지 않을 경우, 인덱스가 배열의 크기를 초과하는 경우, etc.</li>
<li>예외처리: 이러한 에러를 실행을 멈추지 않고 적절히 대처해 처리하는 방법
<ul>
<li>try ~ except</li>
<li>try ~ finally</li>
<li>try ~ else</li>
<li>try ~ else ~ finally</li>
<li>try 구문에서 예외상황이 발생하면 기존에 남은 명령을 무시하고 except로 넘어감
<ul>
<li>except에는 예외종류와 예외변수, 표시 문구 등이 포함됨</li>
<li>예외 상황이 발생하지 않았을 때에는 else로 넘어감</li>
<li>예외 발생 여부와 상관없이 꼭 실행되는 구문이 finally에 포함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>user-defined exception</h3>
<ul>
<li>exceptions class(의 서브클래스 중 하나)를 inherit/extend하여 사용자 정의 예외를 만듦</li>
<li>이 예외는 raise를 사용해 객체로 호출함
<ul>
<li>raise
<ul>
<li>원하는 에러를 강제로 발생시킬 수 있는 키워드</li>
<li><code>raise exception_variable [exception_comment]</code>
<ul>
<li>e.g. <code>raise ValueError</code></li>
</ul>
</li>
</ul>
</li>
<li>assert
<ul>
<li>자신의 문법을 가지고 있어 특정 조건에 충족하는 경우에 예외를 발생시킬 때 사용할 수 있다.</li>
<li>assert condition message
<ul>
<li>condition이 false일 때 message가 표시됨</li>
</ul>
</li>
</ul>
</li>
<li>unittest
<ul>
<li>파이썬이 갖추고 있는 기본 클래스들에 필요한 부분을 재정의해서 요청하면 동작함</li>
<li>두 개의 클래스를 통해 정의할 수 있음</li>
<li>setUp → runTest → tearDown 순서로 실행됨</li>
</ul>
</li>
</ul>
</li>
<li>except [class_name]을 사용해 사용자 정의 예외를 잡을 수 있음</li>
</ul>
<h3>OS모듈</h3>
<ul>
<li>사용중인 운영체제의 값을 구현하는 클래스와 메소드들을 제공</li>
<li>생성, 삭제 등 파일 탐색기의 명령을 수행</li>
<li>os.path
<ul>
<li>파일 경로를 생성 및 수정하고 파일 정보를 다룸</li>
<li>파일 입출력시에 파일 경로를 지정할 때 사용</li>
</ul>
</li>
<li>sys
<ul>
<li>인터프리터와 관련된 정보와 기능을 제공</li>
<li>프롬프트를 바꿀 수 있음</li>
</ul>
</li>
</ul>
<h3>파일 모듈</h3>
<ul>
<li>개별 파일에 대한 모듈</li>
<li>file 객체를 이용해 제공되는 함수를 통해 CRUD가 이루어짐
<ul>
<li><code>open(file, mode)</code> 	// 피일에 쓰기를 하기 전에 먼저 해당 파일을 지정해 열어주어야 함
<ul>
<li>e.g. <code>open(file, 'rb')</code>로 지정하면 파일을 읽기전용으로 1byte씩 읽어서 hex 코드로 출력함</li>
</ul>
</li>
<li><code>read()</code>			// 파일 내용을 읽어옴</li>
<li><code>write()</code>			// 파일에 내용을 기록</li>
<li><code>close()</code>			// 파일을 닫음</li>
</ul>
</li>
<li>with문과 파일 입출력
<ul>
<li>파일 입출력 대상을 as라는 키워드와 함께 코드를 간결하게 작성하도록 도와줌</li>
<li>어떤 블럭에 진입하고 나올 때, 지정된 객체로 하여금 그 시작과 끝에서 어떤 처리를 하도록 함
<ul>
<li>e.g.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>with open(file, mode) as f:
    f.read()
</code></pre>
<h3>persistence와 pickle</h3>
<ul>
<li>persistence 모듈: 프로그램을 종료한 후에도 사용한 데이터를 프로그램에서 다시 사용하게 함
<ul>
<li>DBM
<ul>
<li>데이터를 DBM 형식으로 파일에 기록함</li>
<li>anydbm 모듈을 사용하면 시스템 가용 모듈 중 DBM과 호환 가능한 최적의 모듈을 찾아줌</li>
<li>dictionary 자료형과 동일한 인터페이스</li>
<li>키와 값은 모두 문자열이어야 함</li>
</ul>
</li>
<li>marshal
<ul>
<li>기본 객체를 2진 포맷으로 저장
<ul>
<li>기본 객체: none, number, string, tuple, list, dictionary, code, etc.</li>
</ul>
</li>
<li>재귀적인 사전이나 리스트는 처리할 수 없음</li>
<li>pyc 파일의 컴파일된 코드를 읽고 쓰는 데 사용됨</li>
<li>일반 객체에는 pickle 모듈을 사용해야 함</li>
</ul>
</li>
<li>shelve
<ul>
<li>anydbm와 유사하나, 다만 임의의 파이썬 객체가 값으로 사용됨</li>
<li>객체 저장을 위해서는 cPickle 모듈을 사용함</li>
</ul>
</li>
<li>pickle
<ul>
<li>객체를 파일에 저장하는 개념</li>
<li>객체의 상태를 그대로 저장함</li>
<li>복잡한 자료형을 텍스트 형태나 2진 파일 등으로 변환하여 저장하거나, 네트워크를 통해 다른 시스템으로 전달 가능함</li>
<li>원래의 객체 형태로 복원도 가능함</li>
<li>장점
<ul>
<li>기본 객체 및 사용자 클래스, 인스턴스를 저장함</li>
<li>서로 참조되는 객체들의 관계까지도 저장함</li>
<li>재귀적인 관계도 모두 처리함</li>
<li>디버깅을 쉽게 하고 문제가 생겼을 때 일반 텍스트 에디터로 쉽게 복구 가능</li>
</ul>
</li>
<li>단점
<ul>
<li>파일의 용량이 큼</li>
<li>처리 속도가 느림
<ul>
<li>cPickle을 사용해 속도를 보완할 수 있음</li>
</ul>
</li>
</ul>
</li>
<li><code>import pickle (또는 cPickle)</code>
<ul>
<li><code>pickle.dump (output_object, file_object)</code>	// 파일 객체를 출력함</li>
<li><code>file_object = pickle.load</code>			        // 파일에서 객체를 읽어들임</li>
<li><code>S(file object)</code>				    	        // 문자열로 객체를 출력</li>
<li><code>object = pickle.loads(S)</code>			        // 문자열에서 객체를 다시 읽어들임</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>XML 모듈</h3>
<ul>
<li>웹서비스: 네트워크상에서 서로 다른 종류의 컴퓨터들간 상호작용을 위한 서비스 지향적 분산 컴퓨팅 기술
<ul>
<li>SOAP, WSDL, UDDI 등의 표준 기술들에 기반</li>
<li>메시징 작업을 이용해 데이터를 전송
<ul>
<li>document style: XML
<ul>
<li>HTML과 유사하지만 보다 더 구조화됨</li>
<li>모든 데이터형은 string임</li>
<li>tree 구조로 간단한 비교/연산 과정 = 빠른 처리 속도</li>
<li>데이터 구조화는 XSL로 표현, 다양한 데이터형으로 동시저장 = 접근이 용이</li>
<li>linking과 stylesheets에 대한 자체적 표준을 가짐</li>
<li>SGML의 특정 측면 중 하나</li>
</ul>
</li>
<li>dictionary/list/etc. : JSON</li>
</ul>
</li>
</ul>
</li>
<li>XML모듈은 XML parsing 방법인 SAX와 DOM을 사용함
<ul>
<li>패키지의 네임스페이스로 나타냄</li>
<li>data들을 문법에 맞게 분석하여 새롭게 구성</li>
<li>SAX: tree를 만들 때, 응용프로그램의 작업을 수행하기 위해 data를 이용</li>
<li>DOM: tree를 만들고 나서, 응용프로그램이 tree를 이용해 작업 수행</li>
<li>xml.etree.ElementTree
<ul>
<li>DOM을 pythonic하게 쓰기 위한 것</li>
<li>element 중심으로 트리를 구성</li>
<li>DOM에서는 node로 트리가 구성되며, element는 node의 일종으로 취급됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>JSON 모듈</h3>
<ul>
<li>XML의 자료가 클 경우 XML 파싱을 위해 모드를 모두 메모리에 올려놓고 작업함</li>
<li>파싱 자체가 부하가 걸리거나 실패하는 경우가 많음</li>
<li>이럴 때 JSON을 활용
<ul>
<li>데이터 교환용으로 설계된 텍스트 기반 경량 개방형 표준</li>
<li>자바스크립트의 문법 및 객체 표기법을 사용</li>
<li>application/json</li>
<li>주로 서버와 웹앱간에 데이터를 전송하는데 사용</li>
<li>platform-agnostic</li>
<li>language-agnostic</li>
<li>JSON 전용 파서 기능이 웹브라우저에 내장되어 있음</li>
<li>XML보다 가볍고 빠름</li>
<li>string 뿐만 아니라 여러가지 data type을 지원</li>
</ul>
</li>
<li>JSON 네임스페이스는 XML과 JSON간 변환에 사용함</li>
</ul>
<h3>네트워크</h3>
<ul>
<li>TCP/IP 프로토콜
<ul>
<li>Application layer: NFS, TFTP, HTTP, SMTP 등 TCP 또는 UDP를 사용하는 응용 서비스</li>
<li>Socket interface: 소프트웨어로 작성된 통신 접속점이며 이를 통해 응용프로그램이 TCP/IP 사용</li>
<li>Transport layer: 호스트 사이의 종점간 연결을 제공, TCP와 UDP로 구성</li>
<li>Internet layer: 비연결형 서비스, 데이터그램 방식으로 호스트간 IP패킷을 전달, 라우팅 수행 등</li>
<li>Network access layer: IP패킷의 물리적인 전달을 담당하는 서브네트워크 기능</li>
</ul>
</li>
<li>sockets 모듈
<ul>
<li>파이썬에서는 sockets 모듈을 통해 망 연결 및 데이터 검색을 쉽게 해줌</li>
<li>socket(socket_family, socket_type, protocol=0)</li>
<li>TCP는 출발과 도착을 연결하는 하나의 연결통로를 설정해 데이터를 전송하거나 받음</li>
<li>TCP는 다른 두 개의 소켓이 연결되는 것에서부터 시작됨</li>
<li>서버와 클라이언트에서 각각 socket()을 생성함
<ul>
<li>→ 서버에서 bind()로 주소와 소켓을 결합시킴</li>
<li>→ 서버에서 listen()을 통해 서버는 접속 요청을 대기하게 됨
<ul>
<li>클라이언트에서 connect()로 서버에 연결 요청을 함
<ul>
<li>→ 서버는 accept()로 연결 요청을 수락함</li>
<li>서버와 클라이언트간 send()와 receive()를 통해 통신을 하게 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>server socket은 항상 클라이언트의 접속을 대기함
<ul>
<li>클라이언트가 접속하면 새로운 소켓을 만들어 클라이언트와 접속 후 다시 대기함</li>
</ul>
</li>
<li>client socket은 새로 만들어진 소켓과 데이터를 전송함</li>
</ul>
</li>
</ul>
<h3>웹 어플리케이션</h3>
<ul>
<li>웹 클라이언트용 API와 웹 서버 API로 나뉨</li>
<li>웹 서버단은 http모듈을 사용
<ul>
<li>client: 클라이언트의 정보값을 가지고 연동하는 네임스페이스
<ul>
<li>HTTPConnection, HTTPMessage, HTTPResponse 등</li>
</ul>
</li>
<li>cookiejar: 쿠키의 모든 정보를 포함</li>
<li>cookies: 쿠키의 속성값 정보를 포함</li>
<li>server: HTTP 서버를 구축할 수 있는 BaseHTTPSRequestHandler, CGIHTTPRequestHander, HTTPServer, SimpleHTTPRequestHandler 등의 클래스를 포함함</li>
</ul>
</li>
<li>웹 클라이언트단은 urllib 라이브러리를 사용
<ul>
<li>urllib: HTTP, FTP, file 등의 처리가 동시에 가능
<ul>
<li>웹페이지 탐색, 데이터 액세스 구문분석 등을 GET과 POST 방식으로 URL 요청</li>
<li>다운로드한 데이터를 액세스해 헤더를 수정</li>
<li>서버의 정보 추출에 사용됨</li>
<li><code>urllib.request.urlopen(url, data=none, timeout)</code></li>
</ul>
</li>
<li>urllib2: 리퀘스트 시점에 헤더 정보를 입력하게 해줌</li>
</ul>
</li>
<li>HTTP클라이언트(브라우저)가 url 경로와 쿠키를 포함한 request를 HTTP GET/POST를 통해 전송
<ul>
<li>→ 웹 서버가 HTTP코드로써 그 내용을 포함해 response를 HTTP 클라이언트에 전송</li>
</ul>
</li>
</ul>
<h3>데이터베이스</h3>
<ul>
<li>SQLite3
<ul>
<li>오프라인에서 애플리케이션에 넣어 사용하는 경량의 임베디드 데이터베이스</li>
<li>DBMS와 달리 API는 단순히 라이브러리를 호출함</li>
<li>데이터 저장시 하나의 파일만 사용함</li>
<li>안드로이드 SDK에도 내장되어 있음</li>
<li>장점
<ul>
<li>크기가 작고 간결하기 때문에 로컬에서 간단한 DB 구성에 활용</li>
<li>서버를 포함한 네트워크 구성이 필요 없음</li>
<li>데이터의 처리가 빠름</li>
<li>cross-platform, open-source</li>
</ul>
</li>
<li>단점
<ul>
<li>DB 엔진 자체가 호스트 프로그램에 임베딩되므로 호스트 프로그램이 DB 처리에 관한 부하를 모두 부담해야 함</li>
</ul>
</li>
</ul>
</li>
<li>pySQLite3 모듈
<ul>
<li>파이썬에 내장된 모듈이므로 별도 설치 필요 없음</li>
<li>connection 클래스
<ul>
<li>데이터를 생성</li>
<li>연결된 데이터베이스를 동작시키는 역할</li>
</ul>
</li>
<li>cursor 클래스
<ul>
<li>SQL 문장을 수행함</li>
<li>조회된 결과를 가져옴</li>
</ul>
</li>
<li>row 클래스
<ul>
<li>조회된 결과의 한 행을 보여줌</li>
</ul>
</li>
<li>SQLite3의 자료형: null / integer / real / text / blob
<ul>
<li>PySQLite3의 자료형: none / int / float / str, bytes / buffer</li>
</ul>
</li>
<li>내장 집계 함수
<ul>
<li>SQLite3에 내장되어 있는 집계 함수를 활용해 결과값의 가공이 가능
<ul>
<li>e.g. 특정 필드의 최댓값 등의 수치연산, 조건 충족하는 튜플의 갯수 찾기</li>
<li>e.g. 대소문자가 섞여있는 데이터가 정렬이 제대로 되지 않을 때 일괄 소문자 변환
<ul>
<li><code>connection.create_collation()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CSV 모듈
<ul>
<li>CSV: 각 항목들의 값이 콤마로 분리되어 있고, 행은 개행문자로 구분하는 파일 포맷
<ul>
<li>텍스트 형태이므로 열람과 편집이 쉬움</li>
<li>수많은 애플리케이션에서 취급하는 범용 형식</li>
<li>빅데이터 분석에도 주로 활용됨</li>
</ul>
</li>
<li><code>CSV.DictReader(CSVfile, fieldnames=none, restkey=none, restval=none, dialect='file_format' *args, *kwargs)</code></li>
</ul>
</li>
</ul>

    </div>
    
    <div class="mt-20 md:mt-32 lg:mt-32 xl:mt-32"></div>
</article>
        
    </main>
    <footer class="mt-20 px-10 py-8 bg-gray-200">
    <div class="max-w-5xl mx-auto text-gray-700 text-center">
        © 2022 <a href="/" class="font-medium" target="_blank" rel="noopener">devfreedom.github.io</a> by 
        <a href="https://devfreedom.github.io" target="_blank" rel="noopener">devfreedom</a> 
    </div>
</footer>
    <script src="/assets/js/bundle.js"></script>
</body>

</html>